# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.1
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

"""
IDA Plugin SDK API wrapper: typeinf
"""

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _ida_typeinf
else:
    import _ida_typeinf

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """
    Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass
    """
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """
    Meta class to enforce nondynamic attributes (no new attributes) for a class
    """
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import weakref

SWIG_PYTHON_LEGACY_BOOL = _ida_typeinf.SWIG_PYTHON_LEGACY_BOOL

import ida_idaapi


import sys
_BC695 = sys.modules["__main__"].IDAPYTHON_COMPAT_695_API

if _BC695:






    def bc695redef(func):
        ida_idaapi._BC695.replace_fun(func)
        return func

import ida_idp
class funcargvec_t(object):
    r"""
    Proxy of C++ qvector< funcarg_t > class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        __init__(self) -> funcargvec_t
            x: qvector< funcarg_t > const &
        """
        _ida_typeinf.funcargvec_t_swiginit(self, _ida_typeinf.new_funcargvec_t(*args))
    __swig_destroy__ = _ida_typeinf.delete_funcargvec_t

    def push_back(self, *args) -> "funcarg_t &":
        r"""


        push_back(self, x)
            x: funcarg_t const &
        """
        return _ida_typeinf.funcargvec_t_push_back(self, *args)

    def pop_back(self, *args) -> "void":
        r"""
        pop_back(self)
        """
        return _ida_typeinf.funcargvec_t_pop_back(self, *args)

    def size(self, *args) -> "size_t":
        r"""
        size(self) -> size_t
        """
        return _ida_typeinf.funcargvec_t_size(self, *args)

    def empty(self, *args) -> "bool":
        r"""
        empty(self) -> bool
        """
        return _ida_typeinf.funcargvec_t_empty(self, *args)

    def at(self, *args) -> "funcarg_t const &":
        r"""


        at(self, _idx) -> funcarg_t
            _idx: size_t
        """
        return _ida_typeinf.funcargvec_t_at(self, *args)

    def qclear(self, *args) -> "void":
        r"""
        qclear(self)
        """
        return _ida_typeinf.funcargvec_t_qclear(self, *args)

    def clear(self, *args) -> "void":
        r"""
        clear(self)
        """
        return _ida_typeinf.funcargvec_t_clear(self, *args)

    def resize(self, *args) -> "void":
        r"""


        resize(self, _newsize, x)
            _newsize: size_t
            x: funcarg_t const &
        

        resize(self, _newsize)
            _newsize: size_t
        """
        return _ida_typeinf.funcargvec_t_resize(self, *args)

    def grow(self, *args) -> "void":
        r"""


        grow(self, x=funcarg_t())
            x: funcarg_t const &
        """
        return _ida_typeinf.funcargvec_t_grow(self, *args)

    def capacity(self, *args) -> "size_t":
        r"""
        capacity(self) -> size_t
        """
        return _ida_typeinf.funcargvec_t_capacity(self, *args)

    def reserve(self, *args) -> "void":
        r"""


        reserve(self, cnt)
            cnt: size_t
        """
        return _ida_typeinf.funcargvec_t_reserve(self, *args)

    def truncate(self, *args) -> "void":
        r"""
        truncate(self)
        """
        return _ida_typeinf.funcargvec_t_truncate(self, *args)

    def swap(self, *args) -> "void":
        r"""


        swap(self, r)
            r: qvector< funcarg_t > &
        """
        return _ida_typeinf.funcargvec_t_swap(self, *args)

    def extract(self, *args) -> "funcarg_t *":
        r"""
        extract(self) -> funcarg_t
        """
        return _ida_typeinf.funcargvec_t_extract(self, *args)

    def inject(self, *args) -> "void":
        r"""


        inject(self, s, len)
            s: funcarg_t *
            len: size_t
        """
        return _ida_typeinf.funcargvec_t_inject(self, *args)

    def __eq__(self, *args) -> "bool":
        r"""


        __eq__(self, r) -> bool
            r: qvector< funcarg_t > const &
        """
        return _ida_typeinf.funcargvec_t___eq__(self, *args)

    def __ne__(self, *args) -> "bool":
        r"""


        __ne__(self, r) -> bool
            r: qvector< funcarg_t > const &
        """
        return _ida_typeinf.funcargvec_t___ne__(self, *args)

    def begin(self, *args) -> "qvector< funcarg_t >::const_iterator":
        r"""
        begin(self) -> funcarg_t
        begin(self) -> funcarg_t
        """
        return _ida_typeinf.funcargvec_t_begin(self, *args)

    def end(self, *args) -> "qvector< funcarg_t >::const_iterator":
        r"""
        end(self) -> funcarg_t
        end(self) -> funcarg_t
        """
        return _ida_typeinf.funcargvec_t_end(self, *args)

    def insert(self, *args) -> "qvector< funcarg_t >::iterator":
        r"""


        insert(self, it, x) -> funcarg_t
            it: qvector< funcarg_t >::iterator
            x: funcarg_t const &
        """
        return _ida_typeinf.funcargvec_t_insert(self, *args)

    def erase(self, *args) -> "qvector< funcarg_t >::iterator":
        r"""


        erase(self, it) -> funcarg_t
            it: qvector< funcarg_t >::iterator
        

        erase(self, first, last) -> funcarg_t
            first: qvector< funcarg_t >::iterator
            last: qvector< funcarg_t >::iterator
        """
        return _ida_typeinf.funcargvec_t_erase(self, *args)

    def find(self, *args) -> "qvector< funcarg_t >::const_iterator":
        r"""


        find(self, x) -> funcarg_t
            x: funcarg_t const &
        

        find(self, x) -> funcarg_t
            x: funcarg_t const &
        """
        return _ida_typeinf.funcargvec_t_find(self, *args)

    def has(self, *args) -> "bool":
        r"""


        has(self, x) -> bool
            x: funcarg_t const &
        """
        return _ida_typeinf.funcargvec_t_has(self, *args)

    def add_unique(self, *args) -> "bool":
        r"""


        add_unique(self, x) -> bool
            x: funcarg_t const &
        """
        return _ida_typeinf.funcargvec_t_add_unique(self, *args)

    def _del(self, *args) -> "bool":
        r"""


        _del(self, x) -> bool
            x: funcarg_t const &
        """
        return _ida_typeinf.funcargvec_t__del(self, *args)

    def __len__(self, *args) -> "size_t":
        r"""
        __len__(self) -> size_t
        """
        return _ida_typeinf.funcargvec_t___len__(self, *args)

    def __getitem__(self, *args) -> "funcarg_t const &":
        r"""


        __getitem__(self, i) -> funcarg_t
            i: size_t
        """
        return _ida_typeinf.funcargvec_t___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        r"""


        __setitem__(self, i, v)
            i: size_t
            v: funcarg_t const &
        """
        return _ida_typeinf.funcargvec_t___setitem__(self, *args)

    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator


# Register funcargvec_t in _ida_typeinf:
_ida_typeinf.funcargvec_t_swigregister(funcargvec_t)

class udtmembervec_t(object):
    r"""
    Proxy of C++ qvector< udt_member_t > class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        __init__(self) -> udtmembervec_t
            x: qvector< udt_member_t > const &
        """
        _ida_typeinf.udtmembervec_t_swiginit(self, _ida_typeinf.new_udtmembervec_t(*args))
    __swig_destroy__ = _ida_typeinf.delete_udtmembervec_t

    def push_back(self, *args) -> "udt_member_t &":
        r"""


        push_back(self, x)
            x: udt_member_t const &
        """
        return _ida_typeinf.udtmembervec_t_push_back(self, *args)

    def pop_back(self, *args) -> "void":
        r"""
        pop_back(self)
        """
        return _ida_typeinf.udtmembervec_t_pop_back(self, *args)

    def size(self, *args) -> "size_t":
        r"""
        size(self) -> size_t
        """
        return _ida_typeinf.udtmembervec_t_size(self, *args)

    def empty(self, *args) -> "bool":
        r"""
        empty(self) -> bool
        """
        return _ida_typeinf.udtmembervec_t_empty(self, *args)

    def at(self, *args) -> "udt_member_t const &":
        r"""


        at(self, _idx) -> udt_member_t
            _idx: size_t
        """
        return _ida_typeinf.udtmembervec_t_at(self, *args)

    def qclear(self, *args) -> "void":
        r"""
        qclear(self)
        """
        return _ida_typeinf.udtmembervec_t_qclear(self, *args)

    def clear(self, *args) -> "void":
        r"""
        clear(self)
        """
        return _ida_typeinf.udtmembervec_t_clear(self, *args)

    def resize(self, *args) -> "void":
        r"""


        resize(self, _newsize, x)
            _newsize: size_t
            x: udt_member_t const &
        

        resize(self, _newsize)
            _newsize: size_t
        """
        return _ida_typeinf.udtmembervec_t_resize(self, *args)

    def grow(self, *args) -> "void":
        r"""


        grow(self, x=udt_member_t())
            x: udt_member_t const &
        """
        return _ida_typeinf.udtmembervec_t_grow(self, *args)

    def capacity(self, *args) -> "size_t":
        r"""
        capacity(self) -> size_t
        """
        return _ida_typeinf.udtmembervec_t_capacity(self, *args)

    def reserve(self, *args) -> "void":
        r"""


        reserve(self, cnt)
            cnt: size_t
        """
        return _ida_typeinf.udtmembervec_t_reserve(self, *args)

    def truncate(self, *args) -> "void":
        r"""
        truncate(self)
        """
        return _ida_typeinf.udtmembervec_t_truncate(self, *args)

    def swap(self, *args) -> "void":
        r"""


        swap(self, r)
            r: qvector< udt_member_t > &
        """
        return _ida_typeinf.udtmembervec_t_swap(self, *args)

    def extract(self, *args) -> "udt_member_t *":
        r"""
        extract(self) -> udt_member_t
        """
        return _ida_typeinf.udtmembervec_t_extract(self, *args)

    def inject(self, *args) -> "void":
        r"""


        inject(self, s, len)
            s: udt_member_t *
            len: size_t
        """
        return _ida_typeinf.udtmembervec_t_inject(self, *args)

    def __eq__(self, *args) -> "bool":
        r"""


        __eq__(self, r) -> bool
            r: qvector< udt_member_t > const &
        """
        return _ida_typeinf.udtmembervec_t___eq__(self, *args)

    def __ne__(self, *args) -> "bool":
        r"""


        __ne__(self, r) -> bool
            r: qvector< udt_member_t > const &
        """
        return _ida_typeinf.udtmembervec_t___ne__(self, *args)

    def begin(self, *args) -> "qvector< udt_member_t >::const_iterator":
        r"""
        begin(self) -> udt_member_t
        begin(self) -> udt_member_t
        """
        return _ida_typeinf.udtmembervec_t_begin(self, *args)

    def end(self, *args) -> "qvector< udt_member_t >::const_iterator":
        r"""
        end(self) -> udt_member_t
        end(self) -> udt_member_t
        """
        return _ida_typeinf.udtmembervec_t_end(self, *args)

    def insert(self, *args) -> "qvector< udt_member_t >::iterator":
        r"""


        insert(self, it, x) -> udt_member_t
            it: qvector< udt_member_t >::iterator
            x: udt_member_t const &
        """
        return _ida_typeinf.udtmembervec_t_insert(self, *args)

    def erase(self, *args) -> "qvector< udt_member_t >::iterator":
        r"""


        erase(self, it) -> udt_member_t
            it: qvector< udt_member_t >::iterator
        

        erase(self, first, last) -> udt_member_t
            first: qvector< udt_member_t >::iterator
            last: qvector< udt_member_t >::iterator
        """
        return _ida_typeinf.udtmembervec_t_erase(self, *args)

    def find(self, *args) -> "qvector< udt_member_t >::const_iterator":
        r"""


        find(self, x) -> udt_member_t
            x: udt_member_t const &
        

        find(self, x) -> udt_member_t
            x: udt_member_t const &
        """
        return _ida_typeinf.udtmembervec_t_find(self, *args)

    def has(self, *args) -> "bool":
        r"""


        has(self, x) -> bool
            x: udt_member_t const &
        """
        return _ida_typeinf.udtmembervec_t_has(self, *args)

    def add_unique(self, *args) -> "bool":
        r"""


        add_unique(self, x) -> bool
            x: udt_member_t const &
        """
        return _ida_typeinf.udtmembervec_t_add_unique(self, *args)

    def _del(self, *args) -> "bool":
        r"""


        _del(self, x) -> bool
            x: udt_member_t const &
        """
        return _ida_typeinf.udtmembervec_t__del(self, *args)

    def __len__(self, *args) -> "size_t":
        r"""
        __len__(self) -> size_t
        """
        return _ida_typeinf.udtmembervec_t___len__(self, *args)

    def __getitem__(self, *args) -> "udt_member_t const &":
        r"""


        __getitem__(self, i) -> udt_member_t
            i: size_t
        """
        return _ida_typeinf.udtmembervec_t___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        r"""


        __setitem__(self, i, v)
            i: size_t
            v: udt_member_t const &
        """
        return _ida_typeinf.udtmembervec_t___setitem__(self, *args)

    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator


# Register udtmembervec_t in _ida_typeinf:
_ida_typeinf.udtmembervec_t_swigregister(udtmembervec_t)

class reginfovec_t(object):
    r"""
    Proxy of C++ qvector< reg_info_t > class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        __init__(self) -> reginfovec_t
            x: qvector< reg_info_t > const &
        """
        _ida_typeinf.reginfovec_t_swiginit(self, _ida_typeinf.new_reginfovec_t(*args))
    __swig_destroy__ = _ida_typeinf.delete_reginfovec_t

    def push_back(self, *args) -> "reg_info_t &":
        r"""


        push_back(self, x)
            x: reg_info_t const &
        """
        return _ida_typeinf.reginfovec_t_push_back(self, *args)

    def pop_back(self, *args) -> "void":
        r"""
        pop_back(self)
        """
        return _ida_typeinf.reginfovec_t_pop_back(self, *args)

    def size(self, *args) -> "size_t":
        r"""
        size(self) -> size_t
        """
        return _ida_typeinf.reginfovec_t_size(self, *args)

    def empty(self, *args) -> "bool":
        r"""
        empty(self) -> bool
        """
        return _ida_typeinf.reginfovec_t_empty(self, *args)

    def at(self, *args) -> "reg_info_t const &":
        r"""


        at(self, _idx) -> reg_info_t
            _idx: size_t
        """
        return _ida_typeinf.reginfovec_t_at(self, *args)

    def qclear(self, *args) -> "void":
        r"""
        qclear(self)
        """
        return _ida_typeinf.reginfovec_t_qclear(self, *args)

    def clear(self, *args) -> "void":
        r"""
        clear(self)
        """
        return _ida_typeinf.reginfovec_t_clear(self, *args)

    def resize(self, *args) -> "void":
        r"""


        resize(self, _newsize, x)
            _newsize: size_t
            x: reg_info_t const &
        

        resize(self, _newsize)
            _newsize: size_t
        """
        return _ida_typeinf.reginfovec_t_resize(self, *args)

    def grow(self, *args) -> "void":
        r"""


        grow(self, x=reg_info_t())
            x: reg_info_t const &
        """
        return _ida_typeinf.reginfovec_t_grow(self, *args)

    def capacity(self, *args) -> "size_t":
        r"""
        capacity(self) -> size_t
        """
        return _ida_typeinf.reginfovec_t_capacity(self, *args)

    def reserve(self, *args) -> "void":
        r"""


        reserve(self, cnt)
            cnt: size_t
        """
        return _ida_typeinf.reginfovec_t_reserve(self, *args)

    def truncate(self, *args) -> "void":
        r"""
        truncate(self)
        """
        return _ida_typeinf.reginfovec_t_truncate(self, *args)

    def swap(self, *args) -> "void":
        r"""


        swap(self, r)
            r: qvector< reg_info_t > &
        """
        return _ida_typeinf.reginfovec_t_swap(self, *args)

    def extract(self, *args) -> "reg_info_t *":
        r"""
        extract(self) -> reg_info_t
        """
        return _ida_typeinf.reginfovec_t_extract(self, *args)

    def inject(self, *args) -> "void":
        r"""


        inject(self, s, len)
            s: reg_info_t *
            len: size_t
        """
        return _ida_typeinf.reginfovec_t_inject(self, *args)

    def __eq__(self, *args) -> "bool":
        r"""


        __eq__(self, r) -> bool
            r: qvector< reg_info_t > const &
        """
        return _ida_typeinf.reginfovec_t___eq__(self, *args)

    def __ne__(self, *args) -> "bool":
        r"""


        __ne__(self, r) -> bool
            r: qvector< reg_info_t > const &
        """
        return _ida_typeinf.reginfovec_t___ne__(self, *args)

    def begin(self, *args) -> "qvector< reg_info_t >::const_iterator":
        r"""
        begin(self) -> reg_info_t
        begin(self) -> reg_info_t
        """
        return _ida_typeinf.reginfovec_t_begin(self, *args)

    def end(self, *args) -> "qvector< reg_info_t >::const_iterator":
        r"""
        end(self) -> reg_info_t
        end(self) -> reg_info_t
        """
        return _ida_typeinf.reginfovec_t_end(self, *args)

    def insert(self, *args) -> "qvector< reg_info_t >::iterator":
        r"""


        insert(self, it, x) -> reg_info_t
            it: qvector< reg_info_t >::iterator
            x: reg_info_t const &
        """
        return _ida_typeinf.reginfovec_t_insert(self, *args)

    def erase(self, *args) -> "qvector< reg_info_t >::iterator":
        r"""


        erase(self, it) -> reg_info_t
            it: qvector< reg_info_t >::iterator
        

        erase(self, first, last) -> reg_info_t
            first: qvector< reg_info_t >::iterator
            last: qvector< reg_info_t >::iterator
        """
        return _ida_typeinf.reginfovec_t_erase(self, *args)

    def find(self, *args) -> "qvector< reg_info_t >::const_iterator":
        r"""


        find(self, x) -> reg_info_t
            x: reg_info_t const &
        

        find(self, x) -> reg_info_t
            x: reg_info_t const &
        """
        return _ida_typeinf.reginfovec_t_find(self, *args)

    def has(self, *args) -> "bool":
        r"""


        has(self, x) -> bool
            x: reg_info_t const &
        """
        return _ida_typeinf.reginfovec_t_has(self, *args)

    def add_unique(self, *args) -> "bool":
        r"""


        add_unique(self, x) -> bool
            x: reg_info_t const &
        """
        return _ida_typeinf.reginfovec_t_add_unique(self, *args)

    def _del(self, *args) -> "bool":
        r"""


        _del(self, x) -> bool
            x: reg_info_t const &
        """
        return _ida_typeinf.reginfovec_t__del(self, *args)

    def __len__(self, *args) -> "size_t":
        r"""
        __len__(self) -> size_t
        """
        return _ida_typeinf.reginfovec_t___len__(self, *args)

    def __getitem__(self, *args) -> "reg_info_t const &":
        r"""


        __getitem__(self, i) -> reg_info_t
            i: size_t
        """
        return _ida_typeinf.reginfovec_t___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        r"""


        __setitem__(self, i, v)
            i: size_t
            v: reg_info_t const &
        """
        return _ida_typeinf.reginfovec_t___setitem__(self, *args)

    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator


# Register reginfovec_t in _ida_typeinf:
_ida_typeinf.reginfovec_t_swigregister(reginfovec_t)

class enum_member_vec_t(object):
    r"""
    Proxy of C++ qvector< enum_member_t > class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        __init__(self) -> enum_member_vec_t
            x: qvector< enum_member_t > const &
        """
        _ida_typeinf.enum_member_vec_t_swiginit(self, _ida_typeinf.new_enum_member_vec_t(*args))
    __swig_destroy__ = _ida_typeinf.delete_enum_member_vec_t

    def push_back(self, *args) -> "enum_member_t &":
        r"""


        push_back(self, x)
            x: enum_member_t const &
        """
        return _ida_typeinf.enum_member_vec_t_push_back(self, *args)

    def pop_back(self, *args) -> "void":
        r"""
        pop_back(self)
        """
        return _ida_typeinf.enum_member_vec_t_pop_back(self, *args)

    def size(self, *args) -> "size_t":
        r"""
        size(self) -> size_t
        """
        return _ida_typeinf.enum_member_vec_t_size(self, *args)

    def empty(self, *args) -> "bool":
        r"""
        empty(self) -> bool
        """
        return _ida_typeinf.enum_member_vec_t_empty(self, *args)

    def at(self, *args) -> "enum_member_t const &":
        r"""


        at(self, _idx) -> enum_member_t
            _idx: size_t
        """
        return _ida_typeinf.enum_member_vec_t_at(self, *args)

    def qclear(self, *args) -> "void":
        r"""
        qclear(self)
        """
        return _ida_typeinf.enum_member_vec_t_qclear(self, *args)

    def clear(self, *args) -> "void":
        r"""
        clear(self)
        """
        return _ida_typeinf.enum_member_vec_t_clear(self, *args)

    def resize(self, *args) -> "void":
        r"""


        resize(self, _newsize, x)
            _newsize: size_t
            x: enum_member_t const &
        

        resize(self, _newsize)
            _newsize: size_t
        """
        return _ida_typeinf.enum_member_vec_t_resize(self, *args)

    def grow(self, *args) -> "void":
        r"""


        grow(self, x=enum_member_t())
            x: enum_member_t const &
        """
        return _ida_typeinf.enum_member_vec_t_grow(self, *args)

    def capacity(self, *args) -> "size_t":
        r"""
        capacity(self) -> size_t
        """
        return _ida_typeinf.enum_member_vec_t_capacity(self, *args)

    def reserve(self, *args) -> "void":
        r"""


        reserve(self, cnt)
            cnt: size_t
        """
        return _ida_typeinf.enum_member_vec_t_reserve(self, *args)

    def truncate(self, *args) -> "void":
        r"""
        truncate(self)
        """
        return _ida_typeinf.enum_member_vec_t_truncate(self, *args)

    def swap(self, *args) -> "void":
        r"""


        swap(self, r)
            r: qvector< enum_member_t > &
        """
        return _ida_typeinf.enum_member_vec_t_swap(self, *args)

    def extract(self, *args) -> "enum_member_t *":
        r"""
        extract(self) -> enum_member_t
        """
        return _ida_typeinf.enum_member_vec_t_extract(self, *args)

    def inject(self, *args) -> "void":
        r"""


        inject(self, s, len)
            s: enum_member_t *
            len: size_t
        """
        return _ida_typeinf.enum_member_vec_t_inject(self, *args)

    def __eq__(self, *args) -> "bool":
        r"""


        __eq__(self, r) -> bool
            r: qvector< enum_member_t > const &
        """
        return _ida_typeinf.enum_member_vec_t___eq__(self, *args)

    def __ne__(self, *args) -> "bool":
        r"""


        __ne__(self, r) -> bool
            r: qvector< enum_member_t > const &
        """
        return _ida_typeinf.enum_member_vec_t___ne__(self, *args)

    def begin(self, *args) -> "qvector< enum_member_t >::const_iterator":
        r"""
        begin(self) -> enum_member_t
        begin(self) -> enum_member_t
        """
        return _ida_typeinf.enum_member_vec_t_begin(self, *args)

    def end(self, *args) -> "qvector< enum_member_t >::const_iterator":
        r"""
        end(self) -> enum_member_t
        end(self) -> enum_member_t
        """
        return _ida_typeinf.enum_member_vec_t_end(self, *args)

    def insert(self, *args) -> "qvector< enum_member_t >::iterator":
        r"""


        insert(self, it, x) -> enum_member_t
            it: qvector< enum_member_t >::iterator
            x: enum_member_t const &
        """
        return _ida_typeinf.enum_member_vec_t_insert(self, *args)

    def erase(self, *args) -> "qvector< enum_member_t >::iterator":
        r"""


        erase(self, it) -> enum_member_t
            it: qvector< enum_member_t >::iterator
        

        erase(self, first, last) -> enum_member_t
            first: qvector< enum_member_t >::iterator
            last: qvector< enum_member_t >::iterator
        """
        return _ida_typeinf.enum_member_vec_t_erase(self, *args)

    def find(self, *args) -> "qvector< enum_member_t >::const_iterator":
        r"""


        find(self, x) -> enum_member_t
            x: enum_member_t const &
        

        find(self, x) -> enum_member_t
            x: enum_member_t const &
        """
        return _ida_typeinf.enum_member_vec_t_find(self, *args)

    def has(self, *args) -> "bool":
        r"""


        has(self, x) -> bool
            x: enum_member_t const &
        """
        return _ida_typeinf.enum_member_vec_t_has(self, *args)

    def add_unique(self, *args) -> "bool":
        r"""


        add_unique(self, x) -> bool
            x: enum_member_t const &
        """
        return _ida_typeinf.enum_member_vec_t_add_unique(self, *args)

    def _del(self, *args) -> "bool":
        r"""


        _del(self, x) -> bool
            x: enum_member_t const &
        """
        return _ida_typeinf.enum_member_vec_t__del(self, *args)

    def __len__(self, *args) -> "size_t":
        r"""
        __len__(self) -> size_t
        """
        return _ida_typeinf.enum_member_vec_t___len__(self, *args)

    def __getitem__(self, *args) -> "enum_member_t const &":
        r"""


        __getitem__(self, i) -> enum_member_t
            i: size_t
        """
        return _ida_typeinf.enum_member_vec_t___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        r"""


        __setitem__(self, i, v)
            i: size_t
            v: enum_member_t const &
        """
        return _ida_typeinf.enum_member_vec_t___setitem__(self, *args)

    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator


# Register enum_member_vec_t in _ida_typeinf:
_ida_typeinf.enum_member_vec_t_swigregister(enum_member_vec_t)

class argpartvec_t(object):
    r"""
    Proxy of C++ qvector< argpart_t > class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        __init__(self) -> argpartvec_t
            x: qvector< argpart_t > const &
        """
        _ida_typeinf.argpartvec_t_swiginit(self, _ida_typeinf.new_argpartvec_t(*args))
    __swig_destroy__ = _ida_typeinf.delete_argpartvec_t

    def push_back(self, *args) -> "argpart_t &":
        r"""


        push_back(self, x)
            x: argpart_t const &
        """
        return _ida_typeinf.argpartvec_t_push_back(self, *args)

    def pop_back(self, *args) -> "void":
        r"""
        pop_back(self)
        """
        return _ida_typeinf.argpartvec_t_pop_back(self, *args)

    def size(self, *args) -> "size_t":
        r"""
        size(self) -> size_t
        """
        return _ida_typeinf.argpartvec_t_size(self, *args)

    def empty(self, *args) -> "bool":
        r"""
        empty(self) -> bool
        """
        return _ida_typeinf.argpartvec_t_empty(self, *args)

    def at(self, *args) -> "argpart_t const &":
        r"""


        at(self, _idx) -> argpart_t
            _idx: size_t
        """
        return _ida_typeinf.argpartvec_t_at(self, *args)

    def qclear(self, *args) -> "void":
        r"""
        qclear(self)
        """
        return _ida_typeinf.argpartvec_t_qclear(self, *args)

    def clear(self, *args) -> "void":
        r"""
        clear(self)
        """
        return _ida_typeinf.argpartvec_t_clear(self, *args)

    def resize(self, *args) -> "void":
        r"""


        resize(self, _newsize, x)
            _newsize: size_t
            x: argpart_t const &
        

        resize(self, _newsize)
            _newsize: size_t
        """
        return _ida_typeinf.argpartvec_t_resize(self, *args)

    def grow(self, *args) -> "void":
        r"""


        grow(self, x=argpart_t())
            x: argpart_t const &
        """
        return _ida_typeinf.argpartvec_t_grow(self, *args)

    def capacity(self, *args) -> "size_t":
        r"""
        capacity(self) -> size_t
        """
        return _ida_typeinf.argpartvec_t_capacity(self, *args)

    def reserve(self, *args) -> "void":
        r"""


        reserve(self, cnt)
            cnt: size_t
        """
        return _ida_typeinf.argpartvec_t_reserve(self, *args)

    def truncate(self, *args) -> "void":
        r"""
        truncate(self)
        """
        return _ida_typeinf.argpartvec_t_truncate(self, *args)

    def swap(self, *args) -> "void":
        r"""


        swap(self, r)
            r: qvector< argpart_t > &
        """
        return _ida_typeinf.argpartvec_t_swap(self, *args)

    def extract(self, *args) -> "argpart_t *":
        r"""
        extract(self) -> argpart_t
        """
        return _ida_typeinf.argpartvec_t_extract(self, *args)

    def inject(self, *args) -> "void":
        r"""


        inject(self, s, len)
            s: argpart_t *
            len: size_t
        """
        return _ida_typeinf.argpartvec_t_inject(self, *args)

    def __eq__(self, *args) -> "bool":
        r"""


        __eq__(self, r) -> bool
            r: qvector< argpart_t > const &
        """
        return _ida_typeinf.argpartvec_t___eq__(self, *args)

    def __ne__(self, *args) -> "bool":
        r"""


        __ne__(self, r) -> bool
            r: qvector< argpart_t > const &
        """
        return _ida_typeinf.argpartvec_t___ne__(self, *args)

    def begin(self, *args) -> "qvector< argpart_t >::const_iterator":
        r"""
        begin(self) -> argpart_t
        begin(self) -> argpart_t
        """
        return _ida_typeinf.argpartvec_t_begin(self, *args)

    def end(self, *args) -> "qvector< argpart_t >::const_iterator":
        r"""
        end(self) -> argpart_t
        end(self) -> argpart_t
        """
        return _ida_typeinf.argpartvec_t_end(self, *args)

    def insert(self, *args) -> "qvector< argpart_t >::iterator":
        r"""


        insert(self, it, x) -> argpart_t
            it: qvector< argpart_t >::iterator
            x: argpart_t const &
        """
        return _ida_typeinf.argpartvec_t_insert(self, *args)

    def erase(self, *args) -> "qvector< argpart_t >::iterator":
        r"""


        erase(self, it) -> argpart_t
            it: qvector< argpart_t >::iterator
        

        erase(self, first, last) -> argpart_t
            first: qvector< argpart_t >::iterator
            last: qvector< argpart_t >::iterator
        """
        return _ida_typeinf.argpartvec_t_erase(self, *args)

    def find(self, *args) -> "qvector< argpart_t >::const_iterator":
        r"""


        find(self, x) -> argpart_t
            x: argpart_t const &
        

        find(self, x) -> argpart_t
            x: argpart_t const &
        """
        return _ida_typeinf.argpartvec_t_find(self, *args)

    def has(self, *args) -> "bool":
        r"""


        has(self, x) -> bool
            x: argpart_t const &
        """
        return _ida_typeinf.argpartvec_t_has(self, *args)

    def add_unique(self, *args) -> "bool":
        r"""


        add_unique(self, x) -> bool
            x: argpart_t const &
        """
        return _ida_typeinf.argpartvec_t_add_unique(self, *args)

    def _del(self, *args) -> "bool":
        r"""


        _del(self, x) -> bool
            x: argpart_t const &
        """
        return _ida_typeinf.argpartvec_t__del(self, *args)

    def __len__(self, *args) -> "size_t":
        r"""
        __len__(self) -> size_t
        """
        return _ida_typeinf.argpartvec_t___len__(self, *args)

    def __getitem__(self, *args) -> "argpart_t const &":
        r"""


        __getitem__(self, i) -> argpart_t
            i: size_t
        """
        return _ida_typeinf.argpartvec_t___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        r"""


        __setitem__(self, i, v)
            i: size_t
            v: argpart_t const &
        """
        return _ida_typeinf.argpartvec_t___setitem__(self, *args)

    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator


# Register argpartvec_t in _ida_typeinf:
_ida_typeinf.argpartvec_t_swigregister(argpartvec_t)

class valstrvec_t(object):
    r"""
    Proxy of C++ qvector< valstr_t > class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        __init__(self) -> valstrvec_t
            x: qvector< valstr_t > const &
        """
        _ida_typeinf.valstrvec_t_swiginit(self, _ida_typeinf.new_valstrvec_t(*args))
    __swig_destroy__ = _ida_typeinf.delete_valstrvec_t

    def push_back(self, *args) -> "valstr_t &":
        r"""


        push_back(self, x)
            x: valstr_t const &
        """
        return _ida_typeinf.valstrvec_t_push_back(self, *args)

    def pop_back(self, *args) -> "void":
        r"""
        pop_back(self)
        """
        return _ida_typeinf.valstrvec_t_pop_back(self, *args)

    def size(self, *args) -> "size_t":
        r"""
        size(self) -> size_t
        """
        return _ida_typeinf.valstrvec_t_size(self, *args)

    def empty(self, *args) -> "bool":
        r"""
        empty(self) -> bool
        """
        return _ida_typeinf.valstrvec_t_empty(self, *args)

    def at(self, *args) -> "valstr_t const &":
        r"""


        at(self, _idx) -> valstr_t
            _idx: size_t
        """
        return _ida_typeinf.valstrvec_t_at(self, *args)

    def qclear(self, *args) -> "void":
        r"""
        qclear(self)
        """
        return _ida_typeinf.valstrvec_t_qclear(self, *args)

    def clear(self, *args) -> "void":
        r"""
        clear(self)
        """
        return _ida_typeinf.valstrvec_t_clear(self, *args)

    def resize(self, *args) -> "void":
        r"""


        resize(self, _newsize, x)
            _newsize: size_t
            x: valstr_t const &
        

        resize(self, _newsize)
            _newsize: size_t
        """
        return _ida_typeinf.valstrvec_t_resize(self, *args)

    def grow(self, *args) -> "void":
        r"""


        grow(self, x=valstr_t())
            x: valstr_t const &
        """
        return _ida_typeinf.valstrvec_t_grow(self, *args)

    def capacity(self, *args) -> "size_t":
        r"""
        capacity(self) -> size_t
        """
        return _ida_typeinf.valstrvec_t_capacity(self, *args)

    def reserve(self, *args) -> "void":
        r"""


        reserve(self, cnt)
            cnt: size_t
        """
        return _ida_typeinf.valstrvec_t_reserve(self, *args)

    def truncate(self, *args) -> "void":
        r"""
        truncate(self)
        """
        return _ida_typeinf.valstrvec_t_truncate(self, *args)

    def swap(self, *args) -> "void":
        r"""


        swap(self, r)
            r: qvector< valstr_t > &
        """
        return _ida_typeinf.valstrvec_t_swap(self, *args)

    def extract(self, *args) -> "valstr_t *":
        r"""
        extract(self) -> valstr_t
        """
        return _ida_typeinf.valstrvec_t_extract(self, *args)

    def inject(self, *args) -> "void":
        r"""


        inject(self, s, len)
            s: valstr_t *
            len: size_t
        """
        return _ida_typeinf.valstrvec_t_inject(self, *args)

    def begin(self, *args) -> "qvector< valstr_t >::const_iterator":
        r"""
        begin(self) -> valstr_t
        begin(self) -> valstr_t
        """
        return _ida_typeinf.valstrvec_t_begin(self, *args)

    def end(self, *args) -> "qvector< valstr_t >::const_iterator":
        r"""
        end(self) -> valstr_t
        end(self) -> valstr_t
        """
        return _ida_typeinf.valstrvec_t_end(self, *args)

    def insert(self, *args) -> "qvector< valstr_t >::iterator":
        r"""


        insert(self, it, x) -> valstr_t
            it: qvector< valstr_t >::iterator
            x: valstr_t const &
        """
        return _ida_typeinf.valstrvec_t_insert(self, *args)

    def erase(self, *args) -> "qvector< valstr_t >::iterator":
        r"""


        erase(self, it) -> valstr_t
            it: qvector< valstr_t >::iterator
        

        erase(self, first, last) -> valstr_t
            first: qvector< valstr_t >::iterator
            last: qvector< valstr_t >::iterator
        """
        return _ida_typeinf.valstrvec_t_erase(self, *args)

    def __len__(self, *args) -> "size_t":
        r"""
        __len__(self) -> size_t
        """
        return _ida_typeinf.valstrvec_t___len__(self, *args)

    def __getitem__(self, *args) -> "valstr_t const &":
        r"""


        __getitem__(self, i) -> valstr_t
            i: size_t
        """
        return _ida_typeinf.valstrvec_t___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        r"""


        __setitem__(self, i, v)
            i: size_t
            v: valstr_t const &
        """
        return _ida_typeinf.valstrvec_t___setitem__(self, *args)

    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator


# Register valstrvec_t in _ida_typeinf:
_ida_typeinf.valstrvec_t_swigregister(valstrvec_t)

class regobjvec_t(object):
    r"""
    Proxy of C++ qvector< regobj_t > class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        __init__(self) -> regobjvec_t
            x: qvector< regobj_t > const &
        """
        _ida_typeinf.regobjvec_t_swiginit(self, _ida_typeinf.new_regobjvec_t(*args))
    __swig_destroy__ = _ida_typeinf.delete_regobjvec_t

    def push_back(self, *args) -> "regobj_t &":
        r"""


        push_back(self, x)
            x: regobj_t const &
        """
        return _ida_typeinf.regobjvec_t_push_back(self, *args)

    def pop_back(self, *args) -> "void":
        r"""
        pop_back(self)
        """
        return _ida_typeinf.regobjvec_t_pop_back(self, *args)

    def size(self, *args) -> "size_t":
        r"""
        size(self) -> size_t
        """
        return _ida_typeinf.regobjvec_t_size(self, *args)

    def empty(self, *args) -> "bool":
        r"""
        empty(self) -> bool
        """
        return _ida_typeinf.regobjvec_t_empty(self, *args)

    def at(self, *args) -> "regobj_t const &":
        r"""


        at(self, _idx) -> regobj_t
            _idx: size_t
        """
        return _ida_typeinf.regobjvec_t_at(self, *args)

    def qclear(self, *args) -> "void":
        r"""
        qclear(self)
        """
        return _ida_typeinf.regobjvec_t_qclear(self, *args)

    def clear(self, *args) -> "void":
        r"""
        clear(self)
        """
        return _ida_typeinf.regobjvec_t_clear(self, *args)

    def resize(self, *args) -> "void":
        r"""


        resize(self, _newsize, x)
            _newsize: size_t
            x: regobj_t const &
        

        resize(self, _newsize)
            _newsize: size_t
        """
        return _ida_typeinf.regobjvec_t_resize(self, *args)

    def grow(self, *args) -> "void":
        r"""


        grow(self, x=regobj_t())
            x: regobj_t const &
        """
        return _ida_typeinf.regobjvec_t_grow(self, *args)

    def capacity(self, *args) -> "size_t":
        r"""
        capacity(self) -> size_t
        """
        return _ida_typeinf.regobjvec_t_capacity(self, *args)

    def reserve(self, *args) -> "void":
        r"""


        reserve(self, cnt)
            cnt: size_t
        """
        return _ida_typeinf.regobjvec_t_reserve(self, *args)

    def truncate(self, *args) -> "void":
        r"""
        truncate(self)
        """
        return _ida_typeinf.regobjvec_t_truncate(self, *args)

    def swap(self, *args) -> "void":
        r"""


        swap(self, r)
            r: qvector< regobj_t > &
        """
        return _ida_typeinf.regobjvec_t_swap(self, *args)

    def extract(self, *args) -> "regobj_t *":
        r"""
        extract(self) -> regobj_t
        """
        return _ida_typeinf.regobjvec_t_extract(self, *args)

    def inject(self, *args) -> "void":
        r"""


        inject(self, s, len)
            s: regobj_t *
            len: size_t
        """
        return _ida_typeinf.regobjvec_t_inject(self, *args)

    def begin(self, *args) -> "qvector< regobj_t >::const_iterator":
        r"""
        begin(self) -> regobj_t
        begin(self) -> regobj_t
        """
        return _ida_typeinf.regobjvec_t_begin(self, *args)

    def end(self, *args) -> "qvector< regobj_t >::const_iterator":
        r"""
        end(self) -> regobj_t
        end(self) -> regobj_t
        """
        return _ida_typeinf.regobjvec_t_end(self, *args)

    def insert(self, *args) -> "qvector< regobj_t >::iterator":
        r"""


        insert(self, it, x) -> regobj_t
            it: qvector< regobj_t >::iterator
            x: regobj_t const &
        """
        return _ida_typeinf.regobjvec_t_insert(self, *args)

    def erase(self, *args) -> "qvector< regobj_t >::iterator":
        r"""


        erase(self, it) -> regobj_t
            it: qvector< regobj_t >::iterator
        

        erase(self, first, last) -> regobj_t
            first: qvector< regobj_t >::iterator
            last: qvector< regobj_t >::iterator
        """
        return _ida_typeinf.regobjvec_t_erase(self, *args)

    def __len__(self, *args) -> "size_t":
        r"""
        __len__(self) -> size_t
        """
        return _ida_typeinf.regobjvec_t___len__(self, *args)

    def __getitem__(self, *args) -> "regobj_t const &":
        r"""


        __getitem__(self, i) -> regobj_t
            i: size_t
        """
        return _ida_typeinf.regobjvec_t___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        r"""


        __setitem__(self, i, v)
            i: size_t
            v: regobj_t const &
        """
        return _ida_typeinf.regobjvec_t___setitem__(self, *args)

    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator


# Register regobjvec_t in _ida_typeinf:
_ida_typeinf.regobjvec_t_swigregister(regobjvec_t)

class type_attrs_t(object):
    r"""
    Proxy of C++ qvector< type_attr_t > class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        __init__(self) -> type_attrs_t
            x: qvector< type_attr_t > const &
        """
        _ida_typeinf.type_attrs_t_swiginit(self, _ida_typeinf.new_type_attrs_t(*args))
    __swig_destroy__ = _ida_typeinf.delete_type_attrs_t

    def push_back(self, *args) -> "type_attr_t &":
        r"""


        push_back(self, x)
            x: type_attr_t const &
        """
        return _ida_typeinf.type_attrs_t_push_back(self, *args)

    def pop_back(self, *args) -> "void":
        r"""
        pop_back(self)
        """
        return _ida_typeinf.type_attrs_t_pop_back(self, *args)

    def size(self, *args) -> "size_t":
        r"""
        size(self) -> size_t
        """
        return _ida_typeinf.type_attrs_t_size(self, *args)

    def empty(self, *args) -> "bool":
        r"""
        empty(self) -> bool
        """
        return _ida_typeinf.type_attrs_t_empty(self, *args)

    def at(self, *args) -> "type_attr_t const &":
        r"""


        at(self, _idx) -> type_attr_t
            _idx: size_t
        """
        return _ida_typeinf.type_attrs_t_at(self, *args)

    def qclear(self, *args) -> "void":
        r"""
        qclear(self)
        """
        return _ida_typeinf.type_attrs_t_qclear(self, *args)

    def clear(self, *args) -> "void":
        r"""
        clear(self)
        """
        return _ida_typeinf.type_attrs_t_clear(self, *args)

    def resize(self, *args) -> "void":
        r"""


        resize(self, _newsize, x)
            _newsize: size_t
            x: type_attr_t const &
        

        resize(self, _newsize)
            _newsize: size_t
        """
        return _ida_typeinf.type_attrs_t_resize(self, *args)

    def grow(self, *args) -> "void":
        r"""


        grow(self, x=type_attr_t())
            x: type_attr_t const &
        """
        return _ida_typeinf.type_attrs_t_grow(self, *args)

    def capacity(self, *args) -> "size_t":
        r"""
        capacity(self) -> size_t
        """
        return _ida_typeinf.type_attrs_t_capacity(self, *args)

    def reserve(self, *args) -> "void":
        r"""


        reserve(self, cnt)
            cnt: size_t
        """
        return _ida_typeinf.type_attrs_t_reserve(self, *args)

    def truncate(self, *args) -> "void":
        r"""
        truncate(self)
        """
        return _ida_typeinf.type_attrs_t_truncate(self, *args)

    def swap(self, *args) -> "void":
        r"""


        swap(self, r)
            r: qvector< type_attr_t > &
        """
        return _ida_typeinf.type_attrs_t_swap(self, *args)

    def extract(self, *args) -> "type_attr_t *":
        r"""
        extract(self) -> type_attr_t
        """
        return _ida_typeinf.type_attrs_t_extract(self, *args)

    def inject(self, *args) -> "void":
        r"""


        inject(self, s, len)
            s: type_attr_t *
            len: size_t
        """
        return _ida_typeinf.type_attrs_t_inject(self, *args)

    def begin(self, *args) -> "qvector< type_attr_t >::const_iterator":
        r"""
        begin(self) -> type_attr_t
        begin(self) -> type_attr_t
        """
        return _ida_typeinf.type_attrs_t_begin(self, *args)

    def end(self, *args) -> "qvector< type_attr_t >::const_iterator":
        r"""
        end(self) -> type_attr_t
        end(self) -> type_attr_t
        """
        return _ida_typeinf.type_attrs_t_end(self, *args)

    def insert(self, *args) -> "qvector< type_attr_t >::iterator":
        r"""


        insert(self, it, x) -> type_attr_t
            it: qvector< type_attr_t >::iterator
            x: type_attr_t const &
        """
        return _ida_typeinf.type_attrs_t_insert(self, *args)

    def erase(self, *args) -> "qvector< type_attr_t >::iterator":
        r"""


        erase(self, it) -> type_attr_t
            it: qvector< type_attr_t >::iterator
        

        erase(self, first, last) -> type_attr_t
            first: qvector< type_attr_t >::iterator
            last: qvector< type_attr_t >::iterator
        """
        return _ida_typeinf.type_attrs_t_erase(self, *args)

    def __len__(self, *args) -> "size_t":
        r"""
        __len__(self) -> size_t
        """
        return _ida_typeinf.type_attrs_t___len__(self, *args)

    def __getitem__(self, *args) -> "type_attr_t const &":
        r"""


        __getitem__(self, i) -> type_attr_t
            i: size_t
        """
        return _ida_typeinf.type_attrs_t___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        r"""


        __setitem__(self, i, v)
            i: size_t
            v: type_attr_t const &
        """
        return _ida_typeinf.type_attrs_t___setitem__(self, *args)

    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator


# Register type_attrs_t in _ida_typeinf:
_ida_typeinf.type_attrs_t_swigregister(type_attrs_t)

RESERVED_BYTE = _ida_typeinf.RESERVED_BYTE
"""
multifunctional purpose
"""


def is_type_const(*args) -> "bool":
    r"""


    See 'BTM_CONST' .
    
    is_type_const(t) -> bool
        @param t (C++: type_t)
    """
    return _ida_typeinf.is_type_const(*args)

def is_type_volatile(*args) -> "bool":
    r"""


    See 'BTM_VOLATILE' .
    
    is_type_volatile(t) -> bool
        @param t (C++: type_t)
    """
    return _ida_typeinf.is_type_volatile(*args)

def get_base_type(*args) -> "type_t":
    r"""


    Get get basic type bits ( 'TYPE_BASE_MASK' )
    
    get_base_type(t) -> type_t
        @param t (C++: type_t)
    """
    return _ida_typeinf.get_base_type(*args)

def get_type_flags(*args) -> "type_t":
    r"""


    Get type flags ( 'TYPE_FLAGS_MASK' )
    
    get_type_flags(t) -> type_t
        @param t (C++: type_t)
    """
    return _ida_typeinf.get_type_flags(*args)

def get_full_type(*args) -> "type_t":
    r"""


    Get basic type bits + type flags ( 'TYPE_FULL_MASK' )
    
    get_full_type(t) -> type_t
        @param t (C++: type_t)
    """
    return _ida_typeinf.get_full_type(*args)

def is_typeid_last(*args) -> "bool":
    r"""


    Is the type_t the last byte of type declaration? (there are no
    additional bytes after a basic type, see '_BT_LAST_BASIC' )
    
    is_typeid_last(t) -> bool
        @param t (C++: type_t)
    """
    return _ida_typeinf.is_typeid_last(*args)

def is_type_partial(*args) -> "bool":
    r"""


    Identifies an unknown or void type with a known size (see 'Basic type:
    unknown & void' )
    
    is_type_partial(t) -> bool
        @param t (C++: type_t)
    """
    return _ida_typeinf.is_type_partial(*args)

def is_type_void(*args) -> "bool":
    r"""


    See 'BTF_VOID' .
    
    is_type_void(t) -> bool
        @param t (C++: type_t)
    """
    return _ida_typeinf.is_type_void(*args)

def is_type_unknown(*args) -> "bool":
    r"""


    See 'BT_UNKNOWN' .
    
    is_type_unknown(t) -> bool
        @param t (C++: type_t)
    """
    return _ida_typeinf.is_type_unknown(*args)

def is_type_ptr(*args) -> "bool":
    r"""


    See 'BT_PTR' .
    
    is_type_ptr(t) -> bool
        @param t (C++: type_t)
    """
    return _ida_typeinf.is_type_ptr(*args)

def is_type_complex(*args) -> "bool":
    r"""


    See 'BT_COMPLEX' .
    
    is_type_complex(t) -> bool
        @param t (C++: type_t)
    """
    return _ida_typeinf.is_type_complex(*args)

def is_type_func(*args) -> "bool":
    r"""


    See 'BT_FUNC' .
    
    is_type_func(t) -> bool
        @param t (C++: type_t)
    """
    return _ida_typeinf.is_type_func(*args)

def is_type_array(*args) -> "bool":
    r"""


    See 'BT_ARRAY' .
    
    is_type_array(t) -> bool
        @param t (C++: type_t)
    """
    return _ida_typeinf.is_type_array(*args)

def is_type_typedef(*args) -> "bool":
    r"""


    See 'BTF_TYPEDEF' .
    
    is_type_typedef(t) -> bool
        @param t (C++: type_t)
    """
    return _ida_typeinf.is_type_typedef(*args)

def is_type_sue(*args) -> "bool":
    r"""


    Is the type a struct/union/enum?
    
    is_type_sue(t) -> bool
        @param t (C++: type_t)
    """
    return _ida_typeinf.is_type_sue(*args)

def is_type_struct(*args) -> "bool":
    r"""


    See 'BTF_STRUCT' .
    
    is_type_struct(t) -> bool
        @param t (C++: type_t)
    """
    return _ida_typeinf.is_type_struct(*args)

def is_type_union(*args) -> "bool":
    r"""


    See 'BTF_UNION' .
    
    is_type_union(t) -> bool
        @param t (C++: type_t)
    """
    return _ida_typeinf.is_type_union(*args)

def is_type_struni(*args) -> "bool":
    r"""


    Is the type a struct or union?
    
    is_type_struni(t) -> bool
        @param t (C++: type_t)
    """
    return _ida_typeinf.is_type_struni(*args)

def is_type_enum(*args) -> "bool":
    r"""


    See 'BTF_ENUM' .
    
    is_type_enum(t) -> bool
        @param t (C++: type_t)
    """
    return _ida_typeinf.is_type_enum(*args)

def is_type_bitfld(*args) -> "bool":
    r"""


    See 'BT_BITFIELD' .
    
    is_type_bitfld(t) -> bool
        @param t (C++: type_t)
    """
    return _ida_typeinf.is_type_bitfld(*args)

def is_type_int(*args) -> "bool":
    r"""


    Does the type_t specify one of the basic types in 'Basic type:
    integer' ?
    
    is_type_int(bt) -> bool
        @param bt (C++: type_t)
    """
    return _ida_typeinf.is_type_int(*args)

def is_type_int128(*args) -> "bool":
    r"""


    Does the type specify a 128-bit value? (signed or unsigned, see 'Basic
    type: integer' )
    
    is_type_int128(t) -> bool
        @param t (C++: type_t)
    """
    return _ida_typeinf.is_type_int128(*args)

def is_type_int64(*args) -> "bool":
    r"""


    Does the type specify a 64-bit value? (signed or unsigned, see 'Basic
    type: integer' )
    
    is_type_int64(t) -> bool
        @param t (C++: type_t)
    """
    return _ida_typeinf.is_type_int64(*args)

def is_type_int32(*args) -> "bool":
    r"""


    Does the type specify a 32-bit value? (signed or unsigned, see 'Basic
    type: integer' )
    
    is_type_int32(t) -> bool
        @param t (C++: type_t)
    """
    return _ida_typeinf.is_type_int32(*args)

def is_type_int16(*args) -> "bool":
    r"""


    Does the type specify a 16-bit value? (signed or unsigned, see 'Basic
    type: integer' )
    
    is_type_int16(t) -> bool
        @param t (C++: type_t)
    """
    return _ida_typeinf.is_type_int16(*args)

def is_type_char(*args) -> "bool":
    r"""


    Does the type specify a char value? (signed or unsigned, see 'Basic
    type: integer' )
    
    is_type_char(t) -> bool
        @param t (C++: type_t)
    """
    return _ida_typeinf.is_type_char(*args)

def is_type_paf(*args) -> "bool":
    r"""


    Is the type a pointer, array, or function type?
    
    is_type_paf(t) -> bool
        @param t (C++: type_t)
    """
    return _ida_typeinf.is_type_paf(*args)

def is_type_ptr_or_array(*args) -> "bool":
    r"""


    Is the type a pointer or array type?
    
    is_type_ptr_or_array(t) -> bool
        @param t (C++: type_t)
    """
    return _ida_typeinf.is_type_ptr_or_array(*args)

def is_type_floating(*args) -> "bool":
    r"""


    Is the type a floating point type?
    
    is_type_floating(t) -> bool
        @param t (C++: type_t)
    """
    return _ida_typeinf.is_type_floating(*args)

def is_type_integral(*args) -> "bool":
    r"""


    Is the type an integral type (char/short/int/long/bool)?
    
    is_type_integral(t) -> bool
        @param t (C++: type_t)
    """
    return _ida_typeinf.is_type_integral(*args)

def is_type_ext_integral(*args) -> "bool":
    r"""


    Is the type an extended integral type? (integral or enum)
    
    is_type_ext_integral(t) -> bool
        @param t (C++: type_t)
    """
    return _ida_typeinf.is_type_ext_integral(*args)

def is_type_arithmetic(*args) -> "bool":
    r"""


    Is the type an arithmetic type? (floating or integral)
    
    is_type_arithmetic(t) -> bool
        @param t (C++: type_t)
    """
    return _ida_typeinf.is_type_arithmetic(*args)

def is_type_ext_arithmetic(*args) -> "bool":
    r"""


    Is the type an extended arithmetic type? (arithmetic or enum)
    
    is_type_ext_arithmetic(t) -> bool
        @param t (C++: type_t)
    """
    return _ida_typeinf.is_type_ext_arithmetic(*args)

def is_type_uint(*args) -> "bool":
    r"""


    See 'BTF_UINT' .
    
    is_type_uint(t) -> bool
        @param t (C++: type_t)
    """
    return _ida_typeinf.is_type_uint(*args)

def is_type_uchar(*args) -> "bool":
    r"""


    See 'BTF_UCHAR' .
    
    is_type_uchar(t) -> bool
        @param t (C++: type_t)
    """
    return _ida_typeinf.is_type_uchar(*args)

def is_type_uint16(*args) -> "bool":
    r"""


    See 'BTF_UINT16' .
    
    is_type_uint16(t) -> bool
        @param t (C++: type_t)
    """
    return _ida_typeinf.is_type_uint16(*args)

def is_type_uint32(*args) -> "bool":
    r"""


    See 'BTF_UINT32' .
    
    is_type_uint32(t) -> bool
        @param t (C++: type_t)
    """
    return _ida_typeinf.is_type_uint32(*args)

def is_type_uint64(*args) -> "bool":
    r"""


    See 'BTF_UINT64' .
    
    is_type_uint64(t) -> bool
        @param t (C++: type_t)
    """
    return _ida_typeinf.is_type_uint64(*args)

def is_type_uint128(*args) -> "bool":
    r"""


    See 'BTF_UINT128' .
    
    is_type_uint128(t) -> bool
        @param t (C++: type_t)
    """
    return _ida_typeinf.is_type_uint128(*args)

def is_type_ldouble(*args) -> "bool":
    r"""


    See 'BTF_LDOUBLE' .
    
    is_type_ldouble(t) -> bool
        @param t (C++: type_t)
    """
    return _ida_typeinf.is_type_ldouble(*args)

def is_type_double(*args) -> "bool":
    r"""


    See 'BTF_DOUBLE' .
    
    is_type_double(t) -> bool
        @param t (C++: type_t)
    """
    return _ida_typeinf.is_type_double(*args)

def is_type_float(*args) -> "bool":
    r"""


    See 'BTF_FLOAT' .
    
    is_type_float(t) -> bool
        @param t (C++: type_t)
    """
    return _ida_typeinf.is_type_float(*args)

def is_type_tbyte(*args) -> "bool":
    r"""


    See 'BTF_FLOAT' .
    
    is_type_tbyte(t) -> bool
        @param t (C++: type_t)
    """
    return _ida_typeinf.is_type_tbyte(*args)

def is_type_bool(*args) -> "bool":
    r"""


    See 'BTF_BOOL' .
    
    is_type_bool(t) -> bool
        @param t (C++: type_t)
    """
    return _ida_typeinf.is_type_bool(*args)
TAH_BYTE = _ida_typeinf.TAH_BYTE
"""
type attribute header byte
"""

FAH_BYTE = _ida_typeinf.FAH_BYTE
"""
function argument attribute header byte
"""

MAX_DECL_ALIGN = _ida_typeinf.MAX_DECL_ALIGN

TAH_HASATTRS = _ida_typeinf.TAH_HASATTRS
"""
has extended attributes
"""

TAUDT_UNALIGNED = _ida_typeinf.TAUDT_UNALIGNED
"""
struct: unaligned struct
"""

TAUDT_MSSTRUCT = _ida_typeinf.TAUDT_MSSTRUCT
"""
struct: gcc msstruct attribute
"""

TAUDT_CPPOBJ = _ida_typeinf.TAUDT_CPPOBJ
"""
struct: a c++ object, not simple pod type
"""

TAUDT_VFTABLE = _ida_typeinf.TAUDT_VFTABLE
"""
struct: is virtual function table
"""

TAFLD_BASECLASS = _ida_typeinf.TAFLD_BASECLASS
"""
field: do not include but inherit from the current field
"""

TAFLD_UNALIGNED = _ida_typeinf.TAFLD_UNALIGNED
"""
field: unaligned field
"""

TAFLD_VIRTBASE = _ida_typeinf.TAFLD_VIRTBASE
"""
field: virtual base (not supported yet)
"""

TAFLD_VFTABLE = _ida_typeinf.TAFLD_VFTABLE
"""
field: ptr to virtual function table
"""

TAPTR_PTR32 = _ida_typeinf.TAPTR_PTR32
"""
ptr: __ptr32
"""

TAPTR_PTR64 = _ida_typeinf.TAPTR_PTR64
"""
ptr: __ptr64
"""

TAPTR_RESTRICT = _ida_typeinf.TAPTR_RESTRICT
"""
ptr: __restrict
"""

TAPTR_SHIFTED = _ida_typeinf.TAPTR_SHIFTED
"""
ptr: __shifted(parent_struct, delta)
"""

TAENUM_64BIT = _ida_typeinf.TAENUM_64BIT
"""
enum: store 64-bit values
"""

TAENUM_UNSIGNED = _ida_typeinf.TAENUM_UNSIGNED
"""
enum: unsigned
"""

TAENUM_SIGNED = _ida_typeinf.TAENUM_SIGNED
"""
enum: signed
"""

TAH_ALL = _ida_typeinf.TAH_ALL
"""
all defined bits
"""


def is_tah_byte(*args) -> "bool":
    r"""


    The TAH byte (type attribute header byte) denotes the start of type
    attributes. (see "tah-typeattrs" in the type bit definitions)
    
    is_tah_byte(t) -> bool
        @param t (C++: type_t)
    """
    return _ida_typeinf.is_tah_byte(*args)

def is_sdacl_byte(*args) -> "bool":
    r"""


    Identify an sdacl byte. The first sdacl byte has the following format:
    11xx000x. The sdacl bytes are appended to udt fields. They indicate
    the start of type attributes (as the tah-bytes do). The sdacl bytes
    are used in the udt headers instead of the tah-byte. This is done for
    compatibility with old databases, they were already using sdacl bytes
    in udt headers and as udt field postfixes. (see "sdacl-typeattrs" in
    the type bit definitions)
    
    is_sdacl_byte(t) -> bool
        @param t (C++: type_t)
    """
    return _ida_typeinf.is_sdacl_byte(*args)
class type_attr_t(object):
    r"""
    Proxy of C++ type_attr_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    key = property(_ida_typeinf.type_attr_t_key_get, _ida_typeinf.type_attr_t_key_set)
    value = property(_ida_typeinf.type_attr_t_value_get, _ida_typeinf.type_attr_t_value_set)

    def __lt__(self, *args) -> "bool":
        r"""


        __lt__(self, r) -> bool
            r: type_attr_t const &
        """
        return _ida_typeinf.type_attr_t___lt__(self, *args)

    def __ge__(self, *args) -> "bool":
        r"""


        __ge__(self, r) -> bool
            r: type_attr_t const &
        """
        return _ida_typeinf.type_attr_t___ge__(self, *args)

    def __init__(self, *args):
        r"""
        __init__(self) -> type_attr_t
        """
        _ida_typeinf.type_attr_t_swiginit(self, _ida_typeinf.new_type_attr_t(*args))
    __swig_destroy__ = _ida_typeinf.delete_type_attr_t

# Register type_attr_t in _ida_typeinf:
_ida_typeinf.type_attr_t_swigregister(type_attr_t)
cvar = _ida_typeinf.cvar
TYPE_BASE_MASK = cvar.TYPE_BASE_MASK
TYPE_FLAGS_MASK = cvar.TYPE_FLAGS_MASK
TYPE_MODIF_MASK = cvar.TYPE_MODIF_MASK
TYPE_FULL_MASK = cvar.TYPE_FULL_MASK
BT_UNK = cvar.BT_UNK
BT_VOID = cvar.BT_VOID
BTMT_SIZE0 = cvar.BTMT_SIZE0
BTMT_SIZE12 = cvar.BTMT_SIZE12
BTMT_SIZE48 = cvar.BTMT_SIZE48
BTMT_SIZE128 = cvar.BTMT_SIZE128
BT_INT8 = cvar.BT_INT8
BT_INT16 = cvar.BT_INT16
BT_INT32 = cvar.BT_INT32
BT_INT64 = cvar.BT_INT64
BT_INT128 = cvar.BT_INT128
BT_INT = cvar.BT_INT
BTMT_UNKSIGN = cvar.BTMT_UNKSIGN
BTMT_SIGNED = cvar.BTMT_SIGNED
BTMT_USIGNED = cvar.BTMT_USIGNED
BTMT_UNSIGNED = cvar.BTMT_UNSIGNED
BTMT_CHAR = cvar.BTMT_CHAR
BT_BOOL = cvar.BT_BOOL
BTMT_DEFBOOL = cvar.BTMT_DEFBOOL
BTMT_BOOL1 = cvar.BTMT_BOOL1
BTMT_BOOL2 = cvar.BTMT_BOOL2
BTMT_BOOL8 = cvar.BTMT_BOOL8
BTMT_BOOL4 = cvar.BTMT_BOOL4
BT_FLOAT = cvar.BT_FLOAT
BTMT_FLOAT = cvar.BTMT_FLOAT
BTMT_DOUBLE = cvar.BTMT_DOUBLE
BTMT_LNGDBL = cvar.BTMT_LNGDBL
BTMT_SPECFLT = cvar.BTMT_SPECFLT
_BT_LAST_BASIC = cvar._BT_LAST_BASIC
BT_PTR = cvar.BT_PTR
BTMT_DEFPTR = cvar.BTMT_DEFPTR
BTMT_NEAR = cvar.BTMT_NEAR
BTMT_FAR = cvar.BTMT_FAR
BTMT_CLOSURE = cvar.BTMT_CLOSURE
BT_ARRAY = cvar.BT_ARRAY
BTMT_NONBASED = cvar.BTMT_NONBASED
BTMT_ARRESERV = cvar.BTMT_ARRESERV
BT_FUNC = cvar.BT_FUNC
BTMT_DEFCALL = cvar.BTMT_DEFCALL
BTMT_NEARCALL = cvar.BTMT_NEARCALL
BTMT_FARCALL = cvar.BTMT_FARCALL
BTMT_INTCALL = cvar.BTMT_INTCALL
BT_COMPLEX = cvar.BT_COMPLEX
BTMT_STRUCT = cvar.BTMT_STRUCT
BTMT_UNION = cvar.BTMT_UNION
BTMT_ENUM = cvar.BTMT_ENUM
BTMT_TYPEDEF = cvar.BTMT_TYPEDEF
BT_BITFIELD = cvar.BT_BITFIELD
BTMT_BFLDI8 = cvar.BTMT_BFLDI8
BTMT_BFLDI16 = cvar.BTMT_BFLDI16
BTMT_BFLDI32 = cvar.BTMT_BFLDI32
BTMT_BFLDI64 = cvar.BTMT_BFLDI64
BT_RESERVED = cvar.BT_RESERVED
BTM_CONST = cvar.BTM_CONST
BTM_VOLATILE = cvar.BTM_VOLATILE
BTE_SIZE_MASK = cvar.BTE_SIZE_MASK
BTE_RESERVED = cvar.BTE_RESERVED
BTE_BITFIELD = cvar.BTE_BITFIELD
BTE_OUT_MASK = cvar.BTE_OUT_MASK
BTE_HEX = cvar.BTE_HEX
BTE_CHAR = cvar.BTE_CHAR
BTE_SDEC = cvar.BTE_SDEC
BTE_UDEC = cvar.BTE_UDEC
BTE_ALWAYS = cvar.BTE_ALWAYS
BT_SEGREG = cvar.BT_SEGREG
BT_UNK_BYTE = cvar.BT_UNK_BYTE
BT_UNK_WORD = cvar.BT_UNK_WORD
BT_UNK_DWORD = cvar.BT_UNK_DWORD
BT_UNK_QWORD = cvar.BT_UNK_QWORD
BT_UNK_OWORD = cvar.BT_UNK_OWORD
BT_UNKNOWN = cvar.BT_UNKNOWN
BTF_BYTE = cvar.BTF_BYTE
BTF_UNK = cvar.BTF_UNK
BTF_VOID = cvar.BTF_VOID
BTF_INT8 = cvar.BTF_INT8
BTF_CHAR = cvar.BTF_CHAR
BTF_UCHAR = cvar.BTF_UCHAR
BTF_UINT8 = cvar.BTF_UINT8
BTF_INT16 = cvar.BTF_INT16
BTF_UINT16 = cvar.BTF_UINT16
BTF_INT32 = cvar.BTF_INT32
BTF_UINT32 = cvar.BTF_UINT32
BTF_INT64 = cvar.BTF_INT64
BTF_UINT64 = cvar.BTF_UINT64
BTF_INT128 = cvar.BTF_INT128
BTF_UINT128 = cvar.BTF_UINT128
BTF_INT = cvar.BTF_INT
BTF_UINT = cvar.BTF_UINT
BTF_SINT = cvar.BTF_SINT
BTF_BOOL = cvar.BTF_BOOL
BTF_FLOAT = cvar.BTF_FLOAT
BTF_DOUBLE = cvar.BTF_DOUBLE
BTF_LDOUBLE = cvar.BTF_LDOUBLE
BTF_TBYTE = cvar.BTF_TBYTE
BTF_STRUCT = cvar.BTF_STRUCT
BTF_UNION = cvar.BTF_UNION
BTF_ENUM = cvar.BTF_ENUM
BTF_TYPEDEF = cvar.BTF_TYPEDEF


def append_argloc(*args) -> "bool":
    r"""


    Serialize argument location.
    
    append_argloc(out, vloc) -> bool
        @param out (C++: qtype  *)
        @param vloc (C++: const  argloc_t  &)
    """
    return _ida_typeinf.append_argloc(*args)

def extract_argloc(*args) -> "bool":
    r"""


    Deserialize argument location.
    
    extract_argloc(vloc, ptype, is_retval) -> bool
        @param vloc (C++: argloc_t  *)
        @param ptype (C++: const  type_t  **)
        @param is_retval (C++: bool)
    """
    return _ida_typeinf.extract_argloc(*args)

def resolve_typedef(*args) -> "type_t const *":
    r"""


    resolve_typedef(til, type) -> type_t const *
        @param til (C++: const  til_t  *)
        @param type (C++: const  type_t  *)
    """
    return _ida_typeinf.resolve_typedef(*args)

def is_restype_void(*args) -> "bool":
    r"""


    is_restype_void(til, type) -> bool
        @param til (C++: const  til_t  *)
        @param type (C++: const  type_t  *)
    """
    return _ida_typeinf.is_restype_void(*args)

def is_restype_enum(*args) -> "bool":
    r"""


    is_restype_enum(til, type) -> bool
        @param til (C++: const  til_t  *)
        @param type (C++: const  type_t  *)
    """
    return _ida_typeinf.is_restype_enum(*args)

def is_restype_struni(*args) -> "bool":
    r"""


    is_restype_struni(til, type) -> bool
        @param til (C++: const  til_t  *)
        @param type (C++: const  type_t  *)
    """
    return _ida_typeinf.is_restype_struni(*args)

def is_restype_struct(*args) -> "bool":
    r"""


    is_restype_struct(til, type) -> bool
        @param til (C++: const  til_t  *)
        @param type (C++: const  type_t  *)
    """
    return _ida_typeinf.is_restype_struct(*args)

def get_scalar_bt(*args) -> "type_t":
    r"""


    get_scalar_bt(size) -> type_t
        @param size (C++: int)
    """
    return _ida_typeinf.get_scalar_bt(*args)
class til_t(object):
    r"""
    Proxy of C++ til_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = property(_ida_typeinf.til_t_name_get, _ida_typeinf.til_t_name_set)
    desc = property(_ida_typeinf.til_t_desc_get, _ida_typeinf.til_t_desc_set)
    nbases = property(_ida_typeinf.til_t_nbases_get, _ida_typeinf.til_t_nbases_set)
    flags = property(_ida_typeinf.til_t_flags_get, _ida_typeinf.til_t_flags_set)

    def is_dirty(self, *args) -> "bool":
        r"""


        Has the til been modified? ( 'TIL_MOD' )
        """
        return _ida_typeinf.til_t_is_dirty(self, *args)

    def set_dirty(self, *args) -> "void":
        r"""


        Mark the til as modified ( 'TIL_MOD' )
        """
        return _ida_typeinf.til_t_set_dirty(self, *args)
    cc = property(_ida_typeinf.til_t_cc_get, _ida_typeinf.til_t_cc_set)
    nrefs = property(_ida_typeinf.til_t_nrefs_get, _ida_typeinf.til_t_nrefs_set)
    nstreams = property(_ida_typeinf.til_t_nstreams_get, _ida_typeinf.til_t_nstreams_set)
    streams = property(_ida_typeinf.til_t_streams_get, _ida_typeinf.til_t_streams_set)

    def __init__(self, *args):
        r"""
        __init__(self) -> til_t
        """
        _ida_typeinf.til_t_swiginit(self, _ida_typeinf.new_til_t(*args))

    def base(self, *args) -> "til_t *":
        r"""


        base(self, n) -> til_t
            n: int
        """
        return _ida_typeinf.til_t_base(self, *args)
    __swig_destroy__ = _ida_typeinf.delete_til_t

# Register til_t in _ida_typeinf:
_ida_typeinf.til_t_swigregister(til_t)
no_sign = cvar.no_sign
type_signed = cvar.type_signed
type_unsigned = cvar.type_unsigned
TIL_ZIP = _ida_typeinf.TIL_ZIP
"""
pack buckets using zip
"""

TIL_MAC = _ida_typeinf.TIL_MAC
"""
til has macro table
"""

TIL_ESI = _ida_typeinf.TIL_ESI
"""
extended sizeof info (short, long, longlong)
"""

TIL_UNI = _ida_typeinf.TIL_UNI
"""
universal til for any compiler
"""

TIL_ORD = _ida_typeinf.TIL_ORD
"""
type ordinal numbers are present
"""

TIL_ALI = _ida_typeinf.TIL_ALI
"""
type aliases are present (this bit is used only on the disk)
"""

TIL_MOD = _ida_typeinf.TIL_MOD
"""
til has been modified, should be saved
"""

TIL_STM = _ida_typeinf.TIL_STM
"""
til has extra streams
"""

TIL_SLD = _ida_typeinf.TIL_SLD
"""
sizeof(long double)
"""



def new_til(*args) -> "til_t *":
    r"""


    Initialize a til.
    
    new_til(name, desc) -> til_t
        @param name (C++: const char *)
        @param desc (C++: const char *)
    """
    return _ida_typeinf.new_til(*args)
TIL_ADD_FAILED = _ida_typeinf.TIL_ADD_FAILED
"""
see errbuf
"""

TIL_ADD_OK = _ida_typeinf.TIL_ADD_OK
"""
some tils were added
"""

TIL_ADD_ALREADY = _ida_typeinf.TIL_ADD_ALREADY
"""
the base til was already added
"""


def load_til(*args) -> "qstring *":
    r"""


    Load til from a file. Failure to load base tils are reported into
    'errbuf'. They do not prevent loading of the main til.
    
    load_til(name, tildir=None) -> til_t
        @param name: filename of the til. If it's an absolute path, tildir is
                     ignored.   NB: the file extension is forced to .til (C++:
                     const char *)
        @param tildir: directory where to load the til from. NULL means
                       default til subdirectories. (C++: const char *)
        @return: pointer to resulting til, NULL if failed and error message is
                 in errbuf
    """
    return _ida_typeinf.load_til(*args)

def compact_til(*args) -> "bool":
    r"""


    Collect garbage in til. Must be called before storing the til.
    
    compact_til(ti) -> bool
        @param ti (C++: til_t  *)
        @return: true if any memory was freed
    """
    return _ida_typeinf.compact_til(*args)

def store_til(*args) -> "bool":
    r"""


    Store til to a file. If the til contains garbage, it will be collected
    before storing the til. Your plugin should call 'compact_til()' before
    calling 'store_til()' .
    
    store_til(ti, tildir, name) -> bool
        @param ti: type library to store (C++: til_t  *)
        @param tildir: directory where to store the til. NULL means current
                       directory. (C++: const char *)
        @param name: filename of the til. If it's an absolute path, tildir is
                     ignored.   NB: the file extension is forced to .til (C++:
                     const char *)
        @return: success
    """
    return _ida_typeinf.store_til(*args)

def free_til(*args) -> "void":
    r"""


    Free memory allocated by til.
    
    free_til(ti)
        @param ti (C++: til_t  *)
    """
    return _ida_typeinf.free_til(*args)

def load_til_header(*args) -> "qstring *":
    r"""


    Get human-readable til description.
    
    load_til_header(tildir, name) -> til_t
        @param tildir (C++: const char *)
        @param name (C++: const char *)
    """
    return _ida_typeinf.load_til_header(*args)

def is_code_far(*args) -> "bool":
    r"""


    Does the given model specify far code?.
    
    is_code_far(cm) -> bool
        @param cm (C++: cm_t)
    """
    return _ida_typeinf.is_code_far(*args)

def is_data_far(*args) -> "bool":
    r"""


    Does the given model specify far data?.
    
    is_data_far(cm) -> bool
        @param cm (C++: cm_t)
    """
    return _ida_typeinf.is_data_far(*args)
class rrel_t(object):
    r"""
    Proxy of C++ rrel_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    off = property(_ida_typeinf.rrel_t_off_get, _ida_typeinf.rrel_t_off_set)
    reg = property(_ida_typeinf.rrel_t_reg_get, _ida_typeinf.rrel_t_reg_set)

    def __init__(self, *args):
        r"""
        __init__(self) -> rrel_t
        """
        _ida_typeinf.rrel_t_swiginit(self, _ida_typeinf.new_rrel_t(*args))
    __swig_destroy__ = _ida_typeinf.delete_rrel_t

# Register rrel_t in _ida_typeinf:
_ida_typeinf.rrel_t_swigregister(rrel_t)
CM_MASK = cvar.CM_MASK
CM_UNKNOWN = cvar.CM_UNKNOWN
CM_N8_F16 = cvar.CM_N8_F16
CM_N64 = cvar.CM_N64
CM_N16_F32 = cvar.CM_N16_F32
CM_N32_F48 = cvar.CM_N32_F48
CM_M_MASK = cvar.CM_M_MASK
CM_M_NN = cvar.CM_M_NN
CM_M_FF = cvar.CM_M_FF
CM_M_NF = cvar.CM_M_NF
CM_M_FN = cvar.CM_M_FN
CM_CC_MASK = cvar.CM_CC_MASK
CM_CC_INVALID = cvar.CM_CC_INVALID
CM_CC_UNKNOWN = cvar.CM_CC_UNKNOWN
CM_CC_VOIDARG = cvar.CM_CC_VOIDARG
CM_CC_CDECL = cvar.CM_CC_CDECL
CM_CC_ELLIPSIS = cvar.CM_CC_ELLIPSIS
CM_CC_STDCALL = cvar.CM_CC_STDCALL
CM_CC_PASCAL = cvar.CM_CC_PASCAL
CM_CC_FASTCALL = cvar.CM_CC_FASTCALL
CM_CC_THISCALL = cvar.CM_CC_THISCALL
CM_CC_MANUAL = cvar.CM_CC_MANUAL
CM_CC_SPOILED = cvar.CM_CC_SPOILED
CM_CC_RESERVE4 = cvar.CM_CC_RESERVE4
CM_CC_RESERVE3 = cvar.CM_CC_RESERVE3
CM_CC_SPECIALE = cvar.CM_CC_SPECIALE
CM_CC_SPECIALP = cvar.CM_CC_SPECIALP
CM_CC_SPECIAL = cvar.CM_CC_SPECIAL
BFA_NORET = cvar.BFA_NORET
BFA_PURE = cvar.BFA_PURE
BFA_HIGH = cvar.BFA_HIGH
BFA_STATIC = cvar.BFA_STATIC
BFA_VIRTUAL = cvar.BFA_VIRTUAL
BFA_FUNC_MARKER = cvar.BFA_FUNC_MARKER
BFA_FUNC_EXT_FORMAT = cvar.BFA_FUNC_EXT_FORMAT
ALOC_NONE = cvar.ALOC_NONE
ALOC_STACK = cvar.ALOC_STACK
ALOC_DIST = cvar.ALOC_DIST
ALOC_REG1 = cvar.ALOC_REG1
ALOC_REG2 = cvar.ALOC_REG2
ALOC_RREL = cvar.ALOC_RREL
ALOC_STATIC = cvar.ALOC_STATIC
ALOC_CUSTOM = cvar.ALOC_CUSTOM

class argloc_t(object):
    r"""
    Proxy of C++ argloc_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        __init__(self) -> argloc_t
            r: argloc_t const &
        """
        _ida_typeinf.argloc_t_swiginit(self, _ida_typeinf.new_argloc_t(*args))
    __swig_destroy__ = _ida_typeinf.delete_argloc_t

    def swap(self, *args) -> "void":
        r"""


        Assign this == r and r == this.
        
        swap(self, r)
            @param r (C++: argloc_t  &)
        """
        return _ida_typeinf.argloc_t_swap(self, *args)

    def atype(self, *args) -> "argloc_type_t":
        r"""


        Get type ( 'Argument location types' )
        """
        return _ida_typeinf.argloc_t_atype(self, *args)

    def is_reg1(self, *args) -> "bool":
        r"""


        See 'ALOC_REG1' .
        """
        return _ida_typeinf.argloc_t_is_reg1(self, *args)

    def is_reg2(self, *args) -> "bool":
        r"""


        See 'ALOC_REG2' .
        """
        return _ida_typeinf.argloc_t_is_reg2(self, *args)

    def is_reg(self, *args) -> "bool":
        r"""


        'is_reg1()' || 'is_reg2()'
        """
        return _ida_typeinf.argloc_t_is_reg(self, *args)

    def is_rrel(self, *args) -> "bool":
        r"""


        See 'ALOC_RREL' .
        """
        return _ida_typeinf.argloc_t_is_rrel(self, *args)

    def is_ea(self, *args) -> "bool":
        r"""


        See 'ALOC_STATIC' .
        """
        return _ida_typeinf.argloc_t_is_ea(self, *args)

    def is_stkoff(self, *args) -> "bool":
        r"""


        See 'ALOC_STACK' .
        """
        return _ida_typeinf.argloc_t_is_stkoff(self, *args)

    def is_scattered(self, *args) -> "bool":
        r"""


        See 'ALOC_DIST' .
        """
        return _ida_typeinf.argloc_t_is_scattered(self, *args)

    def has_reg(self, *args) -> "bool":
        r"""


        TRUE if argloc has a register part.
        """
        return _ida_typeinf.argloc_t_has_reg(self, *args)

    def has_stkoff(self, *args) -> "bool":
        r"""


        TRUE if argloc has a stack part.
        """
        return _ida_typeinf.argloc_t_has_stkoff(self, *args)

    def is_mixed_scattered(self, *args) -> "bool":
        r"""


        mixed scattered: consists of register and stack parts
        """
        return _ida_typeinf.argloc_t_is_mixed_scattered(self, *args)

    def is_fragmented(self, *args) -> "bool":
        r"""


        'is_scattered()' || 'is_reg2()'
        """
        return _ida_typeinf.argloc_t_is_fragmented(self, *args)

    def is_custom(self, *args) -> "bool":
        r"""


        See 'ALOC_CUSTOM' .
        """
        return _ida_typeinf.argloc_t_is_custom(self, *args)

    def is_badloc(self, *args) -> "bool":
        r"""


        See 'ALOC_NONE' .
        """
        return _ida_typeinf.argloc_t_is_badloc(self, *args)

    def reg1(self, *args) -> "int":
        r"""


        Get the register info. Use when 'atype()' == 'ALOC_REG1' or
        'ALOC_REG2'
        """
        return _ida_typeinf.argloc_t_reg1(self, *args)

    def regoff(self, *args) -> "int":
        r"""


        Get offset from the beginning of the register in bytes. Use when
        'atype()' == 'ALOC_REG1'
        """
        return _ida_typeinf.argloc_t_regoff(self, *args)

    def reg2(self, *args) -> "int":
        r"""


        Get info for the second register. Use when 'atype()' == 'ALOC_REG2'
        """
        return _ida_typeinf.argloc_t_reg2(self, *args)

    def get_reginfo(self, *args) -> "uint32":
        r"""


        Get all register info. Use when 'atype()' == 'ALOC_REG1' or
        'ALOC_REG2'
        """
        return _ida_typeinf.argloc_t_get_reginfo(self, *args)

    def stkoff(self, *args) -> "sval_t":
        r"""


        Get the stack offset. Use if 'atype()' == 'ALOC_STACK'
        """
        return _ida_typeinf.argloc_t_stkoff(self, *args)

    def get_ea(self, *args) -> "ea_t":
        r"""


        Get the global address. Use when 'atype()' == 'ALOC_STATIC'
        """
        return _ida_typeinf.argloc_t_get_ea(self, *args)

    def scattered(self, *args) -> "scattered_aloc_t const &":
        r"""


        Get scattered argument info. Use when 'atype()' == 'ALOC_DIST'
        """
        return _ida_typeinf.argloc_t_scattered(self, *args)

    def get_rrel(self, *args) -> "rrel_t const &":
        r"""


        Get register-relative info. Use when 'atype()' == 'ALOC_RREL'
        """
        return _ida_typeinf.argloc_t_get_rrel(self, *args)

    def get_custom(self, *args) -> "void *":
        r"""


        Get custom argloc info. Use if 'atype()' == 'ALOC_CUSTOM'
        """
        return _ida_typeinf.argloc_t_get_custom(self, *args)

    def get_biggest(self, *args) -> "argloc_t::biggest_t":
        r"""


        Get largest element in internal union.
        """
        return _ida_typeinf.argloc_t_get_biggest(self, *args)

    def _set_badloc(self, *args) -> "void":
        r"""


        Use 'set_badloc()'
        """
        return _ida_typeinf.argloc_t__set_badloc(self, *args)

    def _set_reg1(self, *args) -> "void":
        r"""


        Use 'set_reg1()'
        
        _set_reg1(self, reg, off=0)
            @param reg (C++: int)
            @param off (C++: int)
        """
        return _ida_typeinf.argloc_t__set_reg1(self, *args)

    def _set_reg2(self, *args) -> "void":
        r"""


        Use 'set_reg2()'
        
        _set_reg2(self, _reg1, _reg2)
            @param _reg1 (C++: int)
            @param _reg2 (C++: int)
        """
        return _ida_typeinf.argloc_t__set_reg2(self, *args)

    def _set_stkoff(self, *args) -> "void":
        r"""


        Use 'set_stkoff()'
        
        _set_stkoff(self, off)
            @param off (C++: sval_t)
        """
        return _ida_typeinf.argloc_t__set_stkoff(self, *args)

    def _set_ea(self, *args) -> "void":
        r"""


        Use set_ea
        
        _set_ea(self, _ea)
            @param _ea (C++: ea_t)
        """
        return _ida_typeinf.argloc_t__set_ea(self, *args)

    def _consume_rrel(self, *args) -> "bool":
        r"""


        Use 'consume_rrel()'
        
        _consume_rrel(self, p) -> bool
            @param p (C++: rrel_t  *)
        """
        return _ida_typeinf.argloc_t__consume_rrel(self, *args)

    def _consume_scattered(self, *args) -> "bool":
        r"""


        Use 'consume_scattered()'
        
        _consume_scattered(self, p) -> bool
            @param p (C++: scattered_aloc_t  *)
        """
        return _ida_typeinf.argloc_t__consume_scattered(self, *args)

    def _set_custom(self, *args) -> "void":
        r"""


        Set custom argument location (careful - this function does not clean
        up!)
        
        _set_custom(self, ct, pdata)
            @param ct (C++: argloc_type_t)
            @param pdata (C++: void *)
        """
        return _ida_typeinf.argloc_t__set_custom(self, *args)

    def _set_biggest(self, *args) -> "void":
        r"""


        Set biggest element in internal union (careful - this function does
        not clean up!)
        
        _set_biggest(self, ct, data)
            @param ct (C++: argloc_type_t)
            @param data (C++: biggest_t)
        """
        return _ida_typeinf.argloc_t__set_biggest(self, *args)

    def set_reg1(self, *args) -> "void":
        r"""


        Set register location.
        
        set_reg1(self, reg, off=0)
            @param reg (C++: int)
            @param off (C++: int)
        """
        return _ida_typeinf.argloc_t_set_reg1(self, *args)

    def set_reg2(self, *args) -> "void":
        r"""


        Set secondary register location.
        
        set_reg2(self, _reg1, _reg2)
            @param _reg1 (C++: int)
            @param _reg2 (C++: int)
        """
        return _ida_typeinf.argloc_t_set_reg2(self, *args)

    def set_stkoff(self, *args) -> "void":
        r"""


        Set stack offset location.
        
        set_stkoff(self, off)
            @param off (C++: sval_t)
        """
        return _ida_typeinf.argloc_t_set_stkoff(self, *args)

    def set_ea(self, *args) -> "void":
        r"""


        Set static ea location.
        
        set_ea(self, _ea)
            @param _ea (C++: ea_t)
        """
        return _ida_typeinf.argloc_t_set_ea(self, *args)

    def consume_rrel(self, *args) -> "void":
        r"""


        Set register-relative location - can't be NULL.
        
        consume_rrel(self, p)
            @param p (C++: rrel_t  *)
        """
        return _ida_typeinf.argloc_t_consume_rrel(self, *args)

    def set_badloc(self, *args) -> "void":
        r"""


        Set to invalid location.
        """
        return _ida_typeinf.argloc_t_set_badloc(self, *args)

    def calc_offset(self, *args) -> "sval_t":
        r"""


        Calculate offset that can be used to compare 2 similar arglocs.
        """
        return _ida_typeinf.argloc_t_calc_offset(self, *args)

    def advance(self, *args) -> "bool":
        r"""


        Move the location to point 'delta' bytes further.
        
        advance(self, delta) -> bool
            @param delta (C++: int)
        """
        return _ida_typeinf.argloc_t_advance(self, *args)

    def justify_reg_high(self, *args) -> "void":
        r"""


        Set register offset to justify it to the upper part of _SLOTSIZE.
        
        justify_reg_high(self, size, _slotsize)
            @param size (C++: size_t)
            @param _slotsize (C++: size_t)
        """
        return _ida_typeinf.argloc_t_justify_reg_high(self, *args)

    def justify_stkoff_right(self, *args) -> "void":
        r"""


        Set stack offset to right-justify it in _SLOTSIZE.
        
        justify_stkoff_right(self, size, _slotsize)
            @param size (C++: size_t)
            @param _slotsize (C++: size_t)
        """
        return _ida_typeinf.argloc_t_justify_stkoff_right(self, *args)

    def __eq__(self, *args) -> "bool":
        r"""


        __eq__(self, r) -> bool
            r: argloc_t const &
        """
        return _ida_typeinf.argloc_t___eq__(self, *args)

    def __ne__(self, *args) -> "bool":
        r"""


        __ne__(self, r) -> bool
            r: argloc_t const &
        """
        return _ida_typeinf.argloc_t___ne__(self, *args)

    def __lt__(self, *args) -> "bool":
        r"""


        __lt__(self, r) -> bool
            r: argloc_t const &
        """
        return _ida_typeinf.argloc_t___lt__(self, *args)

    def __gt__(self, *args) -> "bool":
        r"""


        __gt__(self, r) -> bool
            r: argloc_t const &
        """
        return _ida_typeinf.argloc_t___gt__(self, *args)

    def __le__(self, *args) -> "bool":
        r"""


        __le__(self, r) -> bool
            r: argloc_t const &
        """
        return _ida_typeinf.argloc_t___le__(self, *args)

    def __ge__(self, *args) -> "bool":
        r"""


        __ge__(self, r) -> bool
            r: argloc_t const &
        """
        return _ida_typeinf.argloc_t___ge__(self, *args)

    def compare(self, *args) -> "int":
        r"""


        compare(self, r) -> int
            r: argloc_t const &
        """
        return _ida_typeinf.argloc_t_compare(self, *args)

    def consume_scattered(self, *args) -> "void":
        r"""


        Set distributed argument location.
        
        consume_scattered(self, p)
            @param p (C++: scattered_aloc_t  *)
        """
        return _ida_typeinf.argloc_t_consume_scattered(self, *args)

# Register argloc_t in _ida_typeinf:
_ida_typeinf.argloc_t_swigregister(argloc_t)

class argpart_t(argloc_t):
    r"""
    Proxy of C++ argpart_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    off = property(_ida_typeinf.argpart_t_off_get, _ida_typeinf.argpart_t_off_set)
    size = property(_ida_typeinf.argpart_t_size_get, _ida_typeinf.argpart_t_size_set)

    def __init__(self, *args):
        r"""


        __init__(self, a) -> argpart_t
            a: argloc_t const &
        """
        _ida_typeinf.argpart_t_swiginit(self, _ida_typeinf.new_argpart_t(*args))

    def bad_offset(self, *args) -> "bool":
        r"""


        Does this argpart have a valid offset?
        """
        return _ida_typeinf.argpart_t_bad_offset(self, *args)

    def bad_size(self, *args) -> "bool":
        r"""


        Does this argpart have a valid size?
        """
        return _ida_typeinf.argpart_t_bad_size(self, *args)

    def __lt__(self, *args) -> "bool":
        r"""


        __lt__(self, r) -> bool
            r: argpart_t const &
        """
        return _ida_typeinf.argpart_t___lt__(self, *args)

    def swap(self, *args) -> "void":
        r"""


        Assign this = r and r = this.
        
        swap(self, r)
            @param r (C++: argpart_t  &)
        """
        return _ida_typeinf.argpart_t_swap(self, *args)
    __swig_destroy__ = _ida_typeinf.delete_argpart_t

# Register argpart_t in _ida_typeinf:
_ida_typeinf.argpart_t_swigregister(argpart_t)

class scattered_aloc_t(argpartvec_t):
    r"""
    Proxy of C++ scattered_aloc_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(self) -> scattered_aloc_t
        """
        _ida_typeinf.scattered_aloc_t_swiginit(self, _ida_typeinf.new_scattered_aloc_t(*args))
    __swig_destroy__ = _ida_typeinf.delete_scattered_aloc_t

# Register scattered_aloc_t in _ida_typeinf:
_ida_typeinf.scattered_aloc_t_swigregister(scattered_aloc_t)


def verify_argloc(*args) -> "int":
    r"""


    Verify 'argloc_t' .
    
    verify_argloc(vloc, size, gaps) -> int
        @param vloc (C++: const  argloc_t  &)
        @param size: total size of the variable (C++: int)
        @param gaps: if not NULL, specifies gaps in structure definition.
                     these gaps should not map to any argloc, but everything
                     else must be covered (C++: const  rangeset_t  *)
        @return: 0 if ok, otherwise an interr code.
    """
    return _ida_typeinf.verify_argloc(*args)

def optimize_argloc(*args) -> "bool":
    r"""


    Verify and optimize scattered argloc into simple form. All new arglocs
    must be processed by this function.
    
    optimize_argloc(vloc, size, gaps) -> bool
        @param vloc (C++: argloc_t  *)
        @param size (C++: int)
        @param gaps (C++: const  rangeset_t  *)
        @retval: true - success
        @retval: false - the input argloc was illegal
    """
    return _ida_typeinf.optimize_argloc(*args)

def print_argloc(*args) -> "size_t":
    r"""


    Convert an argloc to human readable form.
    
    print_argloc(vloc, size=0, vflags=0) -> str
        @param vloc (C++: const  argloc_t  &)
        @param size (C++: int)
        @param vflags (C++: int)
    """
    return _ida_typeinf.print_argloc(*args)
PRALOC_VERIFY = _ida_typeinf.PRALOC_VERIFY
"""
interr if illegal argloc
"""

PRALOC_STKOFF = _ida_typeinf.PRALOC_STKOFF
"""
print stack offsets
"""

class aloc_visitor_t(object):
    r"""
    Proxy of C++ aloc_visitor_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def visit_location(self, *args) -> "int":
        r"""


        visit_location(self, v, off, size) -> int
            @param v (C++: argloc_t  &)
            @param off (C++: int)
            @param size (C++: int)
        """
        return _ida_typeinf.aloc_visitor_t_visit_location(self, *args)

    def __init__(self, *args):
        r"""


        __init__(self) -> aloc_visitor_t
            self: PyObject *
        """
        if self.__class__ == aloc_visitor_t:
            _self = None
        else:
            _self = self
        _ida_typeinf.aloc_visitor_t_swiginit(self, _ida_typeinf.new_aloc_visitor_t(_self, *args))
    __swig_destroy__ = _ida_typeinf.delete_aloc_visitor_t
    def __disown__(self):
        self.this.disown()
        _ida_typeinf.disown_aloc_visitor_t(self)
        return weakref.proxy(self)

# Register aloc_visitor_t in _ida_typeinf:
_ida_typeinf.aloc_visitor_t_swigregister(aloc_visitor_t)


def for_all_arglocs(*args) -> "int":
    r"""


    Compress larger argloc types and initiate the aloc visitor.
    
    for_all_arglocs(vv, vloc, size, off=0) -> int
        @param vv (C++: aloc_visitor_t  &)
        @param vloc (C++: argloc_t  &)
        @param size (C++: int)
        @param off (C++: int)
    """
    return _ida_typeinf.for_all_arglocs(*args)
class const_aloc_visitor_t(object):
    r"""
    Proxy of C++ const_aloc_visitor_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def visit_location(self, *args) -> "int":
        r"""


        visit_location(self, v, off, size) -> int
            @param v (C++: const  argloc_t  &)
            @param off (C++: int)
            @param size (C++: int)
        """
        return _ida_typeinf.const_aloc_visitor_t_visit_location(self, *args)

    def __init__(self, *args):
        r"""


        __init__(self) -> const_aloc_visitor_t
            self: PyObject *
        """
        if self.__class__ == const_aloc_visitor_t:
            _self = None
        else:
            _self = self
        _ida_typeinf.const_aloc_visitor_t_swiginit(self, _ida_typeinf.new_const_aloc_visitor_t(_self, *args))
    __swig_destroy__ = _ida_typeinf.delete_const_aloc_visitor_t
    def __disown__(self):
        self.this.disown()
        _ida_typeinf.disown_const_aloc_visitor_t(self)
        return weakref.proxy(self)

# Register const_aloc_visitor_t in _ida_typeinf:
_ida_typeinf.const_aloc_visitor_t_swigregister(const_aloc_visitor_t)


def for_all_const_arglocs(*args) -> "int":
    r"""


    See 'for_all_arglocs()'
    
    for_all_const_arglocs(vv, vloc, size, off=0) -> int
        @param vv (C++: const_aloc_visitor_t  &)
        @param vloc (C++: const  argloc_t  &)
        @param size (C++: int)
        @param off (C++: int)
    """
    return _ida_typeinf.for_all_const_arglocs(*args)

def is_user_cc(*args) -> "bool":
    r"""


    Does the calling convention specify argument locations explicitly?
    
    is_user_cc(cm) -> bool
        @param cm (C++: cm_t)
    """
    return _ida_typeinf.is_user_cc(*args)

def is_vararg_cc(*args) -> "bool":
    r"""


    Does the calling convention use ellipsis?
    
    is_vararg_cc(cm) -> bool
        @param cm (C++: cm_t)
    """
    return _ida_typeinf.is_vararg_cc(*args)

def is_purging_cc(*args) -> "bool":
    r"""


    Does the calling convention clean the stack arguments upon
    return?.this function is valid only for x86 code
    
    is_purging_cc(cm) -> bool
        @param cm (C++: cm_t)
    """
    return _ida_typeinf.is_purging_cc(*args)
ARGREGS_POLICY_UNDEFINED = _ida_typeinf.ARGREGS_POLICY_UNDEFINED

ARGREGS_GP_ONLY = _ida_typeinf.ARGREGS_GP_ONLY

ARGREGS_INDEPENDENT = _ida_typeinf.ARGREGS_INDEPENDENT

ARGREGS_BY_SLOTS = _ida_typeinf.ARGREGS_BY_SLOTS

ARGREGS_FP_CONSUME_GP = _ida_typeinf.ARGREGS_FP_CONSUME_GP

ARGREGS_MIPS_O32 = _ida_typeinf.ARGREGS_MIPS_O32

class callregs_t(object):
    r"""
    Proxy of C++ callregs_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    policy = property(_ida_typeinf.callregs_t_policy_get, _ida_typeinf.callregs_t_policy_set)
    nregs = property(_ida_typeinf.callregs_t_nregs_get, _ida_typeinf.callregs_t_nregs_set)
    gpregs = property(_ida_typeinf.callregs_t_gpregs_get, _ida_typeinf.callregs_t_gpregs_set)
    fpregs = property(_ida_typeinf.callregs_t_fpregs_get, _ida_typeinf.callregs_t_fpregs_set)

    def __init__(self, *args):
        r"""


        __init__(self) -> callregs_t
            cc: cm_t
        """
        _ida_typeinf.callregs_t_swiginit(self, _ida_typeinf.new_callregs_t(*args))

    def init_regs(self, *args) -> "void":
        r"""


        Init policy & registers for given CC.
        
        init_regs(self, cc)
            @param cc (C++: cm_t)
        """
        return _ida_typeinf.callregs_t_init_regs(self, *args)

    def by_slots(self, *args) -> "bool":
        r"""
        by_slots(self) -> bool
        """
        return _ida_typeinf.callregs_t_by_slots(self, *args)

    def set(self, *args) -> "void":
        r"""


        Init policy & registers (arrays are -1-terminated)
        
        set(self, _policy, gprs, fprs)
            @param _policy (C++: argreg_policy_t)
            @param gprs (C++: const int *)
            @param fprs (C++: const int *)
        """
        return _ida_typeinf.callregs_t_set(self, *args)

    def reset(self, *args) -> "void":
        r"""


        Set policy and registers to invalid values.
        """
        return _ida_typeinf.callregs_t_reset(self, *args)

    @staticmethod
    def regcount(*args) -> "int":
        r"""


        regcount(cc) -> int
            cc: cm_t
        """
        return _ida_typeinf.callregs_t_regcount(*args)

    def reginds(self, *args) -> "bool":
        r"""


        Get register indexes within GP/FP arrays. (-1 -> is not present in the
        corresponding array)
        
        reginds(self, gp_ind, fp_ind, r) -> bool
            @param gp_ind (C++: int *)
            @param fp_ind (C++: int *)
            @param r (C++: int)
        """
        return _ida_typeinf.callregs_t_reginds(self, *args)
    __swig_destroy__ = _ida_typeinf.delete_callregs_t

# Register callregs_t in _ida_typeinf:
_ida_typeinf.callregs_t_swigregister(callregs_t)
C_PC_TINY = cvar.C_PC_TINY
C_PC_SMALL = cvar.C_PC_SMALL
C_PC_COMPACT = cvar.C_PC_COMPACT
C_PC_MEDIUM = cvar.C_PC_MEDIUM
C_PC_LARGE = cvar.C_PC_LARGE
C_PC_HUGE = cvar.C_PC_HUGE
C_PC_FLAT = cvar.C_PC_FLAT

def callregs_t_regcount(*args) -> "int":
    r"""


    callregs_t_regcount(cc) -> int
        cc: cm_t
    """
    return _ida_typeinf.callregs_t_regcount(*args)


def get_comp(*args) -> "comp_t":
    r"""


    Get compiler bits.
    
    get_comp(comp) -> comp_t
        @param comp (C++: comp_t)
    """
    return _ida_typeinf.get_comp(*args)

def get_compiler_name(*args) -> "char const *":
    r"""


    Get full compiler name.
    
    get_compiler_name(id) -> char const *
        @param id (C++: comp_t)
    """
    return _ida_typeinf.get_compiler_name(*args)

def get_compiler_abbr(*args) -> "char const *":
    r"""


    Get abbreviated compiler name.
    
    get_compiler_abbr(id) -> char const *
        @param id (C++: comp_t)
    """
    return _ida_typeinf.get_compiler_abbr(*args)

def get_compilers(*args) -> "void":
    r"""


    Get names of all built-in compilers.
    
    get_compilers(ids, names, abbrs)
        @param ids (C++: compvec_t  *)
        @param names (C++: qstrvec_t  *)
        @param abbrs (C++: qstrvec_t  *)
    """
    return _ida_typeinf.get_compilers(*args)

def is_comp_unsure(*args) -> "comp_t":
    r"""


    See 'COMP_UNSURE' .
    
    is_comp_unsure(comp) -> comp_t
        @param comp (C++: comp_t)
    """
    return _ida_typeinf.is_comp_unsure(*args)

def default_compiler(*args) -> "comp_t":
    r"""


    Get compiler specified by \varmem{inf,idainfo,cc}.
    """
    return _ida_typeinf.default_compiler(*args)

def is_gcc(*args) -> "bool":
    r"""


    Is the target compiler 'COMP_GNU' ?
    """
    return _ida_typeinf.is_gcc(*args)

def is_gcc32(*args) -> "bool":
    r"""


    Is the target compiler 32 bit gcc?
    """
    return _ida_typeinf.is_gcc32(*args)

def is_gcc64(*args) -> "bool":
    r"""


    Is the target compiler 64 bit gcc?
    """
    return _ida_typeinf.is_gcc64(*args)

def gcc_layout(*args) -> "bool":
    r"""


    Should use the struct/union layout as done by gcc?
    """
    return _ida_typeinf.gcc_layout(*args)

def set_compiler(*args) -> "bool":
    r"""


    Change current compiler.
    
    set_compiler(cc, flags, abiname=None) -> bool
        @param cc: compiler to switch to (C++: const  compiler_info_t  &)
        @param flags: Set compiler flags (C++: int)
        @param abiname: ABI name (C++: const char *)
        @return: success
    """
    return _ida_typeinf.set_compiler(*args)
SETCOMP_OVERRIDE = _ida_typeinf.SETCOMP_OVERRIDE
"""
may override old compiler info
"""

SETCOMP_ONLY_ID = _ida_typeinf.SETCOMP_ONLY_ID
"""
cc has only 'id' field the rest will be set to defaults corresponding
to the program bitness
"""

SETCOMP_ONLY_ABI = _ida_typeinf.SETCOMP_ONLY_ABI
"""
ignore cc field complete, use only abiname
"""

SETCOMP_BY_USER = _ida_typeinf.SETCOMP_BY_USER
"""
invoked by user, cannot be replaced by module/loader
"""


def set_compiler_id(*args) -> "bool":
    r"""


    Set the compiler id (see 'Compiler IDs' )
    
    set_compiler_id(id, abiname=None) -> bool
        @param id (C++: comp_t)
        @param abiname (C++: const char *)
    """
    return _ida_typeinf.set_compiler_id(*args)

def set_abi_name(*args) -> "bool":
    r"""


    Set abi name (see 'Compiler IDs' )
    
    set_abi_name(abiname, user_level=False) -> bool
        @param abiname (C++: const char *)
        @param user_level (C++: bool)
    """
    return _ida_typeinf.set_abi_name(*args)

def get_abi_name(*args) -> "qstring *":
    r"""


    Get ABI name.
    """
    return _ida_typeinf.get_abi_name(*args)

def append_abi_opts(*args) -> "bool":
    r"""


    Add/remove/check ABI option General form of full abi name: abiname-
    opt1-opt2-... or -opt1-opt2-...
    
    append_abi_opts(abi_opts, user_level=False) -> bool
        @param abi_opts: - ABI options to add/remove in form opt1-opt2-...
                         (C++: const char *)
        @param user_level: - initiated by user if TRUE (==SETCOMP_BY_USER)
                           (C++: bool)
        @return: success
    """
    return _ida_typeinf.append_abi_opts(*args)

def remove_abi_opts(*args) -> "bool":
    r"""


    remove_abi_opts(abi_opts, user_level=False) -> bool
        @param abi_opts (C++: const char *)
        @param user_level (C++: bool)
    """
    return _ida_typeinf.remove_abi_opts(*args)

def set_compiler_string(*args) -> "bool":
    r"""


    set_compiler_string(compstr, user_level) -> bool
        @param compstr: - compiler description in form <abbr>:<abiname> (C++:
                        const char *)
        @param user_level: - initiated by user if TRUE (C++: bool)
        @return: success
    """
    return _ida_typeinf.set_compiler_string(*args)
MAX_FUNC_ARGS = _ida_typeinf.MAX_FUNC_ARGS
"""
max number of function arguments
"""

abs_unk = _ida_typeinf.abs_unk

abs_no = _ida_typeinf.abs_no

abs_yes = _ida_typeinf.abs_yes

sc_unk = _ida_typeinf.sc_unk

sc_type = _ida_typeinf.sc_type

sc_ext = _ida_typeinf.sc_ext

sc_stat = _ida_typeinf.sc_stat

sc_reg = _ida_typeinf.sc_reg

sc_auto = _ida_typeinf.sc_auto

sc_friend = _ida_typeinf.sc_friend

sc_virt = _ida_typeinf.sc_virt

HTI_CPP = _ida_typeinf.HTI_CPP
"""
C++ mode (not implemented)
"""

HTI_INT = _ida_typeinf.HTI_INT
"""
debug: print internal representation of types
"""

HTI_EXT = _ida_typeinf.HTI_EXT
"""
debug: print external representation of types
"""

HTI_LEX = _ida_typeinf.HTI_LEX
"""
debug: print tokens
"""

HTI_UNP = _ida_typeinf.HTI_UNP
"""
debug: check the result by unpacking it
"""

HTI_TST = _ida_typeinf.HTI_TST
"""
test mode: discard the result
"""

HTI_FIL = _ida_typeinf.HTI_FIL
"""
otherwise "input" contains a C declaration

"input" is file name,
"""

HTI_MAC = _ida_typeinf.HTI_MAC
"""
define macros from the base tils
"""

HTI_NWR = _ida_typeinf.HTI_NWR
"""
no warning messages
"""

HTI_NER = _ida_typeinf.HTI_NER
"""
ignore all errors but display them
"""

HTI_DCL = _ida_typeinf.HTI_DCL
"""
don't complain about redeclarations
"""

HTI_NDC = _ida_typeinf.HTI_NDC
"""
don't decorate names
"""

HTI_PAK = _ida_typeinf.HTI_PAK
"""
explicit structure pack value (#pragma pack)
"""

HTI_PAK_SHIFT = _ida_typeinf.HTI_PAK_SHIFT
"""
shift for 'HTI_PAK' . This field should be used if you want to
remember an explicit pack value for each structure/union type. See
'HTI_PAK' ... definitions
"""

HTI_PAKDEF = _ida_typeinf.HTI_PAKDEF
"""
default pack value
"""

HTI_PAK1 = _ida_typeinf.HTI_PAK1
"""
#pragma pack(1)
"""

HTI_PAK2 = _ida_typeinf.HTI_PAK2
"""
#pragma pack(2)
"""

HTI_PAK4 = _ida_typeinf.HTI_PAK4
"""
#pragma pack(4)
"""

HTI_PAK8 = _ida_typeinf.HTI_PAK8
"""
#pragma pack(8)
"""

HTI_PAK16 = _ida_typeinf.HTI_PAK16
"""
#pragma pack(16)
"""

HTI_HIGH = _ida_typeinf.HTI_HIGH
"""
(with hidden args, etc)

assume high level prototypes
"""

HTI_LOWER = _ida_typeinf.HTI_LOWER
"""
lower the function prototypes
"""

HTI_RAWARGS = _ida_typeinf.HTI_RAWARGS
"""
leave argument names unchanged (do not remove underscores)
"""


def parse_decl(*args) -> "qstring *":
    r"""


    Parse ONE declaration. If the input string contains more than one
    declaration, the first complete type declaration ( 'PT_TYP' ) or the
    last variable declaration ( 'PT_VAR' ) will be used.name & tif may be
    empty after the call!
    
    parse_decl(tif, til, decl, flags) -> str
        @param tif: type info (C++: tinfo_t  *)
        @param til: type library to use. may be NULL (C++: til_t  *)
        @param decl: C declaration to parse (C++: const char *)
        @param flags: combination of  Type parsing flags  bits (C++: int)
        @retval: true - ok
        @retval: false - declaration is bad, the error message is displayed if
                         !PT_SIL
    """
    return _ida_typeinf.parse_decl(*args)
PT_SIL = _ida_typeinf.PT_SIL
"""
silent, no messages
"""

PT_NDC = _ida_typeinf.PT_NDC
"""
don't decorate names
"""

PT_TYP = _ida_typeinf.PT_TYP
"""
return declared type information
"""

PT_VAR = _ida_typeinf.PT_VAR
"""
return declared object information
"""

PT_PACKMASK = _ida_typeinf.PT_PACKMASK
"""
mask for pack alignment values
"""

PT_HIGH = _ida_typeinf.PT_HIGH
"""
(with hidden args, etc)

assume high level prototypes
"""

PT_LOWER = _ida_typeinf.PT_LOWER
"""
lower the function prototypes
"""

PT_REPLACE = _ida_typeinf.PT_REPLACE
"""
replace the old type (used in idc)
"""

PT_RAWARGS = _ida_typeinf.PT_RAWARGS
"""
leave argument names unchanged (do not remove underscores)
"""


def convert_pt_flags_to_hti(*args) -> "int":
    r"""


    Convert 'Type parsing flags' to 'Type formatting flags' . Type parsing
    flags lesser than 0x10 don't have stable meaning and will be ignored
    (more on these flags can be seen in idc.idc)
    
    convert_pt_flags_to_hti(pt_flags) -> int
        @param pt_flags (C++: int)
    """
    return _ida_typeinf.convert_pt_flags_to_hti(*args)

def parse_decls(*args) -> "int":
    r"""


    Parse many declarations and store them in a til. If there are any
    errors, they will be printed using 'printer'. This function uses
    default include path and predefined macros from the database settings.
    It always uses the 'HTI_DCL' bit.
    
    parse_decls(til, input, printer, hti_flags) -> int
        @param til: type library to store the result (C++: til_t  *)
        @param input: input string or file name (see hti_flags) (C++: const
                      char *)
        @param printer: function to output error messages (use msg or NULL or
                        your own callback) (C++: printer_t  *)
        @param hti_flags: combination of  Type formatting flags (C++: int)
        @return: number of errors, 0 means ok.
    """
    return _ida_typeinf.parse_decls(*args)

def print_type(*args) -> "qstring *":
    r"""


    Get type declaration for the specified address.
    
    print_type(ea, prtype_flags) -> str
        @param ea: address (C++: ea_t)
        @param prtype_flags: combination of  Type printing flags (C++: int)
        @return: success
    """
    return _ida_typeinf.print_type(*args)
PRTYPE_1LINE = _ida_typeinf.PRTYPE_1LINE
"""
print to one line
"""

PRTYPE_MULTI = _ida_typeinf.PRTYPE_MULTI
"""
print to many lines
"""

PRTYPE_TYPE = _ida_typeinf.PRTYPE_TYPE
"""
print type declaration (not variable declaration)
"""

PRTYPE_PRAGMA = _ida_typeinf.PRTYPE_PRAGMA
"""
print pragmas for alignment
"""

PRTYPE_SEMI = _ida_typeinf.PRTYPE_SEMI
"""
append ; to the end
"""

PRTYPE_CPP = _ida_typeinf.PRTYPE_CPP
"""
use c++ name (only for 'print_type()' )
"""

PRTYPE_DEF = _ida_typeinf.PRTYPE_DEF
"""
'tinfo_t' : print definition, if available
"""

PRTYPE_NOARGS = _ida_typeinf.PRTYPE_NOARGS
"""
'tinfo_t' : do not print function argument names
"""

PRTYPE_NOARRS = _ida_typeinf.PRTYPE_NOARRS
"""
'tinfo_t' : print arguments with 'FAI_ARRAY' as pointers
"""

PRTYPE_NORES = _ida_typeinf.PRTYPE_NORES
"""
'tinfo_t' : never resolve types (meaningful with PRTYPE_DEF)
"""

PRTYPE_RESTORE = _ida_typeinf.PRTYPE_RESTORE
"""
'tinfo_t' : print restored types for 'FAI_ARRAY' and 'FAI_STRUCT'
"""

PRTYPE_NOREGEX = _ida_typeinf.PRTYPE_NOREGEX
"""
do not apply regular expressions to beautify name
"""

PRTYPE_COLORED = _ida_typeinf.PRTYPE_COLORED
"""
add color tag COLOR_SYMBOL for any parentheses, commas and colons
"""

NTF_TYPE = _ida_typeinf.NTF_TYPE
"""
type name
"""

NTF_SYMU = _ida_typeinf.NTF_SYMU
"""
symbol, name is unmangled ('func')
"""

NTF_SYMM = _ida_typeinf.NTF_SYMM
"""
only one of 'NTF_TYPE' and 'NTF_SYMU' , 'NTF_SYMM' can be used

symbol, name is mangled ('_func')
"""

NTF_NOBASE = _ida_typeinf.NTF_NOBASE
"""
don't inspect base tils (for get_named_type)
"""

NTF_REPLACE = _ida_typeinf.NTF_REPLACE
"""
replace original type (for set_named_type)
"""

NTF_UMANGLED = _ida_typeinf.NTF_UMANGLED
"""
name is unmangled (don't use this flag)
"""

NTF_NOCUR = _ida_typeinf.NTF_NOCUR
"""
don't inspect current til file (for get_named_type)
"""

NTF_64BIT = _ida_typeinf.NTF_64BIT
"""
value is 64bit
"""

NTF_FIXNAME = _ida_typeinf.NTF_FIXNAME
"""
(set_named_type, set_numbered_type only)

force-validate the name of the type when setting
"""

NTF_IDBENC = _ida_typeinf.NTF_IDBENC
"""
the name is given in the IDB encoding; non-ASCII bytes will be decoded
accordingly (set_named_type, set_numbered_type only)
"""

NTF_CHKSYNC = _ida_typeinf.NTF_CHKSYNC
"""
(set_numbered_type, set_named_type)

check that synchronization to IDB passed OK
"""

TERR_OK = _ida_typeinf.TERR_OK

TERR_SAVE = _ida_typeinf.TERR_SAVE

TERR_SERIALIZE = _ida_typeinf.TERR_SERIALIZE

TERR_WRONGNAME = _ida_typeinf.TERR_WRONGNAME

TERR_BADSYNC = _ida_typeinf.TERR_BADSYNC


def del_named_type(*args) -> "bool":
    r"""


    Delete information about a symbol.
    
    del_named_type(ti, name, ntf_flags) -> bool
        @param ti: type library (C++: til_t  *)
        @param name: name of symbol (C++: const char *)
        @param ntf_flags: combination of  Flags for named types (C++: int)
        @return: success
    """
    return _ida_typeinf.del_named_type(*args)

def first_named_type(*args) -> "char const *":
    r"""


    Enumerate types. Returns mangled names. Never returns anonymous types.
    To include it, enumerate types by ordinals.
    
    first_named_type(ti, ntf_flags) -> char const *
        @param ti (C++: const  til_t  *)
        @param ntf_flags (C++: int)
    """
    return _ida_typeinf.first_named_type(*args)

def next_named_type(*args) -> "char const *":
    r"""


    Enumerate types. Returns mangled names. Never returns anonymous types.
    To include it, enumerate types by ordinals.
    
    next_named_type(ti, name, ntf_flags) -> char const *
        @param ti (C++: const  til_t  *)
        @param name (C++: const char *)
        @param ntf_flags (C++: int)
    """
    return _ida_typeinf.next_named_type(*args)

def copy_named_type(*args) -> "uint32":
    r"""


    Copy a named type from one til to another. This function will copy the
    specified type and all dependent types from the source type library to
    the destination library.
    
    copy_named_type(dsttil, srctil, name) -> uint32
        @param dsttil: Destination til. It must have orginal types enabled
                       (C++: til_t  *)
        @param srctil: Source til. (C++: const  til_t  *)
        @param name: name of the type to copy (C++: const char *)
        @return: ordinal number of the copied type. 0 means error
    """
    return _ida_typeinf.copy_named_type(*args)

def gen_decorate_name(*args) -> "qstring *":
    r"""


    Generic function for 'decorate_name()' (may be used in IDP modules)
    
    gen_decorate_name(name, mangle, cc, type) -> str
        @param name (C++: const char *)
        @param mangle (C++: bool)
        @param cc (C++: cm_t)
        @param type (C++: const  tinfo_t  *)
    """
    return _ida_typeinf.gen_decorate_name(*args)

def calc_c_cpp_name(*args) -> "qstring *":
    r"""


    Get C or C++ form of the name.
    
    calc_c_cpp_name(name, type, ccn_flags) -> str
        @param name: original (mangled or decorated) name (C++: const char *)
        @param type: name type if known, otherwise NULL (C++: const  tinfo_t
                     *)
        @param ccn_flags: one of  C/C++ naming flags (C++: int)
    """
    return _ida_typeinf.calc_c_cpp_name(*args)
CCN_C = _ida_typeinf.CCN_C

CCN_CPP = _ida_typeinf.CCN_CPP


def alloc_type_ordinals(*args) -> "uint32":
    r"""


    Allocate a range of ordinal numbers for new types.
    
    alloc_type_ordinals(ti, qty) -> uint32
        @param ti: type library (C++: til_t  *)
        @param qty: number of ordinals to allocate (C++: int)
        @return: the first ordinal. 0 means failure.
    """
    return _ida_typeinf.alloc_type_ordinals(*args)

def alloc_type_ordinal(*args) -> "uint32":
    r"""


    \call2{alloc_type_ordinals,ti,1}
    
    alloc_type_ordinal(ti) -> uint32
        @param ti (C++: til_t  *)
    """
    return _ida_typeinf.alloc_type_ordinal(*args)

def get_ordinal_qty(*args) -> "uint32":
    r"""


    Get number of allocated ordinals.
    
    get_ordinal_qty(ti) -> uint32
        @param ti (C++: const  til_t  *)
        @return: uint32(-1) if failed
    """
    return _ida_typeinf.get_ordinal_qty(*args)

def set_numbered_type(*args) -> "tinfo_code_t":
    r"""


    Store a type in the til. 'name' may be NULL for anonymous types. The
    specified ordinal must be free (no other type is using it). For
    ntf_flags, only 'NTF_REPLACE' is consulted.
    
    set_numbered_type(ti, ordinal, ntf_flags, name, type, fields=None, cmt=None, fldcmts=None, sclass=None) -> tinfo_code_t
        @param ti (C++: til_t  *)
        @param ordinal (C++: uint32)
        @param ntf_flags (C++: int)
        @param name (C++: const char *)
        @param type (C++: const  type_t  *)
        @param fields (C++: const  p_list  *)
        @param cmt (C++: const char *)
        @param fldcmts (C++: const  p_list  *)
        @param sclass (C++: const  sclass_t  *)
    """
    return _ida_typeinf.set_numbered_type(*args)

def del_numbered_type(*args) -> "bool":
    r"""


    Delete a numbered type.
    
    del_numbered_type(ti, ordinal) -> bool
        @param ti (C++: til_t  *)
        @param ordinal (C++: uint32)
    """
    return _ida_typeinf.del_numbered_type(*args)

def set_type_alias(*args) -> "bool":
    r"""


    Create a type alias. Redirects all references to source type to the
    destination type. This is equivalent to instantaneous replacement all
    reference to srctype by dsttype.
    
    set_type_alias(ti, src_ordinal, dst_ordinal) -> bool
        @param ti (C++: til_t  *)
        @param src_ordinal (C++: uint32)
        @param dst_ordinal (C++: uint32)
    """
    return _ida_typeinf.set_type_alias(*args)

def get_alias_target(*args) -> "uint32":
    r"""


    Find the final alias destination. If the ordinal has not been aliased,
    return the specified ordinal itself If failed, returns 0.
    
    get_alias_target(ti, ordinal) -> uint32
        @param ti (C++: const  til_t  *)
        @param ordinal (C++: uint32)
    """
    return _ida_typeinf.get_alias_target(*args)

def get_type_ordinal(*args) -> "int32":
    r"""


    Get type ordinal by its name.
    
    get_type_ordinal(ti, name) -> int32
        @param ti (C++: const  til_t  *)
        @param name (C++: const char *)
    """
    return _ida_typeinf.get_type_ordinal(*args)

def get_numbered_type_name(*args) -> "char const *":
    r"""


    Get type name (if exists) by its ordinal. If the type is anonymous,
    returns "". If failed, returns NULL
    
    get_numbered_type_name(ti, ordinal) -> char const *
        @param ti (C++: const  til_t  *)
        @param ordinal (C++: uint32)
    """
    return _ida_typeinf.get_numbered_type_name(*args)

def create_numbered_type_name(*args) -> "qstring *":
    r"""


    Create anonymous name for numbered type. This name can be used to
    reference a numbered type by its ordinal Ordinal names have the
    following format: '#' + set_de(ord) Returns: -1 if error, otherwise
    the name length
    
    create_numbered_type_name(ord) -> str
        @param ord (C++: int32)
    """
    return _ida_typeinf.create_numbered_type_name(*args)

def is_ordinal_name(*args) -> "bool":
    r"""


    Check if the name is an ordinal name. Ordinal names have the following
    format: '#' + set_de(ord)
    
    is_ordinal_name(name, ord=None) -> bool
        @param name (C++: const char *)
        @param ord (C++: uint32  *)
    """
    return _ida_typeinf.is_ordinal_name(*args)

def get_ordinal_from_idb_type(*args) -> "int":
    r"""


    Get ordinal number of an idb type (struct/enum). The 'type' parameter
    is used only to determine the kind of the type (struct or enum) Use
    this function to find out the correspondence between idb types and til
    types
    
    get_ordinal_from_idb_type(name, type) -> int
        @param name (C++: const char *)
        @param type (C++: const  type_t  *)
    """
    return _ida_typeinf.get_ordinal_from_idb_type(*args)

def is_autosync(*args) -> "bool":
    r"""


    Is the specified idb type automatically synchronized?
    
    is_autosync(name, type) -> bool
        @param name (C++: const char *)
        @param type (C++: const  type_t  *)
    

    is_autosync(name, tif) -> bool
        @param name (C++: const char *)
        tif: tinfo_t const &
    """
    return _ida_typeinf.is_autosync(*args)

def deref_ptr(*args) -> "bool":
    r"""


    Dereference a pointer.
    
    deref_ptr(ptr_ea, tif, closure_obj=None) -> bool
        @param ptr_ea: in/out parameter   in: address of the pointer   out:
                       the pointed address (C++: ea_t *)
        @param tif: type of the pointer (C++: const  tinfo_t  &)
        @param closure_obj: closure object (not used yet) (C++: ea_t *)
        @return: success
    """
    return _ida_typeinf.deref_ptr(*args)

def import_type(*args) -> "tid_t":
    r"""


    Copy a named type from til to idb.
    
    import_type(til, idx, name, flags=0) -> tid_t
        @param til: type library (C++: const  til_t  *)
        @param idx: the position of the new type in the list of types
                    (structures or enums). -1 means at the end of the list
                    (C++: int)
        @param name: the type name (C++: const char *)
        @param flags: combination of  Import type flags (C++: int)
        @return: BADNODE  on error
    """
    return _ida_typeinf.import_type(*args)
IMPTYPE_VERBOSE = _ida_typeinf.IMPTYPE_VERBOSE
"""
more verbose output (dialog boxes may appear)
"""

IMPTYPE_OVERRIDE = _ida_typeinf.IMPTYPE_OVERRIDE
"""
override existing type
"""

IMPTYPE_LOCAL = _ida_typeinf.IMPTYPE_LOCAL
"""
the type is local, the struct/enum won't be marked as til type. there
is no need to specify this bit if til==idati, the kernel will set it
automatically
"""


def add_til(*args) -> "int":
    r"""


    Load a til file.
    
    add_til(name, flags) -> int
        @param name: til name (C++: const char *)
        @param flags: combination of  Load TIL flags (C++: int)
        @return: one of  Load TIL result codes
    """
    return _ida_typeinf.add_til(*args)
ADDTIL_DEFAULT = _ida_typeinf.ADDTIL_DEFAULT
"""
default behavior
"""

ADDTIL_INCOMP = _ida_typeinf.ADDTIL_INCOMP
"""
load incompatible tils
"""

ADDTIL_SILENT = _ida_typeinf.ADDTIL_SILENT
"""
do not ask any questions
"""

ADDTIL_FAILED = _ida_typeinf.ADDTIL_FAILED
"""
something bad, the warning is displayed
"""

ADDTIL_OK = _ida_typeinf.ADDTIL_OK
"""
ok, til is loaded
"""

ADDTIL_COMP = _ida_typeinf.ADDTIL_COMP
"""
ok, but til is not compatible with the current compiler
"""

ADDTIL_ABORTED = _ida_typeinf.ADDTIL_ABORTED
"""
til was not loaded (incompatible til rejected by user)
"""


def del_til(*args) -> "bool":
    r"""


    Unload a til file.
    
    del_til(name) -> bool
        @param name (C++: const char *)
    """
    return _ida_typeinf.del_til(*args)

def apply_named_type(*args) -> "bool":
    r"""


    Apply the specified named type to the address.
    
    apply_named_type(ea, name) -> bool
        @param ea: linear address (C++: ea_t)
        @param name: the type name, e.g. "FILE" (C++: const char *)
        @return: success
    """
    return _ida_typeinf.apply_named_type(*args)

def apply_tinfo(*args) -> "bool":
    r"""


    Apply the specified type to the specified address. This function sets
    the type and tries to convert the item at the specified address to
    conform the type.
    
    apply_tinfo(ea, tif, flags) -> bool
        @param ea: linear address (C++: ea_t)
        @param tif: type string in internal format (C++: const  tinfo_t  &)
        @param flags: combination of  Apply tinfo flags (C++: uint32)
        @return: success
    """
    return _ida_typeinf.apply_tinfo(*args)
TINFO_GUESSED = _ida_typeinf.TINFO_GUESSED
"""
this is a guessed type
"""

TINFO_DEFINITE = _ida_typeinf.TINFO_DEFINITE
"""
this is a definite type
"""

TINFO_DELAYFUNC = _ida_typeinf.TINFO_DELAYFUNC
"""
if type is a function and no function exists at ea, schedule its
creation and argument renaming to auto-analysis otherwise try to
create it immediately
"""

TINFO_STRICT = _ida_typeinf.TINFO_STRICT
"""
never convert given type to another one before applying
"""


def apply_cdecl(*args) -> "bool":
    r"""


    Apply the specified type to the address. This function parses the
    declaration and calls 'apply_tinfo()'
    
    apply_cdecl(til, ea, decl, flags=0) -> bool
        @param til: type library (C++: til_t  *)
        @param ea: linear address (C++: ea_t)
        @param decl: type declaration in C form (C++: const char *)
        @param flags: flags to pass to apply_tinfo ( TINFO_DEFINITE  is always
                      passed) (C++: int)
        @return: success
    """
    return _ida_typeinf.apply_cdecl(*args)

def apply_callee_tinfo(*args) -> "bool":
    r"""


    Apply the type of the called function to the calling instruction. This
    function will append parameter comments and rename the local variables
    of the calling function. It also stores information about the
    instructions that initialize call arguments in the database. Use
    'get_arg_addrs()' to retrieve it if necessary. Alternatively it is
    possible to hook to processor_t::arg_addrs_ready event.
    
    apply_callee_tinfo(caller, tif) -> bool
        @param caller: linear address of the calling instruction. must belong
                       to a function. (C++: ea_t)
        @param tif: type info (C++: const  tinfo_t  &)
        @return: success
    """
    return _ida_typeinf.apply_callee_tinfo(*args)

def apply_once_tinfo_and_name(*args) -> "bool":
    r"""


    Apply the specified type and name to the address. This function checks
    if the address already has a type. If the old typedoes not exist or
    the new type is 'better' than the old type, then thenew type will be
    applied. A type is considered better if it has moreinformation (e.g.
    'BTMT_STRUCT' is better than 'BT_INT' ).The same logic is with the
    name: if the address already have a meaningfulname, it will be
    preserved. Only if the old name does not exist or itis a dummy name
    like byte_123, it will be replaced by the new name.
    
    apply_once_tinfo_and_name(dea, tif, name) -> bool
        @param dea: linear address (C++: ea_t)
        @param tif: type string in the internal format (C++: const  tinfo_t
                    &)
        @param name: new name for the address (C++: const char *)
        @return: success
    """
    return _ida_typeinf.apply_once_tinfo_and_name(*args)

def guess_tinfo(*args) -> "int":
    r"""


    Generate a type information about the id from the disassembly. id can
    be a structure/union/enum id or an address.
    
    guess_tinfo(tif, id) -> int
        @param tif (C++: tinfo_t  *)
        @param id (C++: tid_t)
        @return: one of  Guess tinfo codes
    """
    return _ida_typeinf.guess_tinfo(*args)
GUESS_FUNC_FAILED = _ida_typeinf.GUESS_FUNC_FAILED
"""
couldn't guess the function type
"""

GUESS_FUNC_TRIVIAL = _ida_typeinf.GUESS_FUNC_TRIVIAL
"""
the function type doesn't have interesting info
"""

GUESS_FUNC_OK = _ida_typeinf.GUESS_FUNC_OK
"""
ok, some non-trivial information is gathered
"""


def set_c_header_path(*args) -> "void":
    r"""


    Set include directory path the target compiler.
    
    set_c_header_path(incdir)
        @param incdir (C++: const char *)
    """
    return _ida_typeinf.set_c_header_path(*args)

def get_c_header_path(*args) -> "qstring *":
    r"""


    Get the include directory path of the target compiler.
    """
    return _ida_typeinf.get_c_header_path(*args)

def set_c_macros(*args) -> "void":
    r"""


    Set predefined macros for the target compiler.
    
    set_c_macros(macros)
        @param macros (C++: const char *)
    """
    return _ida_typeinf.set_c_macros(*args)

def get_c_macros(*args) -> "qstring *":
    r"""


    Get predefined macros for the target compiler.
    """
    return _ida_typeinf.get_c_macros(*args)

def get_idati(*args) -> "til_t const *":
    r"""


    Pointer to the local type library - this til is private for each IDB
    file Function that accepts til_t* uses local type library instead of
    NULL.
    """
    return _ida_typeinf.get_idati(*args)

def get_idainfo_by_type(*args) -> "size_t *, flags_t *, opinfo_t *, size_t *":
    r"""


    Extract information from a 'tinfo_t' .
    
    get_idainfo_by_type(tif) -> bool
        @param tif: the type to inspect (C++: const  tinfo_t  &)
    """
    return _ida_typeinf.get_idainfo_by_type(*args)
STI_PCHAR = _ida_typeinf.STI_PCHAR

STI_PUCHAR = _ida_typeinf.STI_PUCHAR

STI_PCCHAR = _ida_typeinf.STI_PCCHAR

STI_PCUCHAR = _ida_typeinf.STI_PCUCHAR

STI_PBYTE = _ida_typeinf.STI_PBYTE

STI_PINT = _ida_typeinf.STI_PINT

STI_PUINT = _ida_typeinf.STI_PUINT

STI_PVOID = _ida_typeinf.STI_PVOID

STI_PPVOID = _ida_typeinf.STI_PPVOID

STI_PCVOID = _ida_typeinf.STI_PCVOID

STI_ACHAR = _ida_typeinf.STI_ACHAR

STI_AUCHAR = _ida_typeinf.STI_AUCHAR

STI_ACCHAR = _ida_typeinf.STI_ACCHAR

STI_ACUCHAR = _ida_typeinf.STI_ACUCHAR

STI_FPURGING = _ida_typeinf.STI_FPURGING

STI_FDELOP = _ida_typeinf.STI_FDELOP

STI_MSGSEND = _ida_typeinf.STI_MSGSEND

STI_AEABI_LCMP = _ida_typeinf.STI_AEABI_LCMP

STI_AEABI_ULCMP = _ida_typeinf.STI_AEABI_ULCMP

STI_DONT_USE = _ida_typeinf.STI_DONT_USE

STI_SIZE_T = _ida_typeinf.STI_SIZE_T

STI_SSIZE_T = _ida_typeinf.STI_SSIZE_T

STI_AEABI_MEMCPY = _ida_typeinf.STI_AEABI_MEMCPY

STI_AEABI_MEMSET = _ida_typeinf.STI_AEABI_MEMSET

STI_AEABI_MEMCLR = _ida_typeinf.STI_AEABI_MEMCLR

STI_RTC_CHECK_2 = _ida_typeinf.STI_RTC_CHECK_2

STI_RTC_CHECK_4 = _ida_typeinf.STI_RTC_CHECK_4

STI_RTC_CHECK_8 = _ida_typeinf.STI_RTC_CHECK_8

STI_LAST = _ida_typeinf.STI_LAST

GTD_CALC_LAYOUT = _ida_typeinf.GTD_CALC_LAYOUT

GTD_NO_LAYOUT = _ida_typeinf.GTD_NO_LAYOUT

GTD_DEL_BITFLDS = _ida_typeinf.GTD_DEL_BITFLDS

GTD_CALC_ARGLOCS = _ida_typeinf.GTD_CALC_ARGLOCS

GTD_NO_ARGLOCS = _ida_typeinf.GTD_NO_ARGLOCS

GTS_NESTED = _ida_typeinf.GTS_NESTED

GTS_BASECLASS = _ida_typeinf.GTS_BASECLASS

SUDT_SORT = _ida_typeinf.SUDT_SORT
"""
fields are not sorted by offset, sort them first
"""

SUDT_ALIGN = _ida_typeinf.SUDT_ALIGN
"""
to match the offsets and size info

recalculate field alignments, struct packing, etc
"""

SUDT_GAPS = _ida_typeinf.SUDT_GAPS
"""
allow to fill gaps with additional members (_BYTE[])
"""

SUDT_UNEX = _ida_typeinf.SUDT_UNEX
"""
references to nonexistent member types are acceptable in this case it
is better to set the corresponding 'udt_member_t::fda' field to the
type alignment. if this field is not set, ida will try to guess the
alignment.
"""

SUDT_FAST = _ida_typeinf.SUDT_FAST
"""
serialize without verifying offsets and alignments
"""

SUDT_CONST = _ida_typeinf.SUDT_CONST
"""
only for serialize_udt: make type const
"""

SUDT_VOLATILE = _ida_typeinf.SUDT_VOLATILE
"""
only for serialize_udt: make type volatile
"""

SUDT_TRUNC = _ida_typeinf.SUDT_TRUNC
"""
serialize: truncate useless strings from fields, fldcmts
"""


def copy_tinfo_t(*args) -> "void":
    r"""


    copy_tinfo_t(_this, r)
        _this: tinfo_t *
        r: tinfo_t const &
    """
    return _ida_typeinf.copy_tinfo_t(*args)

def clear_tinfo_t(*args) -> "void":
    r"""


    clear_tinfo_t(_this)
        _this: tinfo_t *
    """
    return _ida_typeinf.clear_tinfo_t(*args)

def create_tinfo(*args) -> "bool":
    r"""


    create_tinfo(_this, bt, bt2, ptr) -> bool
        _this: tinfo_t *
        bt: type_t
        bt2: type_t
        ptr: void *
    """
    return _ida_typeinf.create_tinfo(*args)

def verify_tinfo(*args) -> "int":
    r"""


    verify_tinfo(typid) -> int
        typid: uint32
    """
    return _ida_typeinf.verify_tinfo(*args)

def get_tinfo_details(*args) -> "bool":
    r"""


    get_tinfo_details(typid, bt2, buf) -> bool
        typid: uint32
        bt2: type_t
        buf: void *
    """
    return _ida_typeinf.get_tinfo_details(*args)

def get_tinfo_size(*args) -> "size_t":
    r"""


    get_tinfo_size(p_effalign, typid, gts_code) -> size_t
        p_effalign: uint32 *
        typid: uint32
        gts_code: int
    """
    return _ida_typeinf.get_tinfo_size(*args)

def get_tinfo_pdata(*args) -> "size_t":
    r"""


    get_tinfo_pdata(outptr, typid, what) -> size_t
        outptr: void *
        typid: uint32
        what: int
    """
    return _ida_typeinf.get_tinfo_pdata(*args)

def get_tinfo_property(*args) -> "size_t":
    r"""


    get_tinfo_property(typid, gta_prop) -> size_t
        typid: uint32
        gta_prop: int
    """
    return _ida_typeinf.get_tinfo_property(*args)

def set_tinfo_property(*args) -> "size_t":
    r"""


    set_tinfo_property(tif, sta_prop, x) -> size_t
        tif: tinfo_t *
        sta_prop: int
        x: size_t
    """
    return _ida_typeinf.set_tinfo_property(*args)

def serialize_tinfo(*args) -> "bool":
    r"""


    serialize_tinfo(type, fields, fldcmts, tif, sudt_flags) -> bool
        type: qtype *
        fields: qtype *
        fldcmts: qtype *
        tif: tinfo_t const *
        sudt_flags: int
    """
    return _ida_typeinf.serialize_tinfo(*args)

def deserialize_tinfo(*args) -> "bool":
    r"""


    deserialize_tinfo(tif, til, ptype, pfields, pfldcmts) -> bool
        tif: tinfo_t *
        til: til_t const *
        ptype: type_t const **
        pfields: p_list const **
        pfldcmts: p_list const **
    """
    return _ida_typeinf.deserialize_tinfo(*args)

def find_tinfo_udt_member(*args) -> "int":
    r"""


    find_tinfo_udt_member(udm, typid, strmem_flags) -> int
        udm: udt_member_t *
        typid: uint32
        strmem_flags: int
    """
    return _ida_typeinf.find_tinfo_udt_member(*args)

def print_tinfo(*args) -> "qstring *":
    r"""


    print_tinfo(prefix, indent, cmtindent, flags, tif, name, cmt) -> str
        prefix: char const *
        indent: int
        cmtindent: int
        flags: int
        tif: tinfo_t const *
        name: char const *
        cmt: char const *
    """
    return _ida_typeinf.print_tinfo(*args)

def dstr_tinfo(*args) -> "char const *":
    r"""


    dstr_tinfo(tif) -> char const *
        tif: tinfo_t const *
    """
    return _ida_typeinf.dstr_tinfo(*args)

def visit_subtypes(*args) -> "int":
    r"""


    visit_subtypes(visitor, out, tif, name, cmt) -> int
        visitor: tinfo_visitor_t *
        out: type_mods_t *
        tif: tinfo_t const &
        name: char const *
        cmt: char const *
    """
    return _ida_typeinf.visit_subtypes(*args)

def compare_tinfo(*args) -> "bool":
    r"""


    compare_tinfo(t1, t2, tcflags) -> bool
        t1: uint32
        t2: uint32
        tcflags: int
    """
    return _ida_typeinf.compare_tinfo(*args)

def lexcompare_tinfo(*args) -> "int":
    r"""


    lexcompare_tinfo(t1, t2, arg3) -> int
        t1: uint32
        t2: uint32
        arg3: int
    """
    return _ida_typeinf.lexcompare_tinfo(*args)

def get_stock_tinfo(*args) -> "bool":
    r"""


    get_stock_tinfo(tif, id) -> bool
        tif: tinfo_t *
        id: enum stock_type_id_t
    """
    return _ida_typeinf.get_stock_tinfo(*args)

def read_tinfo_bitfield_value(*args) -> "uint64":
    r"""


    read_tinfo_bitfield_value(typid, v, bitoff) -> uint64
        typid: uint32
        v: uint64
        bitoff: int
    """
    return _ida_typeinf.read_tinfo_bitfield_value(*args)

def write_tinfo_bitfield_value(*args) -> "uint64":
    r"""


    write_tinfo_bitfield_value(typid, dst, v, bitoff) -> uint64
        typid: uint32
        dst: uint64
        v: uint64
        bitoff: int
    """
    return _ida_typeinf.write_tinfo_bitfield_value(*args)

def get_tinfo_attr(*args) -> "bool":
    r"""


    get_tinfo_attr(typid, key, bv, all_attrs) -> bool
        typid: uint32
        key: qstring const &
        bv: bytevec_t *
        all_attrs: bool
    """
    return _ida_typeinf.get_tinfo_attr(*args)

def set_tinfo_attr(*args) -> "bool":
    r"""


    set_tinfo_attr(tif, ta, may_overwrite) -> bool
        tif: tinfo_t *
        ta: type_attr_t const &
        may_overwrite: bool
    """
    return _ida_typeinf.set_tinfo_attr(*args)

def del_tinfo_attr(*args) -> "bool":
    r"""


    del_tinfo_attr(tif, key, make_copy) -> bool
        tif: tinfo_t *
        key: qstring const &
        make_copy: bool
    """
    return _ida_typeinf.del_tinfo_attr(*args)

def get_tinfo_attrs(*args) -> "bool":
    r"""


    get_tinfo_attrs(typid, tav, include_ref_attrs) -> bool
        typid: uint32
        tav: type_attrs_t *
        include_ref_attrs: bool
    """
    return _ida_typeinf.get_tinfo_attrs(*args)

def set_tinfo_attrs(*args) -> "bool":
    r"""


    set_tinfo_attrs(tif, ta) -> bool
        tif: tinfo_t *
        ta: type_attrs_t *
    """
    return _ida_typeinf.set_tinfo_attrs(*args)

def score_tinfo(*args) -> "uint32":
    r"""


    score_tinfo(tif) -> uint32
        tif: tinfo_t const *
    """
    return _ida_typeinf.score_tinfo(*args)

def save_tinfo(*args) -> "tinfo_code_t":
    r"""


    save_tinfo(tif, til, ord, name, ntf_flags) -> tinfo_code_t
        tif: tinfo_t *
        til: til_t *
        ord: size_t
        name: char const *
        ntf_flags: int
    """
    return _ida_typeinf.save_tinfo(*args)

def append_tinfo_covered(*args) -> "bool":
    r"""


    append_tinfo_covered(out, typid, offset) -> bool
        out: rangeset_t *
        typid: uint32
        offset: uint64
    """
    return _ida_typeinf.append_tinfo_covered(*args)

def calc_tinfo_gaps(*args) -> "bool":
    r"""


    calc_tinfo_gaps(out, typid) -> bool
        out: rangeset_t *
        typid: uint32
    """
    return _ida_typeinf.calc_tinfo_gaps(*args)
class tinfo_t(object):
    r"""
    Proxy of C++ tinfo_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        __init__(self) -> tinfo_t
            decl_type: type_t
        

        __init__(self, r) -> tinfo_t
            r: tinfo_t const &
        """
        _ida_typeinf.tinfo_t_swiginit(self, _ida_typeinf.new_tinfo_t(*args))

    def clear(self, *args) -> "void":
        r"""


        Clear contents of this tinfo, and remove from the type system.
        """
        return _ida_typeinf.tinfo_t_clear(self, *args)

    def swap(self, *args) -> "void":
        r"""


        Assign this = r and r = this.
        
        swap(self, r)
            @param r (C++: tinfo_t  &)
        """
        return _ida_typeinf.tinfo_t_swap(self, *args)

    def get_named_type(self, *args) -> "bool":
        r"""


        Create a 'tinfo_t' object for an existing named type.
        
        get_named_type(self, til, name, decl_type=BTF_TYPEDEF, resolve=True, try_ordinal=True) -> bool
            @param til: type library to use (C++: const  til_t  *)
            @param name: name of the type to link to (C++: const char *)
            @param decl_type: if the reference was explicitly specified with the
                              type tag    ( BTF_STRUCT / BTF_UNION / BTF_ENUM )
                              you may specify it.    the kernel will accept only
                              the specified tag after resolving    the type. If
                              the resolved type does not correspond to the
                              explicitly specified tag, the type will be
                              considered as undefined (C++: type_t)
            @param resolve: true: immediately resolve the type and return success
                            code. false: return true but do not immediately
                            resolve the type (C++: bool)
            @param try_ordinal: true: try to replace name reference by an ordinal
                                reference (C++: bool)
        """
        return _ida_typeinf.tinfo_t_get_named_type(self, *args)

    def get_numbered_type(self, *args) -> "bool":
        r"""


        Create a 'tinfo_t' object for an existing ordinal type.
        
        get_numbered_type(self, til, ordinal, decl_type=BTF_TYPEDEF, resolve=True) -> bool
            @param til: type library to use (C++: const  til_t  *)
            @param ordinal: number of the type to link to (C++: uint32)
            @param decl_type: if the reference was explicitly specified with the
                              type tag (BTF_STRUCT/BTF_UNION/BTF_ENUM) you may
                              specify it. the kernel will accept only the
                              specified tag after resolving the type. If the
                              resolved type does not correspond to the explicitly
                              specified tag, the type will be considered as
                              undefined (C++: type_t)
            @param resolve: true: immediately resolve the type and return success
                            code false: return true but do not immediately resolve
                            the type (C++: bool)
        """
        return _ida_typeinf.tinfo_t_get_numbered_type(self, *args)

    def is_correct(self, *args) -> "bool":
        r"""


        Is the type object correct?. It is possible to create incorrect types.
        For example, we can define a function that returns a enum and then
        delete the enum type. If this function returns false, the type should
        not be used in disassembly. Please note that this function does not
        verify all involved types: for example, pointers to undefined types
        are permitted.
        """
        return _ida_typeinf.tinfo_t_is_correct(self, *args)

    def get_realtype(self, *args) -> "type_t":
        r"""


        Get the resolved base type. Deserialization options:if full=true, the
        referenced type will be deserialized fully, this may not always be
        desirable (slows down things)if full=false, we just return the base
        type, the referenced type will be resolved again later if necessary
        (this may lead to multiple resolvings of the same type) imho
        full=false is a better approach because it does not perform
        unnecessary actions just in case. however, in some cases the caller
        knows that it is very likely that full type info will be required. in
        those cases full=true makes sense
        
        get_realtype(self, full=False) -> type_t
            @param full (C++: bool)
        """
        return _ida_typeinf.tinfo_t_get_realtype(self, *args)

    def get_decltype(self, *args) -> "type_t":
        r"""


        Get declared type (without resolving type references; they are
        returned as is). Obviously this is a very fast function and should be
        used instead of 'get_realtype()' if possible.
        """
        return _ida_typeinf.tinfo_t_get_decltype(self, *args)

    def empty(self, *args) -> "bool":
        r"""


        Was 'tinfo_t' initialized with some type info or not?
        """
        return _ida_typeinf.tinfo_t_empty(self, *args)

    def present(self, *args) -> "bool":
        r"""


        Is the type really present? (not a reference to a missing type, for
        example)
        """
        return _ida_typeinf.tinfo_t_present(self, *args)

    def get_size(self, *args) -> "size_t":
        r"""


        Get the type size in bytes.
        
        get_size(self, p_effalign=None, gts_code=0) -> size_t
            @param p_effalign: buffer for the alignment value (C++: uint32  *)
            @param gts_code: combination of GTS_... constants (C++: int)
            @return: BADSIZE  in case of problems
        """
        return _ida_typeinf.tinfo_t_get_size(self, *args)

    def get_unpadded_size(self, *args) -> "size_t":
        r"""


        Get the type size in bytes without the final padding, in bytes. For
        some UDTs 'get_unpadded_size()' != 'get_size()'
        """
        return _ida_typeinf.tinfo_t_get_unpadded_size(self, *args)

    def get_sign(self, *args) -> "type_sign_t":
        r"""


        Get type sign.
        """
        return _ida_typeinf.tinfo_t_get_sign(self, *args)

    def is_signed(self, *args) -> "bool":
        r"""


        Is this a signed type?
        """
        return _ida_typeinf.tinfo_t_is_signed(self, *args)

    def is_unsigned(self, *args) -> "bool":
        r"""


        Is this an unsigned type?
        """
        return _ida_typeinf.tinfo_t_is_unsigned(self, *args)

    def get_declalign(self, *args) -> "uchar":
        r"""


        Get declared alignment of the type.
        """
        return _ida_typeinf.tinfo_t_get_declalign(self, *args)

    def set_declalign(self, *args) -> "bool":
        r"""


        Set declared alignment of the type.
        
        set_declalign(self, declalign) -> bool
            @param declalign (C++: uchar)
        """
        return _ida_typeinf.tinfo_t_set_declalign(self, *args)

    def is_typeref(self, *args) -> "bool":
        r"""


        Is this type a type reference?. Type references cannot be modified.
        Once created, they do not change. Because of this, the set_...
        functions applied to typerefs create a new type id. Other types are
        modified directly.
        """
        return _ida_typeinf.tinfo_t_is_typeref(self, *args)

    def has_details(self, *args) -> "bool":
        r"""


        Does this type refer to a nontrivial type?
        """
        return _ida_typeinf.tinfo_t_has_details(self, *args)

    def get_type_name(self, *args) -> "bool":
        r"""


        Does a type refer to a name?. If yes, fill the provided buffer with
        the type name and return true. Names are returned for numbered types
        too: either a user-defined nice name or, if a user-provided name does
        not exist, an ordinal name (like #xx, see
        'create_numbered_type_name()' ).
        """
        return _ida_typeinf.tinfo_t_get_type_name(self, *args)

    def get_final_type_name(self, *args) -> "bool":
        r"""


        Use in the case of typedef chain (TYPE1 -> TYPE2 -> TYPE3...TYPEn).
        """
        return _ida_typeinf.tinfo_t_get_final_type_name(self, *args)

    def get_next_type_name(self, *args) -> "bool":
        r"""


        Use In the case of typedef chain (TYPE1 -> TYPE2 -> TYPE3...TYPEn).
        """
        return _ida_typeinf.tinfo_t_get_next_type_name(self, *args)

    def get_ordinal(self, *args) -> "uint32":
        r"""


        Get type ordinal (only if the type was created as a numbered type, 0
        if none)
        """
        return _ida_typeinf.tinfo_t_get_ordinal(self, *args)

    def get_final_ordinal(self, *args) -> "uint32":
        r"""


        Get final type ordinal (0 is none)
        """
        return _ida_typeinf.tinfo_t_get_final_ordinal(self, *args)

    def get_til(self, *args) -> "til_t const *":
        r"""


        Get the type library for 'tinfo_t' .
        """
        return _ida_typeinf.tinfo_t_get_til(self, *args)

    def is_from_subtil(self, *args) -> "bool":
        r"""


        Was the named type found in some base type library (not the top level
        type library)?. If yes, it usually means that the type comes from some
        loaded type library, not the local type library for the database
        """
        return _ida_typeinf.tinfo_t_is_from_subtil(self, *args)

    def is_forward_decl(self, *args) -> "bool":
        r"""


        Is this a forward declaration?. Forward declarations are placeholders:
        the type definition does not exist
        """
        return _ida_typeinf.tinfo_t_is_forward_decl(self, *args)

    def is_decl_const(self, *args) -> "bool":
        r"""


        \isdecl{is_type_const}
        """
        return _ida_typeinf.tinfo_t_is_decl_const(self, *args)

    def is_decl_volatile(self, *args) -> "bool":
        r"""


        \isdecl{is_type_volatile}
        """
        return _ida_typeinf.tinfo_t_is_decl_volatile(self, *args)

    def is_decl_void(self, *args) -> "bool":
        r"""


        \isdecl{is_type_void}
        """
        return _ida_typeinf.tinfo_t_is_decl_void(self, *args)

    def is_decl_partial(self, *args) -> "bool":
        r"""


        \isdecl{is_type_partial}
        """
        return _ida_typeinf.tinfo_t_is_decl_partial(self, *args)

    def is_decl_unknown(self, *args) -> "bool":
        r"""


        \isdecl{is_type_unknown}
        """
        return _ida_typeinf.tinfo_t_is_decl_unknown(self, *args)

    def is_decl_last(self, *args) -> "bool":
        r"""


        \isdecl{is_typeid_last}
        """
        return _ida_typeinf.tinfo_t_is_decl_last(self, *args)

    def is_decl_ptr(self, *args) -> "bool":
        r"""


        \isdecl{is_type_ptr}
        """
        return _ida_typeinf.tinfo_t_is_decl_ptr(self, *args)

    def is_decl_array(self, *args) -> "bool":
        r"""


        \isdecl{is_type_array}
        """
        return _ida_typeinf.tinfo_t_is_decl_array(self, *args)

    def is_decl_func(self, *args) -> "bool":
        r"""


        \isdecl{is_type_func}
        """
        return _ida_typeinf.tinfo_t_is_decl_func(self, *args)

    def is_decl_complex(self, *args) -> "bool":
        r"""


        \isdecl{is_type_complex}
        """
        return _ida_typeinf.tinfo_t_is_decl_complex(self, *args)

    def is_decl_typedef(self, *args) -> "bool":
        r"""


        \isdecl{is_type_typedef}
        """
        return _ida_typeinf.tinfo_t_is_decl_typedef(self, *args)

    def is_decl_sue(self, *args) -> "bool":
        r"""


        \isdecl{is_type_sue}
        """
        return _ida_typeinf.tinfo_t_is_decl_sue(self, *args)

    def is_decl_struct(self, *args) -> "bool":
        r"""


        \isdecl{is_type_struct}
        """
        return _ida_typeinf.tinfo_t_is_decl_struct(self, *args)

    def is_decl_union(self, *args) -> "bool":
        r"""


        \isdecl{is_type_union}
        """
        return _ida_typeinf.tinfo_t_is_decl_union(self, *args)

    def is_decl_udt(self, *args) -> "bool":
        r"""


        \isdecl{is_type_struni}
        """
        return _ida_typeinf.tinfo_t_is_decl_udt(self, *args)

    def is_decl_enum(self, *args) -> "bool":
        r"""


        \isdecl{is_type_enum}
        """
        return _ida_typeinf.tinfo_t_is_decl_enum(self, *args)

    def is_decl_bitfield(self, *args) -> "bool":
        r"""


        \isdecl{is_type_bitfld}
        """
        return _ida_typeinf.tinfo_t_is_decl_bitfield(self, *args)

    def is_decl_int128(self, *args) -> "bool":
        r"""


        \isdecl{is_type_int128}
        """
        return _ida_typeinf.tinfo_t_is_decl_int128(self, *args)

    def is_decl_int64(self, *args) -> "bool":
        r"""


        \isdecl{is_type_int64}
        """
        return _ida_typeinf.tinfo_t_is_decl_int64(self, *args)

    def is_decl_int32(self, *args) -> "bool":
        r"""


        \isdecl{is_type_int32}
        """
        return _ida_typeinf.tinfo_t_is_decl_int32(self, *args)

    def is_decl_int16(self, *args) -> "bool":
        r"""


        \isdecl{is_type_int16}
        """
        return _ida_typeinf.tinfo_t_is_decl_int16(self, *args)

    def is_decl_int(self, *args) -> "bool":
        r"""


        \isdecl{is_type_int}
        """
        return _ida_typeinf.tinfo_t_is_decl_int(self, *args)

    def is_decl_char(self, *args) -> "bool":
        r"""


        \isdecl{is_type_char}
        """
        return _ida_typeinf.tinfo_t_is_decl_char(self, *args)

    def is_decl_uint(self, *args) -> "bool":
        r"""


        \isdecl{is_type_uint}
        """
        return _ida_typeinf.tinfo_t_is_decl_uint(self, *args)

    def is_decl_uchar(self, *args) -> "bool":
        r"""


        \isdecl{is_type_uchar}
        """
        return _ida_typeinf.tinfo_t_is_decl_uchar(self, *args)

    def is_decl_uint16(self, *args) -> "bool":
        r"""


        \isdecl{is_type_uint16}
        """
        return _ida_typeinf.tinfo_t_is_decl_uint16(self, *args)

    def is_decl_uint32(self, *args) -> "bool":
        r"""


        \isdecl{is_type_uint32}
        """
        return _ida_typeinf.tinfo_t_is_decl_uint32(self, *args)

    def is_decl_uint64(self, *args) -> "bool":
        r"""


        \isdecl{is_type_uint64}
        """
        return _ida_typeinf.tinfo_t_is_decl_uint64(self, *args)

    def is_decl_uint128(self, *args) -> "bool":
        r"""


        \isdecl{is_type_uint128}
        """
        return _ida_typeinf.tinfo_t_is_decl_uint128(self, *args)

    def is_decl_ldouble(self, *args) -> "bool":
        r"""


        \isdecl{is_type_ldouble}
        """
        return _ida_typeinf.tinfo_t_is_decl_ldouble(self, *args)

    def is_decl_double(self, *args) -> "bool":
        r"""


        \isdecl{is_type_double}
        """
        return _ida_typeinf.tinfo_t_is_decl_double(self, *args)

    def is_decl_float(self, *args) -> "bool":
        r"""


        \isdecl{is_type_float}
        """
        return _ida_typeinf.tinfo_t_is_decl_float(self, *args)

    def is_decl_tbyte(self, *args) -> "bool":
        r"""


        \isdecl{is_type_tbyte}
        """
        return _ida_typeinf.tinfo_t_is_decl_tbyte(self, *args)

    def is_decl_floating(self, *args) -> "bool":
        r"""


        \isdecl{is_type_floating}
        """
        return _ida_typeinf.tinfo_t_is_decl_floating(self, *args)

    def is_decl_bool(self, *args) -> "bool":
        r"""


        \isdecl{is_type_bool}
        """
        return _ida_typeinf.tinfo_t_is_decl_bool(self, *args)

    def is_decl_paf(self, *args) -> "bool":
        r"""


        \isdecl{is_type_paf}
        """
        return _ida_typeinf.tinfo_t_is_decl_paf(self, *args)

    def is_well_defined(self, *args) -> "bool":
        r"""


        !( 'empty()' ) && !( 'is_decl_partial()' )
        """
        return _ida_typeinf.tinfo_t_is_well_defined(self, *args)

    def is_const(self, *args) -> "bool":
        r"""


        \isreal{is_type_const}
        """
        return _ida_typeinf.tinfo_t_is_const(self, *args)

    def is_volatile(self, *args) -> "bool":
        r"""


        \isreal{is_type_volatile}
        """
        return _ida_typeinf.tinfo_t_is_volatile(self, *args)

    def is_void(self, *args) -> "bool":
        r"""


        \isreal{is_type_void}
        """
        return _ida_typeinf.tinfo_t_is_void(self, *args)

    def is_partial(self, *args) -> "bool":
        r"""


        \isreal{is_type_partial}
        """
        return _ida_typeinf.tinfo_t_is_partial(self, *args)

    def is_unknown(self, *args) -> "bool":
        r"""


        \isreal{is_type_unknown}
        """
        return _ida_typeinf.tinfo_t_is_unknown(self, *args)

    def is_ptr(self, *args) -> "bool":
        r"""


        \isreal{is_type_ptr}
        """
        return _ida_typeinf.tinfo_t_is_ptr(self, *args)

    def is_array(self, *args) -> "bool":
        r"""


        \isreal{is_type_array}
        """
        return _ida_typeinf.tinfo_t_is_array(self, *args)

    def is_func(self, *args) -> "bool":
        r"""


        \isreal{is_type_func}
        """
        return _ida_typeinf.tinfo_t_is_func(self, *args)

    def is_complex(self, *args) -> "bool":
        r"""


        \isreal{is_type_complex}
        """
        return _ida_typeinf.tinfo_t_is_complex(self, *args)

    def is_struct(self, *args) -> "bool":
        r"""


        \isreal{is_type_struct}
        """
        return _ida_typeinf.tinfo_t_is_struct(self, *args)

    def is_union(self, *args) -> "bool":
        r"""


        \isreal{is_type_union}
        """
        return _ida_typeinf.tinfo_t_is_union(self, *args)

    def is_udt(self, *args) -> "bool":
        r"""


        \isreal{is_type_struni}
        """
        return _ida_typeinf.tinfo_t_is_udt(self, *args)

    def is_enum(self, *args) -> "bool":
        r"""


        \isreal{is_type_enum}
        """
        return _ida_typeinf.tinfo_t_is_enum(self, *args)

    def is_sue(self, *args) -> "bool":
        r"""


        \isreal{is_type_sue}
        """
        return _ida_typeinf.tinfo_t_is_sue(self, *args)

    def is_bitfield(self, *args) -> "bool":
        r"""


        \isreal{is_type_bitfld}
        """
        return _ida_typeinf.tinfo_t_is_bitfield(self, *args)

    def is_int128(self, *args) -> "bool":
        r"""


        \isreal{is_type_int128}
        """
        return _ida_typeinf.tinfo_t_is_int128(self, *args)

    def is_int64(self, *args) -> "bool":
        r"""


        \isreal{is_type_int64}
        """
        return _ida_typeinf.tinfo_t_is_int64(self, *args)

    def is_int32(self, *args) -> "bool":
        r"""


        \isreal{is_type_int32}
        """
        return _ida_typeinf.tinfo_t_is_int32(self, *args)

    def is_int16(self, *args) -> "bool":
        r"""


        \isreal{is_type_int16}
        """
        return _ida_typeinf.tinfo_t_is_int16(self, *args)

    def is_int(self, *args) -> "bool":
        r"""


        \isreal{is_type_int}
        """
        return _ida_typeinf.tinfo_t_is_int(self, *args)

    def is_char(self, *args) -> "bool":
        r"""


        \isreal{is_type_char}
        """
        return _ida_typeinf.tinfo_t_is_char(self, *args)

    def is_uint(self, *args) -> "bool":
        r"""


        \isreal{is_type_uint}
        """
        return _ida_typeinf.tinfo_t_is_uint(self, *args)

    def is_uchar(self, *args) -> "bool":
        r"""


        \isreal{is_type_uchar}
        """
        return _ida_typeinf.tinfo_t_is_uchar(self, *args)

    def is_uint16(self, *args) -> "bool":
        r"""


        \isreal{is_type_uint16}
        """
        return _ida_typeinf.tinfo_t_is_uint16(self, *args)

    def is_uint32(self, *args) -> "bool":
        r"""


        \isreal{is_type_uint32}
        """
        return _ida_typeinf.tinfo_t_is_uint32(self, *args)

    def is_uint64(self, *args) -> "bool":
        r"""


        \isreal{is_type_uint64}
        """
        return _ida_typeinf.tinfo_t_is_uint64(self, *args)

    def is_uint128(self, *args) -> "bool":
        r"""


        \isreal{is_type_uint128}
        """
        return _ida_typeinf.tinfo_t_is_uint128(self, *args)

    def is_ldouble(self, *args) -> "bool":
        r"""


        \isreal{is_type_ldouble}
        """
        return _ida_typeinf.tinfo_t_is_ldouble(self, *args)

    def is_double(self, *args) -> "bool":
        r"""


        \isreal{is_type_double}
        """
        return _ida_typeinf.tinfo_t_is_double(self, *args)

    def is_float(self, *args) -> "bool":
        r"""


        \isreal{is_type_float}
        """
        return _ida_typeinf.tinfo_t_is_float(self, *args)

    def is_tbyte(self, *args) -> "bool":
        r"""


        \isreal{is_type_tbyte}
        """
        return _ida_typeinf.tinfo_t_is_tbyte(self, *args)

    def is_bool(self, *args) -> "bool":
        r"""


        \isreal{is_type_bool}
        """
        return _ida_typeinf.tinfo_t_is_bool(self, *args)

    def is_paf(self, *args) -> "bool":
        r"""


        \isreal{is_type_paf}
        """
        return _ida_typeinf.tinfo_t_is_paf(self, *args)

    def is_ptr_or_array(self, *args) -> "bool":
        r"""


        \isreal{is_type_ptr_or_array}
        """
        return _ida_typeinf.tinfo_t_is_ptr_or_array(self, *args)

    def is_integral(self, *args) -> "bool":
        r"""


        \isreal{is_type_integral}
        """
        return _ida_typeinf.tinfo_t_is_integral(self, *args)

    def is_ext_integral(self, *args) -> "bool":
        r"""


        \isreal{is_type_ext_integral}
        """
        return _ida_typeinf.tinfo_t_is_ext_integral(self, *args)

    def is_floating(self, *args) -> "bool":
        r"""


        \isreal{is_type_floating}
        """
        return _ida_typeinf.tinfo_t_is_floating(self, *args)

    def is_arithmetic(self, *args) -> "bool":
        r"""


        \isreal{is_type_arithmetic}
        """
        return _ida_typeinf.tinfo_t_is_arithmetic(self, *args)

    def is_ext_arithmetic(self, *args) -> "bool":
        r"""


        \isreal{is_type_ext_arithmetic}
        """
        return _ida_typeinf.tinfo_t_is_ext_arithmetic(self, *args)

    def is_scalar(self, *args) -> "bool":
        r"""


        Does the type represent a single number?
        """
        return _ida_typeinf.tinfo_t_is_scalar(self, *args)

    def get_ptr_details(self, *args) -> "bool":
        r"""


        Get the pointer info.
        
        get_ptr_details(self, pi) -> bool
            @param pi (C++: ptr_type_data_t  *)
        """
        return _ida_typeinf.tinfo_t_get_ptr_details(self, *args)

    def get_array_details(self, *args) -> "bool":
        r"""


        Get the array specific info.
        
        get_array_details(self, ai) -> bool
            @param ai (C++: array_type_data_t  *)
        """
        return _ida_typeinf.tinfo_t_get_array_details(self, *args)

    def get_enum_details(self, *args) -> "bool":
        r"""


        Get the enum specific info.
        
        get_enum_details(self, ei) -> bool
            @param ei (C++: enum_type_data_t  *)
        """
        return _ida_typeinf.tinfo_t_get_enum_details(self, *args)

    def get_bitfield_details(self, *args) -> "bool":
        r"""


        Get the bitfield specific info.
        
        get_bitfield_details(self, bi) -> bool
            @param bi (C++: bitfield_type_data_t  *)
        """
        return _ida_typeinf.tinfo_t_get_bitfield_details(self, *args)

    def get_udt_details(self, *args) -> "bool":
        r"""


        Get the udt specific info.
        
        get_udt_details(self, udt, gtd=GTD_CALC_LAYOUT) -> bool
            @param udt (C++: udt_type_data_t  *)
            @param gtd (C++: gtd_udt_t)
        """
        return _ida_typeinf.tinfo_t_get_udt_details(self, *args)

    def get_func_details(self, *args) -> "bool":
        r"""


        Get only the function specific info for this 'tinfo_t' .
        
        get_func_details(self, fi, gtd=GTD_CALC_ARGLOCS) -> bool
            @param fi (C++: func_type_data_t  *)
            @param gtd (C++: gtd_func_t)
        """
        return _ida_typeinf.tinfo_t_get_func_details(self, *args)

    def is_funcptr(self, *args) -> "bool":
        r"""


        Is this pointer to a function?
        """
        return _ida_typeinf.tinfo_t_is_funcptr(self, *args)

    def is_shifted_ptr(self, *args) -> "bool":
        r"""


        Is a shifted pointer?
        """
        return _ida_typeinf.tinfo_t_is_shifted_ptr(self, *args)

    def is_varstruct(self, *args) -> "bool":
        r"""


        Is a variable-size structure?
        """
        return _ida_typeinf.tinfo_t_is_varstruct(self, *args)

    def get_ptrarr_objsize(self, *args) -> "int":
        r"""


        'BT_PTR' & 'BT_ARRAY' : get size of pointed object or array element.
        On error returns -1
        """
        return _ida_typeinf.tinfo_t_get_ptrarr_objsize(self, *args)

    def get_ptrarr_object(self, *args) -> "tinfo_t":
        r"""


        'BT_PTR' & 'BT_ARRAY' : get the pointed object or array element. If
        the current type is not a pointer or array, return empty type info.
        """
        return _ida_typeinf.tinfo_t_get_ptrarr_object(self, *args)

    def get_pointed_object(self, *args) -> "tinfo_t":
        r"""


        'BT_PTR' : get type of pointed object. If the current type is not a
        pointer, return empty type info. See also 'get_ptrarr_object()' and
        'remove_pointer()'
        """
        return _ida_typeinf.tinfo_t_get_pointed_object(self, *args)

    def is_pvoid(self, *args) -> "bool":
        r"""


        Is "void *"?. This function does not check the pointer attributes and
        type modifiers.
        """
        return _ida_typeinf.tinfo_t_is_pvoid(self, *args)

    def get_array_element(self, *args) -> "tinfo_t":
        r"""


        'BT_ARRAY' : get type of array element. See also
        'get_ptrarr_object()'
        """
        return _ida_typeinf.tinfo_t_get_array_element(self, *args)

    def get_array_nelems(self, *args) -> "int":
        r"""


        'BT_ARRAY' : get number of elements (-1 means error)
        """
        return _ida_typeinf.tinfo_t_get_array_nelems(self, *args)

    def get_nth_arg(self, *args) -> "tinfo_t":
        r"""


        'BT_FUNC' or 'BT_PTR'  'BT_FUNC' : Get type of n-th arg (-1 means
        return type, see 'get_rettype()' )
        
        get_nth_arg(self, n) -> tinfo_t
            @param n (C++: int)
        """
        return _ida_typeinf.tinfo_t_get_nth_arg(self, *args)

    def get_rettype(self, *args) -> "tinfo_t":
        r"""


        'BT_FUNC' or 'BT_PTR'  'BT_FUNC' : Get the function's return type
        """
        return _ida_typeinf.tinfo_t_get_rettype(self, *args)

    def get_nargs(self, *args) -> "int":
        r"""


        'BT_FUNC' or 'BT_PTR'  'BT_FUNC' : Calculate number of arguments (-1
        - error)
        """
        return _ida_typeinf.tinfo_t_get_nargs(self, *args)

    def is_user_cc(self, *args) -> "bool":
        r"""


        \tinfocc{is_user_cc}
        """
        return _ida_typeinf.tinfo_t_is_user_cc(self, *args)

    def is_vararg_cc(self, *args) -> "bool":
        r"""


        \tinfocc{is_vararg_cc}
        """
        return _ida_typeinf.tinfo_t_is_vararg_cc(self, *args)

    def is_purging_cc(self, *args) -> "bool":
        r"""


        \tinfocc{is_purging_cc}
        """
        return _ida_typeinf.tinfo_t_is_purging_cc(self, *args)

    def calc_purged_bytes(self, *args) -> "int":
        r"""


        'BT_FUNC' : Calculate number of purged bytes
        """
        return _ida_typeinf.tinfo_t_calc_purged_bytes(self, *args)

    def is_high_func(self, *args) -> "bool":
        r"""


        'BT_FUNC' : Is high level type?
        """
        return _ida_typeinf.tinfo_t_is_high_func(self, *args)

    def find_udt_member(self, *args) -> "int":
        r"""


        'BTF_STRUCT' , 'BTF_UNION' : Find a udt member.at the specified
        offset ( 'STRMEM_OFFSET' )with the specified index ( 'STRMEM_INDEX'
        )with the specified type ( 'STRMEM_TYPE' )with the specified name (
        'STRMEM_NAME' )
        
        find_udt_member(self, udm, strmem_flags) -> int
            @param udm (C++: struct  udt_member_t  *)
            @param strmem_flags (C++: int)
            @return: the index of the found member or -1
        """
        return _ida_typeinf.tinfo_t_find_udt_member(self, *args)

    def get_udt_nmembers(self, *args) -> "int":
        r"""


        Get number of udt members. -1-error.
        """
        return _ida_typeinf.tinfo_t_get_udt_nmembers(self, *args)

    def is_empty_udt(self, *args) -> "bool":
        r"""


        Is an empty struct/union? (has no fields)
        """
        return _ida_typeinf.tinfo_t_is_empty_udt(self, *args)

    def is_small_udt(self, *args) -> "bool":
        r"""


        Is a small udt? (can fit a register or a pair of registers)
        """
        return _ida_typeinf.tinfo_t_is_small_udt(self, *args)

    def requires_qualifier(self, *args) -> "bool":
        r"""


        Requires full qualifier? (name is not unique)
        
        requires_qualifier(self, name, offset) -> bool
            @param name: field name (C++: const char *)
            @param offset (C++: uint64)
            @return: if the name is not unique, returns true
        """
        return _ida_typeinf.tinfo_t_requires_qualifier(self, *args)

    def append_covered(self, *args) -> "bool":
        r"""


        Calculate set of covered bytes for the type
        
        append_covered(self, out, offset=0) -> bool
            @param out: pointer to the output buffer. covered bytes will be
                        appended to it. (C++: rangeset_t  *)
            @param offset (C++: uint64)
        """
        return _ida_typeinf.tinfo_t_append_covered(self, *args)

    def calc_gaps(self, *args) -> "bool":
        r"""


        Calculate set of padding bytes for the type
        
        calc_gaps(self, out) -> bool
            @param out: pointer to the output buffer; old buffer contents will be
                        lost. (C++: rangeset_t  *)
        """
        return _ida_typeinf.tinfo_t_calc_gaps(self, *args)

    def is_one_fpval(self, *args) -> "bool":
        r"""


        Floating value or an object consisting of one floating member
        entirely.
        """
        return _ida_typeinf.tinfo_t_is_one_fpval(self, *args)

    def is_sse_type(self, *args) -> "bool":
        r"""


        Is a SSE vector type?
        """
        return _ida_typeinf.tinfo_t_is_sse_type(self, *args)

    def is_anonymous_udt(self, *args) -> "bool":
        r"""


        Is an anonymous struct/union? We assume that types with names are
        anonymous if the name starts with $
        """
        return _ida_typeinf.tinfo_t_is_anonymous_udt(self, *args)

    def is_vftable(self, *args) -> "bool":
        r"""


        Is a vftable type?
        """
        return _ida_typeinf.tinfo_t_is_vftable(self, *args)

    def has_vftable(self, *args) -> "bool":
        r"""


        Has a vftable?
        """
        return _ida_typeinf.tinfo_t_has_vftable(self, *args)

    def get_enum_base_type(self, *args) -> "type_t":
        r"""


        Get enum base type (convert enum to integer type) Returns 'BT_UNK' if
        failed to convert
        """
        return _ida_typeinf.tinfo_t_get_enum_base_type(self, *args)

    def get_onemember_type(self, *args) -> "tinfo_t":
        r"""


        For objects consisting of one member entirely: return type of the
        member.
        """
        return _ida_typeinf.tinfo_t_get_onemember_type(self, *args)

    def calc_score(self, *args) -> "uint32":
        r"""


        Calculate the type score (the higher - the nicer is the type)
        """
        return _ida_typeinf.tinfo_t_calc_score(self, *args)

    def _print(self, *args) -> "bool":
        r"""


        _print(self, name=None, prtype_flags=0, indent=0, cmtindent=0, prefix=None, cmt=None) -> bool
            name: char const *
            prtype_flags: int
            indent: int
            cmtindent: int
            prefix: char const *
            cmt: char const *
        """
        return _ida_typeinf.tinfo_t__print(self, *args)

    def dstr(self, *args) -> "char const *":
        r"""


        Function to facilitate debugging.
        """
        return _ida_typeinf.tinfo_t_dstr(self, *args)

    def get_attrs(self, *args) -> "bool":
        r"""


        Get type attributes (all_attrs: include attributes of referenced
        types, if any)
        
        get_attrs(self, tav, all_attrs=False) -> bool
            @param tav (C++: type_attrs_t  *)
            @param all_attrs (C++: bool)
        """
        return _ida_typeinf.tinfo_t_get_attrs(self, *args)

    def set_attrs(self, *args) -> "bool":
        r"""


        Set type attributes. If necessary, a new typid will be created. this
        function modifies tav! (returns old attributes, if any)
        
        set_attrs(self, tav) -> bool
            @param tav (C++: type_attrs_t  *)
            @return: false: bad attributes
        """
        return _ida_typeinf.tinfo_t_set_attrs(self, *args)

    def set_attr(self, *args) -> "bool":
        r"""


        Set a type attribute. If necessary, a new typid will be created.
        
        set_attr(self, ta, may_overwrite=True) -> bool
            @param ta (C++: const  type_attr_t  &)
            @param may_overwrite (C++: bool)
        """
        return _ida_typeinf.tinfo_t_set_attr(self, *args)

    def del_attrs(self, *args) -> "void":
        r"""


        Del all type attributes. typerefs cannot be modified by this function.
        """
        return _ida_typeinf.tinfo_t_del_attrs(self, *args)

    def del_attr(self, *args) -> "bool":
        r"""


        Del a type attribute. typerefs cannot be modified by this function.
        
        del_attr(self, key, make_copy=True) -> bool
            @param key (C++: const  qstring  &)
            @param make_copy (C++: bool)
        """
        return _ida_typeinf.tinfo_t_del_attr(self, *args)

    def create_simple_type(self, *args) -> "bool":
        r"""


        create_simple_type(self, decl_type) -> bool
            @param decl_type (C++: type_t)
        """
        return _ida_typeinf.tinfo_t_create_simple_type(self, *args)

    def create_ptr(self, *args) -> "bool":
        r"""


        create_ptr(self, p, decl_type=BT_PTR) -> bool
            @param p (C++: const  ptr_type_data_t  &)
            @param decl_type (C++: type_t)
        

        create_ptr(self, tif, bps=0, decl_type=BT_PTR) -> bool
            tif: tinfo_t const &
            bps: uchar
            @param decl_type (C++: type_t)
        """
        return _ida_typeinf.tinfo_t_create_ptr(self, *args)

    def create_array(self, *args) -> "bool":
        r"""


        create_array(self, p, decl_type=BT_ARRAY) -> bool
            @param p (C++: const  array_type_data_t  &)
            @param decl_type (C++: type_t)
        

        create_array(self, tif, nelems=0, base=0, decl_type=BT_ARRAY) -> bool
            tif: tinfo_t const &
            nelems: uint32
            base: uint32
            @param decl_type (C++: type_t)
        """
        return _ida_typeinf.tinfo_t_create_array(self, *args)

    def create_typedef(self, *args) -> "void":
        r"""


        create_typedef(self, p, decl_type=BTF_TYPEDEF, try_ordinal=True) -> bool
            @param p (C++: const  typedef_type_data_t  &)
            @param decl_type (C++: type_t)
            @param try_ordinal (C++: bool)
        

        create_typedef(self, til, name, decl_type=BTF_TYPEDEF, try_ordinal=True)
            til: til_t const *
            name: char const *
            @param decl_type (C++: type_t)
            @param try_ordinal (C++: bool)
        

        create_typedef(self, til, ord, decl_type=BTF_TYPEDEF)
            til: til_t const *
            ord: uint
            @param decl_type (C++: type_t)
        """
        return _ida_typeinf.tinfo_t_create_typedef(self, *args)

    def create_bitfield(self, *args) -> "bool":
        r"""


        create_bitfield(self, p, decl_type=BT_BITFIELD) -> bool
            @param p (C++: const  bitfield_type_data_t  &)
            @param decl_type (C++: type_t)
        

        create_bitfield(self, nbytes, width, is_unsigned=False, decl_type=BT_BITFIELD) -> bool
            nbytes: uchar
            width: uchar
            is_unsigned: bool
            @param decl_type (C++: type_t)
        """
        return _ida_typeinf.tinfo_t_create_bitfield(self, *args)

    def create_udt(self, *args) -> "bool":
        r"""


        create_udt(self, p, decl_type) -> bool
            p: udt_type_data_t &
            decl_type: type_t
        """
        return _ida_typeinf.tinfo_t_create_udt(self, *args)

    def create_enum(self, *args) -> "bool":
        r"""


        create_enum(self, p, decl_type=BTF_ENUM) -> bool
            p: enum_type_data_t &
            decl_type: type_t
        """
        return _ida_typeinf.tinfo_t_create_enum(self, *args)

    def create_func(self, *args) -> "bool":
        r"""


        create_func(self, p, decl_type=BT_FUNC) -> bool
            p: func_type_data_t &
            decl_type: type_t
        """
        return _ida_typeinf.tinfo_t_create_func(self, *args)

    def set_named_type(self, *args) -> "tinfo_code_t":
        r"""


        set_named_type(self, til, name, ntf_flags=0) -> tinfo_code_t
            til: til_t *
            name: char const *
            ntf_flags: int
        """
        return _ida_typeinf.tinfo_t_set_named_type(self, *args)

    def set_symbol_type(self, *args) -> "tinfo_code_t":
        r"""


        set_symbol_type(self, til, name, ntf_flags=0) -> tinfo_code_t
            til: til_t *
            name: char const *
            ntf_flags: int
        """
        return _ida_typeinf.tinfo_t_set_symbol_type(self, *args)

    def set_numbered_type(self, *args) -> "tinfo_code_t":
        r"""


        set_numbered_type(self, til, ord, ntf_flags=0, name=None) -> tinfo_code_t
            til: til_t *
            ord: uint32
            ntf_flags: int
            name: char const *
        """
        return _ida_typeinf.tinfo_t_set_numbered_type(self, *args)

    def create_forward_decl(self, *args) -> "tinfo_code_t":
        r"""


        Create a forward declaration. decl_type: 'BTF_STRUCT' , 'BTF_UNION' ,
        or 'BTF_ENUM'
        
        create_forward_decl(self, til, decl_type, name, ntf_flags=0) -> tinfo_code_t
            @param til (C++: til_t  *)
            @param decl_type (C++: type_t)
            @param name (C++: const char *)
            @param ntf_flags (C++: int)
        """
        return _ida_typeinf.tinfo_t_create_forward_decl(self, *args)

    @staticmethod
    def get_stock(*args) -> "tinfo_t":
        r"""


        get_stock(id) -> tinfo_t
            id: enum stock_type_id_t
        """
        return _ida_typeinf.tinfo_t_get_stock(*args)

    def convert_array_to_ptr(self, *args) -> "bool":
        r"""


        Convert an array into a pointer. type[] => type *
        """
        return _ida_typeinf.tinfo_t_convert_array_to_ptr(self, *args)

    def remove_ptr_or_array(self, *args) -> "bool":
        r"""


        Replace the current type with the ptr obj or array element. This
        function performs one of the following conversions:type[] => typetype*
        => type If the conversion is performed successfully, return true
        """
        return _ida_typeinf.tinfo_t_remove_ptr_or_array(self, *args)

    def change_sign(self, *args) -> "bool":
        r"""


        Change the type sign. Works only for the types that may have sign.
        
        change_sign(self, sign) -> bool
            @param sign (C++: type_sign_t)
        """
        return _ida_typeinf.tinfo_t_change_sign(self, *args)

    def calc_udt_aligns(self, *args) -> "bool":
        r"""


        Calculate the udt alignments using the field offsets/sizes and the
        total udt size This function does not work on typerefs
        
        calc_udt_aligns(self, sudt_flags=0x0004) -> bool
            @param sudt_flags (C++: int)
        """
        return _ida_typeinf.tinfo_t_calc_udt_aligns(self, *args)

    def read_bitfield_value(self, *args) -> "uint64":
        r"""


        read_bitfield_value(self, v, bitoff) -> uint64
            v: uint64
            bitoff: int
        """
        return _ida_typeinf.tinfo_t_read_bitfield_value(self, *args)

    def write_bitfield_value(self, *args) -> "uint64":
        r"""


        write_bitfield_value(self, dst, v, bitoff) -> uint64
            dst: uint64
            v: uint64
            bitoff: int
        """
        return _ida_typeinf.tinfo_t_write_bitfield_value(self, *args)

    def get_modifiers(self, *args) -> "type_t":
        r"""
        get_modifiers(self) -> type_t
        """
        return _ida_typeinf.tinfo_t_get_modifiers(self, *args)

    def set_modifiers(self, *args) -> "void":
        r"""


        set_modifiers(self, mod)
            mod: type_t
        """
        return _ida_typeinf.tinfo_t_set_modifiers(self, *args)

    def set_const(self, *args) -> "void":
        r"""
        set_const(self)
        """
        return _ida_typeinf.tinfo_t_set_const(self, *args)

    def set_volatile(self, *args) -> "void":
        r"""
        set_volatile(self)
        """
        return _ida_typeinf.tinfo_t_set_volatile(self, *args)

    def clr_const(self, *args) -> "void":
        r"""
        clr_const(self)
        """
        return _ida_typeinf.tinfo_t_clr_const(self, *args)

    def clr_volatile(self, *args) -> "void":
        r"""
        clr_volatile(self)
        """
        return _ida_typeinf.tinfo_t_clr_volatile(self, *args)

    def clr_const_volatile(self, *args) -> "void":
        r"""
        clr_const_volatile(self)
        """
        return _ida_typeinf.tinfo_t_clr_const_volatile(self, *args)

    def __eq__(self, *args) -> "bool":
        r"""


        __eq__(self, r) -> bool
            r: tinfo_t const &
        """
        return _ida_typeinf.tinfo_t___eq__(self, *args)

    def __ne__(self, *args) -> "bool":
        r"""


        __ne__(self, r) -> bool
            r: tinfo_t const &
        """
        return _ida_typeinf.tinfo_t___ne__(self, *args)

    def __lt__(self, *args) -> "bool":
        r"""


        __lt__(self, r) -> bool
            r: tinfo_t const &
        """
        return _ida_typeinf.tinfo_t___lt__(self, *args)

    def __gt__(self, *args) -> "bool":
        r"""


        __gt__(self, r) -> bool
            r: tinfo_t const &
        """
        return _ida_typeinf.tinfo_t___gt__(self, *args)

    def __le__(self, *args) -> "bool":
        r"""


        __le__(self, r) -> bool
            r: tinfo_t const &
        """
        return _ida_typeinf.tinfo_t___le__(self, *args)

    def __ge__(self, *args) -> "bool":
        r"""


        __ge__(self, r) -> bool
            r: tinfo_t const &
        """
        return _ida_typeinf.tinfo_t___ge__(self, *args)

    def compare(self, *args) -> "int":
        r"""


        compare(self, r) -> int
            r: tinfo_t const &
        """
        return _ida_typeinf.tinfo_t_compare(self, *args)

    def compare_with(self, *args) -> "bool":
        r"""


        Compare two types, based on given flags (see 'tinfo_t comparison
        flags' )
        
        compare_with(self, r, tcflags=0) -> bool
            @param r (C++: const  tinfo_t  &)
            @param tcflags (C++: int)
        """
        return _ida_typeinf.tinfo_t_compare_with(self, *args)

    def equals_to(self, *args) -> "bool":
        r"""


        equals_to(self, r) -> bool
            @param r (C++: const  tinfo_t  &)
        """
        return _ida_typeinf.tinfo_t_equals_to(self, *args)

    def is_castable_to(self, *args) -> "bool":
        r"""


        is_castable_to(self, target) -> bool
            @param target (C++: const  tinfo_t  &)
        """
        return _ida_typeinf.tinfo_t_is_castable_to(self, *args)

    def is_manually_castable_to(self, *args) -> "bool":
        r"""


        is_manually_castable_to(self, target) -> bool
            @param target (C++: const  tinfo_t  &)
        """
        return _ida_typeinf.tinfo_t_is_manually_castable_to(self, *args)

    def serialize(self, *args) -> "PyObject *":
        r"""


        Serialize 'tinfo_t' object into a type string.
        
        serialize(self, sudt_flags=SUDT_FAST|SUDT_TRUNC) -> PyObject *
            @param sudt_flags (C++: int)
        """
        return _ida_typeinf.tinfo_t_serialize(self, *args)

    def deserialize(self, *args) -> "bool":
        r"""


        Deserialize a type string into a 'tinfo_t' object.
        
        deserialize(self, til, ptype, pfields=None, pfldcmts=None) -> bool
            @param til (C++: const  til_t  *)
            @param ptype (C++: const  type_t  **)
            @param pfields (C++: const  p_list  **)
            @param pfldcmts (C++: const  p_list  **)
        

        deserialize(self, til, type, fields, cmts=None) -> bool
            @param til (C++: const  til_t  *)
            type: type_t const *
            fields: p_list const *
            cmts: p_list const *
        """
        return _ida_typeinf.tinfo_t_deserialize(self, *args)

    def copy(self, *args) -> "tinfo_t":
        r"""
        copy(self) -> tinfo_t
        """
        return _ida_typeinf.tinfo_t_copy(self, *args)

    def __str__(self, *args) -> "qstring":
        r"""
        __str__(self) -> qstring
        """
        return _ida_typeinf.tinfo_t___str__(self, *args)
    __swig_destroy__ = _ida_typeinf.delete_tinfo_t

    def get_attr(self, *args) -> "PyObject *":
        r"""


        Get a type attribute.
        
        get_attr(self, key, all_attrs=True) -> PyObject *
            @param key (C++: const  qstring  &)
            @param all_attrs (C++: bool)
        """
        return _ida_typeinf.tinfo_t_get_attr(self, *args)

# Register tinfo_t in _ida_typeinf:
_ida_typeinf.tinfo_t_swigregister(tinfo_t)
COMP_MASK = cvar.COMP_MASK
COMP_UNK = cvar.COMP_UNK
COMP_MS = cvar.COMP_MS
COMP_BC = cvar.COMP_BC
COMP_WATCOM = cvar.COMP_WATCOM
COMP_GNU = cvar.COMP_GNU
COMP_VISAGE = cvar.COMP_VISAGE
COMP_BP = cvar.COMP_BP
COMP_UNSURE = cvar.COMP_UNSURE
BADSIZE = cvar.BADSIZE
BADORD = cvar.BADORD
FIRST_NONTRIVIAL_TYPID = cvar.FIRST_NONTRIVIAL_TYPID
TYPID_ISREF = cvar.TYPID_ISREF
TYPID_SHIFT = cvar.TYPID_SHIFT

def remove_pointer(*args) -> "tinfo_t":
    r"""


    'BT_PTR' : If the current type is a pointer, return the pointed
    object. If the current type is not a pointer, return the current type.
    See also get_ptrarr_object() and get_pointed_object()
    
    remove_pointer(tif) -> tinfo_t
        @param tif (C++: const  tinfo_t  &)
    """
    return _ida_typeinf.remove_pointer(*args)
STRMEM_MASK = _ida_typeinf.STRMEM_MASK

STRMEM_OFFSET = _ida_typeinf.STRMEM_OFFSET
"""
get member by offset- in: udm->offset - is a member offset in bits
"""

STRMEM_INDEX = _ida_typeinf.STRMEM_INDEX
"""
get member by number- in: udm->offset - is a member number
"""

STRMEM_AUTO = _ida_typeinf.STRMEM_AUTO
"""
get member by offset if struct, or get member by index if union - nb:
union: index is stored in the udm->offset field!nb: struct: offset is
in bytes (not in bits)!
"""

STRMEM_NAME = _ida_typeinf.STRMEM_NAME
"""
get member by name- in: udm->name - the desired member name.
"""

STRMEM_TYPE = _ida_typeinf.STRMEM_TYPE
"""
get member by type. - in: udm->type - the desired member type. member
types are compared with tinfo_t::equals_to()
"""

STRMEM_SIZE = _ida_typeinf.STRMEM_SIZE
"""
get member by size.- in: udm->size - the desired member size.
"""

STRMEM_MINS = _ida_typeinf.STRMEM_MINS
"""
get smallest member by size.
"""

STRMEM_MAXS = _ida_typeinf.STRMEM_MAXS
"""
get biggest member by size.
"""

STRMEM_VFTABLE = _ida_typeinf.STRMEM_VFTABLE
"""
can be combined with 'STRMEM_OFFSET' , 'STRMEM_AUTO' get vftable
instead of the base class
"""

STRMEM_SKIP_EMPTY = _ida_typeinf.STRMEM_SKIP_EMPTY
"""
can be combined with 'STRMEM_OFFSET' , 'STRMEM_AUTO' skip empty
members (i.e. having zero size) only last empty member can be returned
"""

STRMEM_CASTABLE_TO = _ida_typeinf.STRMEM_CASTABLE_TO
"""
can be combined with 'STRMEM_TYPE' : member type must be castable to
the specified type
"""

STRMEM_ANON = _ida_typeinf.STRMEM_ANON
"""
can be combined with 'STRMEM_NAME' : look inside anonymous members
too.
"""


def tinfo_t_get_stock(*args) -> "tinfo_t":
    r"""


    tinfo_t_get_stock(id) -> tinfo_t
        id: enum stock_type_id_t
    """
    return _ida_typeinf.tinfo_t_get_stock(*args)
TCMP_EQUAL = _ida_typeinf.TCMP_EQUAL
"""
are types equal?
"""

TCMP_IGNMODS = _ida_typeinf.TCMP_IGNMODS
"""
ignore const/volatile modifiers
"""

TCMP_AUTOCAST = _ida_typeinf.TCMP_AUTOCAST
"""
can t1 be cast into t2 automatically?
"""

TCMP_MANCAST = _ida_typeinf.TCMP_MANCAST
"""
can t1 be cast into t2 manually?
"""

TCMP_CALL = _ida_typeinf.TCMP_CALL
"""
can t1 be called with t2 type?
"""

TCMP_DELPTR = _ida_typeinf.TCMP_DELPTR
"""
remove pointer from types before comparing
"""

TCMP_DECL = _ida_typeinf.TCMP_DECL
"""
compare declarations without resolving them
"""

TCMP_ANYBASE = _ida_typeinf.TCMP_ANYBASE
"""
accept any base class when casting
"""

TCMP_SKIPTHIS = _ida_typeinf.TCMP_SKIPTHIS
"""
skip the first function argument in comparison
"""


class simd_info_t(object):
    r"""
    Proxy of C++ simd_info_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = property(_ida_typeinf.simd_info_t_name_get, _ida_typeinf.simd_info_t_name_set)
    tif = property(_ida_typeinf.simd_info_t_tif_get, _ida_typeinf.simd_info_t_tif_set)
    size = property(_ida_typeinf.simd_info_t_size_get, _ida_typeinf.simd_info_t_size_set)
    memtype = property(_ida_typeinf.simd_info_t_memtype_get, _ida_typeinf.simd_info_t_memtype_set)

    def __init__(self, *args):
        r"""


        __init__(self, nm=None, sz=0, memt=BTF_UNK) -> simd_info_t
            nm: char const *
            sz: uint16
            memt: type_t
        """
        _ida_typeinf.simd_info_t_swiginit(self, _ida_typeinf.new_simd_info_t(*args))

    def match_pattern(self, *args) -> "bool":
        r"""


        match_pattern(self, pattern) -> bool
            @param pattern (C++: const  simd_info_t  *)
        """
        return _ida_typeinf.simd_info_t_match_pattern(self, *args)
    __swig_destroy__ = _ida_typeinf.delete_simd_info_t

# Register simd_info_t in _ida_typeinf:
_ida_typeinf.simd_info_t_swigregister(simd_info_t)


def guess_func_cc(*args) -> "cm_t":
    r"""


    Use 'func_type_data_t::guess_cc()'
    
    guess_func_cc(fti, npurged, cc_flags) -> cm_t
        @param fti (C++: const  func_type_data_t  &)
        @param npurged (C++: int)
        @param cc_flags (C++: int)
    """
    return _ida_typeinf.guess_func_cc(*args)

def dump_func_type_data(*args) -> "qstring *":
    r"""


    Use 'func_type_data_t::dump()'
    
    dump_func_type_data(fti, praloc_bits) -> str
        @param fti (C++: const  func_type_data_t  &)
        @param praloc_bits (C++: int)
    """
    return _ida_typeinf.dump_func_type_data(*args)
class ptr_type_data_t(object):
    r"""
    Proxy of C++ ptr_type_data_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    obj_type = property(_ida_typeinf.ptr_type_data_t_obj_type_get, _ida_typeinf.ptr_type_data_t_obj_type_set)
    closure = property(_ida_typeinf.ptr_type_data_t_closure_get, _ida_typeinf.ptr_type_data_t_closure_set)
    based_ptr_size = property(_ida_typeinf.ptr_type_data_t_based_ptr_size_get, _ida_typeinf.ptr_type_data_t_based_ptr_size_set)
    taptr_bits = property(_ida_typeinf.ptr_type_data_t_taptr_bits_get, _ida_typeinf.ptr_type_data_t_taptr_bits_set)
    parent = property(_ida_typeinf.ptr_type_data_t_parent_get, _ida_typeinf.ptr_type_data_t_parent_set)
    delta = property(_ida_typeinf.ptr_type_data_t_delta_get, _ida_typeinf.ptr_type_data_t_delta_set)

    def __init__(self, *args):
        r"""


        __init__(self, c=tinfo_t(), bps=0, p=tinfo_t(), d=0) -> ptr_type_data_t
            c: tinfo_t
            bps: uchar
            p: tinfo_t
            d: int32
        """
        _ida_typeinf.ptr_type_data_t_swiginit(self, _ida_typeinf.new_ptr_type_data_t(*args))

    def swap(self, *args) -> "void":
        r"""


        Set this = r and r = this.
        
        swap(self, r)
            @param r (C++: ptr_type_data_t  &)
        """
        return _ida_typeinf.ptr_type_data_t_swap(self, *args)

    def __eq__(self, *args) -> "bool":
        r"""


        __eq__(self, r) -> bool
            r: ptr_type_data_t const &
        """
        return _ida_typeinf.ptr_type_data_t___eq__(self, *args)

    def __ne__(self, *args) -> "bool":
        r"""


        __ne__(self, r) -> bool
            r: ptr_type_data_t const &
        """
        return _ida_typeinf.ptr_type_data_t___ne__(self, *args)

    def is_code_ptr(self, *args) -> "bool":
        r"""


        Are we pointing to code?
        """
        return _ida_typeinf.ptr_type_data_t_is_code_ptr(self, *args)

    def is_shifted(self, *args) -> "bool":
        r"""
        is_shifted(self) -> bool
        """
        return _ida_typeinf.ptr_type_data_t_is_shifted(self, *args)
    __swig_destroy__ = _ida_typeinf.delete_ptr_type_data_t

# Register ptr_type_data_t in _ida_typeinf:
_ida_typeinf.ptr_type_data_t_swigregister(ptr_type_data_t)

class array_type_data_t(object):
    r"""
    Proxy of C++ array_type_data_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    elem_type = property(_ida_typeinf.array_type_data_t_elem_type_get, _ida_typeinf.array_type_data_t_elem_type_set)
    base = property(_ida_typeinf.array_type_data_t_base_get, _ida_typeinf.array_type_data_t_base_set)
    nelems = property(_ida_typeinf.array_type_data_t_nelems_get, _ida_typeinf.array_type_data_t_nelems_set)

    def __init__(self, *args):
        r"""


        __init__(self, b=0, n=0) -> array_type_data_t
            b: size_t
            n: size_t
        """
        _ida_typeinf.array_type_data_t_swiginit(self, _ida_typeinf.new_array_type_data_t(*args))

    def swap(self, *args) -> "void":
        r"""


        set this = r and r = this
        
        swap(self, r)
            @param r (C++: array_type_data_t  &)
        """
        return _ida_typeinf.array_type_data_t_swap(self, *args)
    __swig_destroy__ = _ida_typeinf.delete_array_type_data_t

# Register array_type_data_t in _ida_typeinf:
_ida_typeinf.array_type_data_t_swigregister(array_type_data_t)

class funcarg_t(object):
    r"""
    Proxy of C++ funcarg_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    argloc = property(_ida_typeinf.funcarg_t_argloc_get, _ida_typeinf.funcarg_t_argloc_set)
    name = property(_ida_typeinf.funcarg_t_name_get, _ida_typeinf.funcarg_t_name_set)
    cmt = property(_ida_typeinf.funcarg_t_cmt_get, _ida_typeinf.funcarg_t_cmt_set)
    type = property(_ida_typeinf.funcarg_t_type_get, _ida_typeinf.funcarg_t_type_set)
    flags = property(_ida_typeinf.funcarg_t_flags_get, _ida_typeinf.funcarg_t_flags_set)

    def __init__(self, *args):
        r"""
        __init__(self) -> funcarg_t
        """
        _ida_typeinf.funcarg_t_swiginit(self, _ida_typeinf.new_funcarg_t(*args))

    def __eq__(self, *args) -> "bool":
        r"""


        __eq__(self, r) -> bool
            r: funcarg_t const &
        """
        return _ida_typeinf.funcarg_t___eq__(self, *args)

    def __ne__(self, *args) -> "bool":
        r"""


        __ne__(self, r) -> bool
            r: funcarg_t const &
        """
        return _ida_typeinf.funcarg_t___ne__(self, *args)
    __swig_destroy__ = _ida_typeinf.delete_funcarg_t

# Register funcarg_t in _ida_typeinf:
_ida_typeinf.funcarg_t_swigregister(funcarg_t)
FAI_HIDDEN = _ida_typeinf.FAI_HIDDEN
"""
hidden argument
"""

FAI_RETPTR = _ida_typeinf.FAI_RETPTR
"""
pointer to return value. implies hidden
"""

FAI_STRUCT = _ida_typeinf.FAI_STRUCT
"""
was initially a structure
"""

FAI_ARRAY = _ida_typeinf.FAI_ARRAY
"""
was initially an array see "__org_typedef" or "__org_arrdim" type
attributes to determine the original type
"""

TA_ORG_TYPEDEF = _ida_typeinf.TA_ORG_TYPEDEF
"""
the original typedef name (simple string)
"""

TA_ORG_ARRDIM = _ida_typeinf.TA_ORG_ARRDIM
"""
the original array dimension (pack_dd)
"""

TA_FORMAT = _ida_typeinf.TA_FORMAT
"""
info about the 'format' argument 3 times pack_dd: 'format_functype_t'
, argument number of 'format', argument number of '...'
"""


class func_type_data_t(funcargvec_t):
    r"""
    Proxy of C++ func_type_data_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    flags = property(_ida_typeinf.func_type_data_t_flags_get, _ida_typeinf.func_type_data_t_flags_set)
    rettype = property(_ida_typeinf.func_type_data_t_rettype_get, _ida_typeinf.func_type_data_t_rettype_set)
    retloc = property(_ida_typeinf.func_type_data_t_retloc_get, _ida_typeinf.func_type_data_t_retloc_set)
    stkargs = property(_ida_typeinf.func_type_data_t_stkargs_get, _ida_typeinf.func_type_data_t_stkargs_set)
    spoiled = property(_ida_typeinf.func_type_data_t_spoiled_get, _ida_typeinf.func_type_data_t_spoiled_set)
    cc = property(_ida_typeinf.func_type_data_t_cc_get, _ida_typeinf.func_type_data_t_cc_set)

    def __init__(self, *args):
        r"""
        __init__(self) -> func_type_data_t
        """
        _ida_typeinf.func_type_data_t_swiginit(self, _ida_typeinf.new_func_type_data_t(*args))

    def swap(self, *args) -> "void":
        r"""


        swap(self, r)
            @param r (C++: func_type_data_t  &)
        """
        return _ida_typeinf.func_type_data_t_swap(self, *args)

    def is_high(self, *args) -> "bool":
        r"""
        is_high(self) -> bool
        """
        return _ida_typeinf.func_type_data_t_is_high(self, *args)

    def is_noret(self, *args) -> "bool":
        r"""
        is_noret(self) -> bool
        """
        return _ida_typeinf.func_type_data_t_is_noret(self, *args)

    def is_pure(self, *args) -> "bool":
        r"""
        is_pure(self) -> bool
        """
        return _ida_typeinf.func_type_data_t_is_pure(self, *args)

    def get_call_method(self, *args) -> "int":
        r"""
        get_call_method(self) -> int
        """
        return _ida_typeinf.func_type_data_t_get_call_method(self, *args)

    def is_vararg_cc(self, *args) -> "bool":
        r"""
        is_vararg_cc(self) -> bool
        """
        return _ida_typeinf.func_type_data_t_is_vararg_cc(self, *args)

    def guess_cc(self, *args) -> "cm_t":
        r"""


        Guess function calling convention use the following info: argument
        locations and 'stkargs'
        
        guess_cc(self, purged, cc_flags) -> cm_t
            @param purged (C++: int)
            @param cc_flags (C++: int)
        """
        return _ida_typeinf.func_type_data_t_guess_cc(self, *args)

    def dump(self, *args) -> "bool":
        r"""


        Dump information that is not always visible in the function prototype.
        (argument locations, return location, total stkarg size)
        
        dump(self, praloc_bits=0x02) -> bool
            @param praloc_bits (C++: int)
        """
        return _ida_typeinf.func_type_data_t_dump(self, *args)
    __swig_destroy__ = _ida_typeinf.delete_func_type_data_t

# Register func_type_data_t in _ida_typeinf:
_ida_typeinf.func_type_data_t_swigregister(func_type_data_t)
FTI_SPOILED = _ida_typeinf.FTI_SPOILED
"""
information about spoiled registers is present
"""

FTI_NORET = _ida_typeinf.FTI_NORET
"""
noreturn
"""

FTI_PURE = _ida_typeinf.FTI_PURE
"""
__pure
"""

FTI_HIGH = _ida_typeinf.FTI_HIGH
"""
high level prototype (with possibly hidden args)
"""

FTI_STATIC = _ida_typeinf.FTI_STATIC
"""
static
"""

FTI_VIRTUAL = _ida_typeinf.FTI_VIRTUAL
"""
virtual
"""

FTI_CALLTYPE = _ida_typeinf.FTI_CALLTYPE
"""
mask for FTI_*CALL
"""

FTI_DEFCALL = _ida_typeinf.FTI_DEFCALL
"""
default call
"""

FTI_NEARCALL = _ida_typeinf.FTI_NEARCALL
"""
near call
"""

FTI_FARCALL = _ida_typeinf.FTI_FARCALL
"""
far call
"""

FTI_INTCALL = _ida_typeinf.FTI_INTCALL
"""
interrupt call
"""

FTI_ARGLOCS = _ida_typeinf.FTI_ARGLOCS
"""
(stkargs and retloc too)

info about argument locations has been calculated
"""

FTI_ALL = _ida_typeinf.FTI_ALL
"""
all defined bits
"""

CC_CDECL_OK = _ida_typeinf.CC_CDECL_OK
"""
can use __cdecl calling convention?
"""

CC_ALLOW_ARGPERM = _ida_typeinf.CC_ALLOW_ARGPERM
"""
disregard argument order?
"""

CC_ALLOW_REGHOLES = _ida_typeinf.CC_ALLOW_REGHOLES
"""
allow holes in register argument list?
"""

CC_HAS_ELLIPSIS = _ida_typeinf.CC_HAS_ELLIPSIS
"""
function has a variable list of arguments?
"""


FMTFUNC_PRINTF = _ida_typeinf.FMTFUNC_PRINTF

FMTFUNC_SCANF = _ida_typeinf.FMTFUNC_SCANF

FMTFUNC_STRFTIME = _ida_typeinf.FMTFUNC_STRFTIME

FMTFUNC_STRFMON = _ida_typeinf.FMTFUNC_STRFMON

class enum_member_t(object):
    r"""
    Proxy of C++ enum_member_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = property(_ida_typeinf.enum_member_t_name_get, _ida_typeinf.enum_member_t_name_set)
    cmt = property(_ida_typeinf.enum_member_t_cmt_get, _ida_typeinf.enum_member_t_cmt_set)
    value = property(_ida_typeinf.enum_member_t_value_get, _ida_typeinf.enum_member_t_value_set)

    def __eq__(self, *args) -> "bool":
        r"""


        __eq__(self, r) -> bool
            r: enum_member_t const &
        """
        return _ida_typeinf.enum_member_t___eq__(self, *args)

    def __ne__(self, *args) -> "bool":
        r"""


        __ne__(self, r) -> bool
            r: enum_member_t const &
        """
        return _ida_typeinf.enum_member_t___ne__(self, *args)

    def swap(self, *args) -> "void":
        r"""


        swap(self, r)
            @param r (C++: enum_member_t  &)
        """
        return _ida_typeinf.enum_member_t_swap(self, *args)

    def __init__(self, *args):
        r"""
        __init__(self) -> enum_member_t
        """
        _ida_typeinf.enum_member_t_swiginit(self, _ida_typeinf.new_enum_member_t(*args))
    __swig_destroy__ = _ida_typeinf.delete_enum_member_t

# Register enum_member_t in _ida_typeinf:
_ida_typeinf.enum_member_t_swigregister(enum_member_t)

class enum_type_data_t(enum_member_vec_t):
    r"""
    Proxy of C++ enum_type_data_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    group_sizes = property(_ida_typeinf.enum_type_data_t_group_sizes_get, _ida_typeinf.enum_type_data_t_group_sizes_set)
    taenum_bits = property(_ida_typeinf.enum_type_data_t_taenum_bits_get, _ida_typeinf.enum_type_data_t_taenum_bits_set)
    bte = property(_ida_typeinf.enum_type_data_t_bte_get, _ida_typeinf.enum_type_data_t_bte_set)

    def __init__(self, *args):
        r"""


        __init__(self, _bte=BTE_ALWAYS|BTE_HEX) -> enum_type_data_t
            _bte: bte_t
        """
        _ida_typeinf.enum_type_data_t_swiginit(self, _ida_typeinf.new_enum_type_data_t(*args))

    def is_64bit(self, *args) -> "bool":
        r"""
        is_64bit(self) -> bool
        """
        return _ida_typeinf.enum_type_data_t_is_64bit(self, *args)

    def is_hex(self, *args) -> "bool":
        r"""
        is_hex(self) -> bool
        """
        return _ida_typeinf.enum_type_data_t_is_hex(self, *args)

    def is_char(self, *args) -> "bool":
        r"""
        is_char(self) -> bool
        """
        return _ida_typeinf.enum_type_data_t_is_char(self, *args)

    def is_sdec(self, *args) -> "bool":
        r"""
        is_sdec(self) -> bool
        """
        return _ida_typeinf.enum_type_data_t_is_sdec(self, *args)

    def is_udec(self, *args) -> "bool":
        r"""
        is_udec(self) -> bool
        """
        return _ida_typeinf.enum_type_data_t_is_udec(self, *args)

    def calc_nbytes(self, *args) -> "int":
        r"""
        calc_nbytes(self) -> int
        """
        return _ida_typeinf.enum_type_data_t_calc_nbytes(self, *args)

    def calc_mask(self, *args) -> "uint64":
        r"""
        calc_mask(self) -> uint64
        """
        return _ida_typeinf.enum_type_data_t_calc_mask(self, *args)

    def swap(self, *args) -> "void":
        r"""


        swap two instances
        
        swap(self, r)
            @param r (C++: enum_type_data_t  &)
        """
        return _ida_typeinf.enum_type_data_t_swap(self, *args)
    __swig_destroy__ = _ida_typeinf.delete_enum_type_data_t

# Register enum_type_data_t in _ida_typeinf:
_ida_typeinf.enum_type_data_t_swigregister(enum_type_data_t)

class typedef_type_data_t(object):
    r"""
    Proxy of C++ typedef_type_data_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    til = property(_ida_typeinf.typedef_type_data_t_til_get, _ida_typeinf.typedef_type_data_t_til_set)
    is_ordref = property(_ida_typeinf.typedef_type_data_t_is_ordref_get, _ida_typeinf.typedef_type_data_t_is_ordref_set)
    resolve = property(_ida_typeinf.typedef_type_data_t_resolve_get, _ida_typeinf.typedef_type_data_t_resolve_set)

    def __init__(self, *args):
        r"""


        __init__(self, _til, _name, _resolve=False) -> typedef_type_data_t
            _til: til_t const *
            _name: char const *
            _resolve: bool
        

        __init__(self, _til, ord, _resolve=False) -> typedef_type_data_t
            _til: til_t const *
            ord: uint32
            _resolve: bool
        """
        _ida_typeinf.typedef_type_data_t_swiginit(self, _ida_typeinf.new_typedef_type_data_t(*args))

    def swap(self, *args) -> "void":
        r"""


        swap(self, r)
            @param r (C++: typedef_type_data_t  &)
        """
        return _ida_typeinf.typedef_type_data_t_swap(self, *args)
    __swig_destroy__ = _ida_typeinf.delete_typedef_type_data_t

# Register typedef_type_data_t in _ida_typeinf:
_ida_typeinf.typedef_type_data_t_swigregister(typedef_type_data_t)

class udt_member_t(object):
    r"""
    Proxy of C++ udt_member_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    offset = property(_ida_typeinf.udt_member_t_offset_get, _ida_typeinf.udt_member_t_offset_set)
    size = property(_ida_typeinf.udt_member_t_size_get, _ida_typeinf.udt_member_t_size_set)
    name = property(_ida_typeinf.udt_member_t_name_get, _ida_typeinf.udt_member_t_name_set)
    cmt = property(_ida_typeinf.udt_member_t_cmt_get, _ida_typeinf.udt_member_t_cmt_set)
    type = property(_ida_typeinf.udt_member_t_type_get, _ida_typeinf.udt_member_t_type_set)
    effalign = property(_ida_typeinf.udt_member_t_effalign_get, _ida_typeinf.udt_member_t_effalign_set)
    tafld_bits = property(_ida_typeinf.udt_member_t_tafld_bits_get, _ida_typeinf.udt_member_t_tafld_bits_set)
    fda = property(_ida_typeinf.udt_member_t_fda_get, _ida_typeinf.udt_member_t_fda_set)

    def __init__(self, *args):
        r"""
        __init__(self) -> udt_member_t
        """
        _ida_typeinf.udt_member_t_swiginit(self, _ida_typeinf.new_udt_member_t(*args))

    def is_bitfield(self, *args) -> "bool":
        r"""
        is_bitfield(self) -> bool
        """
        return _ida_typeinf.udt_member_t_is_bitfield(self, *args)

    def is_zero_bitfield(self, *args) -> "bool":
        r"""
        is_zero_bitfield(self) -> bool
        """
        return _ida_typeinf.udt_member_t_is_zero_bitfield(self, *args)

    def is_unaligned(self, *args) -> "bool":
        r"""
        is_unaligned(self) -> bool
        """
        return _ida_typeinf.udt_member_t_is_unaligned(self, *args)

    def is_baseclass(self, *args) -> "bool":
        r"""
        is_baseclass(self) -> bool
        """
        return _ida_typeinf.udt_member_t_is_baseclass(self, *args)

    def is_virtbase(self, *args) -> "bool":
        r"""
        is_virtbase(self) -> bool
        """
        return _ida_typeinf.udt_member_t_is_virtbase(self, *args)

    def is_vftable(self, *args) -> "bool":
        r"""
        is_vftable(self) -> bool
        """
        return _ida_typeinf.udt_member_t_is_vftable(self, *args)

    def set_unaligned(self, *args) -> "void":
        r"""
        set_unaligned(self)
        """
        return _ida_typeinf.udt_member_t_set_unaligned(self, *args)

    def set_baseclass(self, *args) -> "void":
        r"""
        set_baseclass(self)
        """
        return _ida_typeinf.udt_member_t_set_baseclass(self, *args)

    def set_virtbase(self, *args) -> "void":
        r"""
        set_virtbase(self)
        """
        return _ida_typeinf.udt_member_t_set_virtbase(self, *args)

    def set_vftable(self, *args) -> "void":
        r"""
        set_vftable(self)
        """
        return _ida_typeinf.udt_member_t_set_vftable(self, *args)

    def clr_unaligned(self, *args) -> "void":
        r"""
        clr_unaligned(self)
        """
        return _ida_typeinf.udt_member_t_clr_unaligned(self, *args)

    def clr_baseclass(self, *args) -> "void":
        r"""
        clr_baseclass(self)
        """
        return _ida_typeinf.udt_member_t_clr_baseclass(self, *args)

    def clr_virtbase(self, *args) -> "void":
        r"""
        clr_virtbase(self)
        """
        return _ida_typeinf.udt_member_t_clr_virtbase(self, *args)

    def clr_vftable(self, *args) -> "void":
        r"""
        clr_vftable(self)
        """
        return _ida_typeinf.udt_member_t_clr_vftable(self, *args)

    def begin(self, *args) -> "uint64":
        r"""
        begin(self) -> uint64
        """
        return _ida_typeinf.udt_member_t_begin(self, *args)

    def end(self, *args) -> "uint64":
        r"""
        end(self) -> uint64
        """
        return _ida_typeinf.udt_member_t_end(self, *args)

    def __lt__(self, *args) -> "bool":
        r"""


        __lt__(self, r) -> bool
            r: udt_member_t const &
        """
        return _ida_typeinf.udt_member_t___lt__(self, *args)

    def __eq__(self, *args) -> "bool":
        r"""


        __eq__(self, r) -> bool
            r: udt_member_t const &
        """
        return _ida_typeinf.udt_member_t___eq__(self, *args)

    def __ne__(self, *args) -> "bool":
        r"""


        __ne__(self, r) -> bool
            r: udt_member_t const &
        """
        return _ida_typeinf.udt_member_t___ne__(self, *args)

    def swap(self, *args) -> "void":
        r"""


        swap(self, r)
            @param r (C++: udt_member_t  &)
        """
        return _ida_typeinf.udt_member_t_swap(self, *args)

    def is_anonymous_udm(self, *args) -> "bool":
        r"""
        is_anonymous_udm(self) -> bool
        """
        return _ida_typeinf.udt_member_t_is_anonymous_udm(self, *args)
    __swig_destroy__ = _ida_typeinf.delete_udt_member_t

# Register udt_member_t in _ida_typeinf:
_ida_typeinf.udt_member_t_swigregister(udt_member_t)

class udt_type_data_t(udtmembervec_t):
    r"""
    Proxy of C++ udt_type_data_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    total_size = property(_ida_typeinf.udt_type_data_t_total_size_get, _ida_typeinf.udt_type_data_t_total_size_set)
    unpadded_size = property(_ida_typeinf.udt_type_data_t_unpadded_size_get, _ida_typeinf.udt_type_data_t_unpadded_size_set)
    effalign = property(_ida_typeinf.udt_type_data_t_effalign_get, _ida_typeinf.udt_type_data_t_effalign_set)
    taudt_bits = property(_ida_typeinf.udt_type_data_t_taudt_bits_get, _ida_typeinf.udt_type_data_t_taudt_bits_set)
    sda = property(_ida_typeinf.udt_type_data_t_sda_get, _ida_typeinf.udt_type_data_t_sda_set)
    pack = property(_ida_typeinf.udt_type_data_t_pack_get, _ida_typeinf.udt_type_data_t_pack_set)
    is_union = property(_ida_typeinf.udt_type_data_t_is_union_get, _ida_typeinf.udt_type_data_t_is_union_set)

    def __init__(self, *args):
        r"""
        __init__(self) -> udt_type_data_t
        """
        _ida_typeinf.udt_type_data_t_swiginit(self, _ida_typeinf.new_udt_type_data_t(*args))

    def swap(self, *args) -> "void":
        r"""


        swap(self, r)
            @param r (C++: udt_type_data_t  &)
        """
        return _ida_typeinf.udt_type_data_t_swap(self, *args)

    def is_unaligned(self, *args) -> "bool":
        r"""
        is_unaligned(self) -> bool
        """
        return _ida_typeinf.udt_type_data_t_is_unaligned(self, *args)

    def is_msstruct(self, *args) -> "bool":
        r"""
        is_msstruct(self) -> bool
        """
        return _ida_typeinf.udt_type_data_t_is_msstruct(self, *args)

    def is_cppobj(self, *args) -> "bool":
        r"""
        is_cppobj(self) -> bool
        """
        return _ida_typeinf.udt_type_data_t_is_cppobj(self, *args)

    def is_vftable(self, *args) -> "bool":
        r"""
        is_vftable(self) -> bool
        """
        return _ida_typeinf.udt_type_data_t_is_vftable(self, *args)

    def is_last_baseclass(self, *args) -> "bool":
        r"""


        is_last_baseclass(self, idx) -> bool
            @param idx (C++: size_t)
        """
        return _ida_typeinf.udt_type_data_t_is_last_baseclass(self, *args)
    __swig_destroy__ = _ida_typeinf.delete_udt_type_data_t

# Register udt_type_data_t in _ida_typeinf:
_ida_typeinf.udt_type_data_t_swigregister(udt_type_data_t)

VTBL_SUFFIX = _ida_typeinf.VTBL_SUFFIX

VTBL_MEMNAME = _ida_typeinf.VTBL_MEMNAME

class bitfield_type_data_t(object):
    r"""
    Proxy of C++ bitfield_type_data_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    nbytes = property(_ida_typeinf.bitfield_type_data_t_nbytes_get, _ida_typeinf.bitfield_type_data_t_nbytes_set)
    width = property(_ida_typeinf.bitfield_type_data_t_width_get, _ida_typeinf.bitfield_type_data_t_width_set)
    is_unsigned = property(_ida_typeinf.bitfield_type_data_t_is_unsigned_get, _ida_typeinf.bitfield_type_data_t_is_unsigned_set)

    def __init__(self, *args):
        r"""


        __init__(self, _nbytes=0, _width=0, _is_unsigned=False) -> bitfield_type_data_t
            _nbytes: uchar
            _width: uchar
            _is_unsigned: bool
        """
        _ida_typeinf.bitfield_type_data_t_swiginit(self, _ida_typeinf.new_bitfield_type_data_t(*args))

    def __eq__(self, *args) -> "bool":
        r"""


        __eq__(self, r) -> bool
            r: bitfield_type_data_t const &
        """
        return _ida_typeinf.bitfield_type_data_t___eq__(self, *args)

    def __ne__(self, *args) -> "bool":
        r"""


        __ne__(self, r) -> bool
            r: bitfield_type_data_t const &
        """
        return _ida_typeinf.bitfield_type_data_t___ne__(self, *args)

    def __lt__(self, *args) -> "bool":
        r"""


        __lt__(self, r) -> bool
            r: bitfield_type_data_t const &
        """
        return _ida_typeinf.bitfield_type_data_t___lt__(self, *args)

    def __gt__(self, *args) -> "bool":
        r"""


        __gt__(self, r) -> bool
            r: bitfield_type_data_t const &
        """
        return _ida_typeinf.bitfield_type_data_t___gt__(self, *args)

    def __le__(self, *args) -> "bool":
        r"""


        __le__(self, r) -> bool
            r: bitfield_type_data_t const &
        """
        return _ida_typeinf.bitfield_type_data_t___le__(self, *args)

    def __ge__(self, *args) -> "bool":
        r"""


        __ge__(self, r) -> bool
            r: bitfield_type_data_t const &
        """
        return _ida_typeinf.bitfield_type_data_t___ge__(self, *args)

    def compare(self, *args) -> "int":
        r"""


        compare(self, r) -> int
            r: bitfield_type_data_t const &
        """
        return _ida_typeinf.bitfield_type_data_t_compare(self, *args)

    def swap(self, *args) -> "void":
        r"""


        swap(self, r)
            @param r (C++: bitfield_type_data_t  &)
        """
        return _ida_typeinf.bitfield_type_data_t_swap(self, *args)
    __swig_destroy__ = _ida_typeinf.delete_bitfield_type_data_t

# Register bitfield_type_data_t in _ida_typeinf:
_ida_typeinf.bitfield_type_data_t_swigregister(bitfield_type_data_t)

TPOS_LNNUM = _ida_typeinf.TPOS_LNNUM

class type_mods_t(object):
    r"""
    Proxy of C++ type_mods_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    type = property(_ida_typeinf.type_mods_t_type_get, _ida_typeinf.type_mods_t_type_set)
    name = property(_ida_typeinf.type_mods_t_name_get, _ida_typeinf.type_mods_t_name_set)
    cmt = property(_ida_typeinf.type_mods_t_cmt_get, _ida_typeinf.type_mods_t_cmt_set)
    flags = property(_ida_typeinf.type_mods_t_flags_get, _ida_typeinf.type_mods_t_flags_set)

    def __init__(self, *args):
        r"""
        __init__(self) -> type_mods_t
        """
        _ida_typeinf.type_mods_t_swiginit(self, _ida_typeinf.new_type_mods_t(*args))

    def clear(self, *args) -> "void":
        r"""
        clear(self)
        """
        return _ida_typeinf.type_mods_t_clear(self, *args)

    def set_new_type(self, *args) -> "void":
        r"""


        The visit_type() function may optionally save the modified type info.
        Use the following functions for that. The new name and comment will be
        applied only if the current tinfo element has storage for them.
        
        set_new_type(self, t)
            @param t (C++: const  tinfo_t  &)
        """
        return _ida_typeinf.type_mods_t_set_new_type(self, *args)

    def set_new_name(self, *args) -> "void":
        r"""


        set_new_name(self, n)
            @param n (C++: const  qstring  &)
        """
        return _ida_typeinf.type_mods_t_set_new_name(self, *args)

    def set_new_cmt(self, *args) -> "void":
        r"""


        set_new_cmt(self, c)
            @param c (C++: const  qstring  &)
        """
        return _ida_typeinf.type_mods_t_set_new_cmt(self, *args)

    def has_type(self, *args) -> "bool":
        r"""
        has_type(self) -> bool
        """
        return _ida_typeinf.type_mods_t_has_type(self, *args)

    def has_name(self, *args) -> "bool":
        r"""
        has_name(self) -> bool
        """
        return _ida_typeinf.type_mods_t_has_name(self, *args)

    def has_cmt(self, *args) -> "bool":
        r"""
        has_cmt(self) -> bool
        """
        return _ida_typeinf.type_mods_t_has_cmt(self, *args)

    def has_info(self, *args) -> "bool":
        r"""
        has_info(self) -> bool
        """
        return _ida_typeinf.type_mods_t_has_info(self, *args)
    __swig_destroy__ = _ida_typeinf.delete_type_mods_t

# Register type_mods_t in _ida_typeinf:
_ida_typeinf.type_mods_t_swigregister(type_mods_t)
TVIS_TYPE = _ida_typeinf.TVIS_TYPE
"""
new type info is present
"""

TVIS_NAME = _ida_typeinf.TVIS_NAME
"""
new name is present
"""

TVIS_CMT = _ida_typeinf.TVIS_CMT
"""
new comment is present
"""


class tinfo_visitor_t(object):
    r"""
    Proxy of C++ tinfo_visitor_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    state = property(_ida_typeinf.tinfo_visitor_t_state_get, _ida_typeinf.tinfo_visitor_t_state_set)

    def __init__(self, *args):
        r"""


        __init__(self, s=0) -> tinfo_visitor_t
            s: int
        """
        if self.__class__ == tinfo_visitor_t:
            _self = None
        else:
            _self = self
        _ida_typeinf.tinfo_visitor_t_swiginit(self, _ida_typeinf.new_tinfo_visitor_t(_self, *args))

    def visit_type(self, *args) -> "int":
        r"""


        Visit a subtype. this function must be implemented in the derived
        class. it may optionally fill out with the new type info. this can be
        used to modify types (in this case the 'out' argument of 'apply_to()'
        may not be NULL) return 0 to continue the traversal. return !=0 to
        stop the traversal.
        
        visit_type(self, out, tif, name, cmt) -> int
            @param out (C++: type_mods_t  *)
            @param tif (C++: const  tinfo_t  &)
            @param name (C++: const char *)
            @param cmt (C++: const char *)
        """
        return _ida_typeinf.tinfo_visitor_t_visit_type(self, *args)

    def prune_now(self, *args) -> "void":
        r"""


        To refuse to visit children of the current type, use this:
        """
        return _ida_typeinf.tinfo_visitor_t_prune_now(self, *args)

    def apply_to(self, *args) -> "int":
        r"""


        Call this function to initiate the traversal.
        
        apply_to(self, tif, out=None, name=None, cmt=None) -> int
            @param tif (C++: const  tinfo_t  &)
            @param out (C++: type_mods_t  *)
            @param name (C++: const char *)
            @param cmt (C++: const char *)
        """
        return _ida_typeinf.tinfo_visitor_t_apply_to(self, *args)
    __swig_destroy__ = _ida_typeinf.delete_tinfo_visitor_t
    def __disown__(self):
        self.this.disown()
        _ida_typeinf.disown_tinfo_visitor_t(self)
        return weakref.proxy(self)

# Register tinfo_visitor_t in _ida_typeinf:
_ida_typeinf.tinfo_visitor_t_swigregister(tinfo_visitor_t)
TVST_PRUNE = _ida_typeinf.TVST_PRUNE
"""
don't visit children of current type
"""

TVST_DEF = _ida_typeinf.TVST_DEF
"""
visit type definition (meaningful for typerefs)
"""

TVST_LEVEL = _ida_typeinf.TVST_LEVEL


class regobj_t(object):
    r"""
    Proxy of C++ regobj_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    regidx = property(_ida_typeinf.regobj_t_regidx_get, _ida_typeinf.regobj_t_regidx_set)
    relocate = property(_ida_typeinf.regobj_t_relocate_get, _ida_typeinf.regobj_t_relocate_set)
    value = property(_ida_typeinf.regobj_t_value_get, _ida_typeinf.regobj_t_value_set)

    def size(self, *args) -> "size_t":
        r"""
        size(self) -> size_t
        """
        return _ida_typeinf.regobj_t_size(self, *args)

    def __init__(self, *args):
        r"""
        __init__(self) -> regobj_t
        """
        _ida_typeinf.regobj_t_swiginit(self, _ida_typeinf.new_regobj_t(*args))
    __swig_destroy__ = _ida_typeinf.delete_regobj_t

# Register regobj_t in _ida_typeinf:
_ida_typeinf.regobj_t_swigregister(regobj_t)

class regobjs_t(regobjvec_t):
    r"""
    Proxy of C++ regobjs_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(self) -> regobjs_t
        """
        _ida_typeinf.regobjs_t_swiginit(self, _ida_typeinf.new_regobjs_t(*args))
    __swig_destroy__ = _ida_typeinf.delete_regobjs_t

# Register regobjs_t in _ida_typeinf:
_ida_typeinf.regobjs_t_swigregister(regobjs_t)


def unpack_idcobj_from_idb(*args) -> "error_t":
    r"""


    Collection of register objects.
    
    Read a typed idc object from the database
    
    unpack_idcobj_from_idb(obj, tif, ea, off0, pio_flags=0) -> error_t
        @param obj (C++: idc_value_t  *)
        @param tif (C++: const  tinfo_t  &)
        @param ea (C++: ea_t)
        @param off0 (C++: const  bytevec_t  *)
        @param pio_flags (C++: int)
    """
    return _ida_typeinf.unpack_idcobj_from_idb(*args)
PIO_NOATTR_FAIL = _ida_typeinf.PIO_NOATTR_FAIL
"""
missing attributes are not ok
"""

PIO_IGNORE_PTRS = _ida_typeinf.PIO_IGNORE_PTRS
"""
do not follow pointers
"""


def unpack_idcobj_from_bv(*args) -> "error_t":
    r"""


    Read a typed idc object from the byte vector.
    
    unpack_idcobj_from_bv(obj, tif, bytes, pio_flags=0) -> error_t
        @param obj (C++: idc_value_t  *)
        @param tif (C++: const  tinfo_t  &)
        @param bytes (C++: const  bytevec_t  &)
        @param pio_flags (C++: int)
    """
    return _ida_typeinf.unpack_idcobj_from_bv(*args)

def pack_idcobj_to_idb(*args) -> "error_t":
    r"""


    Write a typed idc object to the database.
    
    pack_idcobj_to_idb(obj, tif, ea, pio_flags=0) -> error_t
        @param obj (C++: const  idc_value_t  *)
        @param tif (C++: const  tinfo_t  &)
        @param ea (C++: ea_t)
        @param pio_flags (C++: int)
    """
    return _ida_typeinf.pack_idcobj_to_idb(*args)

def pack_idcobj_to_bv(*args) -> "error_t":
    r"""


    Write a typed idc object to the byte vector. Byte vector may be non-
    empty, this function will append data to it
    
    pack_idcobj_to_bv(obj, tif, bytes, objoff, pio_flags=0) -> error_t
        @param obj (C++: const  idc_value_t  *)
        @param tif (C++: const  tinfo_t  &)
        @param bytes (C++: relobj_t  *)
        @param objoff (C++: void *)
        @param pio_flags (C++: int)
    """
    return _ida_typeinf.pack_idcobj_to_bv(*args)

def apply_tinfo_to_stkarg(*args) -> "bool":
    r"""


    Helper function for the processor modules. to be called from
    \ph{use_stkarg_type}
    
    apply_tinfo_to_stkarg(insn, x, v, tif, name) -> bool
        @param insn  - an ida_ua.insn_t, or an address (C++: const insn_t &)
        @param x (C++: const  op_t  &)
        @param v (C++: uval_t)
        @param tif (C++: const  tinfo_t  &)
        @param name (C++: const char *)
    """
    return _ida_typeinf.apply_tinfo_to_stkarg(*args)
class argtinfo_helper_t(object):
    r"""
    Proxy of C++ argtinfo_helper_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    reserved = property(_ida_typeinf.argtinfo_helper_t_reserved_get, _ida_typeinf.argtinfo_helper_t_reserved_set)
    __swig_destroy__ = _ida_typeinf.delete_argtinfo_helper_t

    def set_op_tinfo(self, *args) -> "bool":
        r"""


        Set the operand type as specified.
        
        set_op_tinfo(self, insn, x, tif, name) -> bool
            @param insn  - an ida_ua.insn_t, or an address (C++: const insn_t &)
            @param x (C++: const  op_t  &)
            @param tif (C++: const  tinfo_t  &)
            @param name (C++: const char *)
        """
        return _ida_typeinf.argtinfo_helper_t_set_op_tinfo(self, *args)

    def is_stkarg_load(self, *args) -> "bool":
        r"""


        Is the current insn a stkarg load?. if yes:src: index of the source
        operand in \insn_t{ops}dst: index of the destination operand in
        \insn_t{ops} \insn_t{ops}[dst].addr is expected to have the stack
        offset
        
        is_stkarg_load(self, insn, src, dst) -> bool
            @param insn  - an ida_ua.insn_t, or an address (C++: const insn_t &)
            @param src (C++: int *)
            @param dst (C++: int *)
        """
        return _ida_typeinf.argtinfo_helper_t_is_stkarg_load(self, *args)

    def has_delay_slot(self, *args) -> "bool":
        r"""


        The call instruction with a delay slot?.
        
        has_delay_slot(self, arg0) -> bool
            arg0: ea_t
        """
        return _ida_typeinf.argtinfo_helper_t_has_delay_slot(self, *args)

    def use_arg_tinfos(self, *args) -> "void":
        r"""


        This function is to be called by the processor module in response to
        ev_use_arg_types.
        
        use_arg_tinfos(self, caller, fti, rargs)
            @param caller (C++: ea_t)
            @param fti (C++: func_type_data_t  *)
            @param rargs (C++: funcargvec_t  *)
        """
        return _ida_typeinf.argtinfo_helper_t_use_arg_tinfos(self, *args)

    def __init__(self, *args):
        r"""


        __init__(self) -> argtinfo_helper_t
            self: PyObject *
        """
        if self.__class__ == argtinfo_helper_t:
            _self = None
        else:
            _self = self
        _ida_typeinf.argtinfo_helper_t_swiginit(self, _ida_typeinf.new_argtinfo_helper_t(_self, *args))
    def __disown__(self):
        self.this.disown()
        _ida_typeinf.disown_argtinfo_helper_t(self)
        return weakref.proxy(self)

# Register argtinfo_helper_t in _ida_typeinf:
_ida_typeinf.argtinfo_helper_t_swigregister(argtinfo_helper_t)


def gen_use_arg_tinfos2(*args) -> "void":
    r"""


    Do not call this function directly, use 'argtinfo_helper_t' .
    
    gen_use_arg_tinfos2(_this, caller, fti, rargs)
        @param _this (C++: struct  argtinfo_helper_t  *)
        @param caller (C++: ea_t)
        @param fti (C++: func_type_data_t  *)
        @param rargs (C++: funcargvec_t  *)
    """
    return _ida_typeinf.gen_use_arg_tinfos2(*args)

def func_has_stkframe_hole(*args) -> "bool":
    r"""


    Looks for a hole at the beginning of the stack arguments. Will make
    use of the IDB's 'func_t' function at that place (if present) to help
    determine the presence of such a hole.
    
    func_has_stkframe_hole(ea, fti) -> bool
        @param ea (C++: ea_t)
        @param fti (C++: const  func_type_data_t  &)
    """
    return _ida_typeinf.func_has_stkframe_hole(*args)
class lowertype_helper_t(object):
    r"""
    Proxy of C++ lowertype_helper_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def func_has_stkframe_hole(self, *args) -> "bool":
        r"""


        func_has_stkframe_hole(self, candidate, candidate_data) -> bool
            @param candidate (C++: const  tinfo_t  &)
            @param candidate_data (C++: const  func_type_data_t  &)
        """
        return _ida_typeinf.lowertype_helper_t_func_has_stkframe_hole(self, *args)

    def get_func_purged_bytes(self, *args) -> "int":
        r"""


        get_func_purged_bytes(self, candidate, candidate_data) -> int
            @param candidate (C++: const  tinfo_t  &)
            @param candidate_data (C++: const  func_type_data_t  &)
        """
        return _ida_typeinf.lowertype_helper_t_get_func_purged_bytes(self, *args)
    __swig_destroy__ = _ida_typeinf.delete_lowertype_helper_t

# Register lowertype_helper_t in _ida_typeinf:
_ida_typeinf.lowertype_helper_t_swigregister(lowertype_helper_t)

class ida_lowertype_helper_t(lowertype_helper_t):
    r"""
    Proxy of C++ ida_lowertype_helper_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        __init__(self, _tif, _ea, _pb) -> ida_lowertype_helper_t
            _tif: tinfo_t const &
            _ea: ea_t
            _pb: int
        """
        _ida_typeinf.ida_lowertype_helper_t_swiginit(self, _ida_typeinf.new_ida_lowertype_helper_t(*args))

    def func_has_stkframe_hole(self, *args) -> "bool":
        r"""


        func_has_stkframe_hole(self, candidate, candidate_data) -> bool
            @param candidate (C++: const  tinfo_t  &)
            @param candidate_data (C++: const  func_type_data_t  &)
        """
        return _ida_typeinf.ida_lowertype_helper_t_func_has_stkframe_hole(self, *args)

    def get_func_purged_bytes(self, *args) -> "int":
        r"""


        get_func_purged_bytes(self, candidate, arg3) -> int
            @param candidate (C++: const  tinfo_t  &)
            arg3: func_type_data_t const &
        """
        return _ida_typeinf.ida_lowertype_helper_t_get_func_purged_bytes(self, *args)
    __swig_destroy__ = _ida_typeinf.delete_ida_lowertype_helper_t

# Register ida_lowertype_helper_t in _ida_typeinf:
_ida_typeinf.ida_lowertype_helper_t_swigregister(ida_lowertype_helper_t)


def lower_type(*args) -> "int":
    r"""


    Lower type. Inspect the type and lower all function subtypes using
    lower_func_type().We call the prototypes usually encountered in source
    files "high level"They may have implicit arguments, array arguments,
    big structure retvals, etcWe introduce explicit arguments (i.e. 'this'
    pointer) and call the result"low level prototype". See 'FTI_HIGH' .In
    order to improve heuristics for recognition of big structure
    retvals,it is recommended to pass a helper that will be used to make
    decisions.That helper will be used only for lowering 'tif', and not
    for the childrentypes walked through by recursion.
    
    lower_type(til, tif, name=None, _helper=None) -> int
        @param til (C++: til_t  *)
        @param tif (C++: tinfo_t  *)
        @param name (C++: const char *)
        @param _helper (C++: lowertype_helper_t  *)
        @retval: 1 - removed  FTI_HIGH ,
        @retval: 2 - made substantial changes
        @retval: -1 - failure
    """
    return _ida_typeinf.lower_type(*args)

def replace_ordinal_typerefs(*args) -> "int":
    r"""


    Replace references to ordinal types by name references. This function
    'unties' the type from the current local type library and makes it
    easier to export it.
    
    replace_ordinal_typerefs(til, tif) -> int
        @param til: type library to use. may be NULL. (C++: til_t  *)
        @param tif: type to modify (in/out) (C++: tinfo_t  *)
        @retval: number - of replaced subtypes, -1 on failure
    """
    return _ida_typeinf.replace_ordinal_typerefs(*args)
UTP_ENUM = _ida_typeinf.UTP_ENUM

UTP_STRUCT = _ida_typeinf.UTP_STRUCT


def begin_type_updating(*args) -> "void":
    r"""


    Mark the beginning of a large update operation on the types. Can be
    used with 'add_enum_member()' , add_struc_member, etc... Also see
    'end_type_updating()'
    
    begin_type_updating(utp)
        @param utp (C++: update_type_t)
    """
    return _ida_typeinf.begin_type_updating(*args)

def end_type_updating(*args) -> "void":
    r"""


    Mark the end of a large update operation on the types (see
    'begin_type_updating()' )
    
    end_type_updating(utp)
        @param utp (C++: update_type_t)
    """
    return _ida_typeinf.end_type_updating(*args)
class valstr_t(object):
    r"""
    Proxy of C++ valstr_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    oneline = property(_ida_typeinf.valstr_t_oneline_get, _ida_typeinf.valstr_t_oneline_set)
    length = property(_ida_typeinf.valstr_t_length_get, _ida_typeinf.valstr_t_length_set)
    members = property(_ida_typeinf.valstr_t_members_get, _ida_typeinf.valstr_t_members_set)
    info = property(_ida_typeinf.valstr_t_info_get, _ida_typeinf.valstr_t_info_set)
    props = property(_ida_typeinf.valstr_t_props_get, _ida_typeinf.valstr_t_props_set)

    def __init__(self, *args):
        r"""
        __init__(self) -> valstr_t
        """
        _ida_typeinf.valstr_t_swiginit(self, _ida_typeinf.new_valstr_t(*args))
    __swig_destroy__ = _ida_typeinf.delete_valstr_t

# Register valstr_t in _ida_typeinf:
_ida_typeinf.valstr_t_swigregister(valstr_t)
VALSTR_OPEN = _ida_typeinf.VALSTR_OPEN
"""
printed opening curly brace '{'
"""


class valstrs_t(valstrvec_t):
    r"""
    Proxy of C++ valstrs_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(self) -> valstrs_t
        """
        _ida_typeinf.valstrs_t_swiginit(self, _ida_typeinf.new_valstrs_t(*args))
    __swig_destroy__ = _ida_typeinf.delete_valstrs_t

# Register valstrs_t in _ida_typeinf:
_ida_typeinf.valstrs_t_swigregister(valstrs_t)

class text_sink_t(object):
    r"""
    Proxy of C++ text_sink_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def _print(self, *args) -> "int":
        r"""


        _print(self, str) -> int
            str: char const *
        """
        return _ida_typeinf.text_sink_t__print(self, *args)

    def __init__(self, *args):
        r"""


        __init__(self) -> text_sink_t
            self: PyObject *
        """
        if self.__class__ == text_sink_t:
            _self = None
        else:
            _self = self
        _ida_typeinf.text_sink_t_swiginit(self, _ida_typeinf.new_text_sink_t(_self, *args))
    __swig_destroy__ = _ida_typeinf.delete_text_sink_t
    def __disown__(self):
        self.this.disown()
        _ida_typeinf.disown_text_sink_t(self)
        return weakref.proxy(self)

# Register text_sink_t in _ida_typeinf:
_ida_typeinf.text_sink_t_swigregister(text_sink_t)

PDF_INCL_DEPS = _ida_typeinf.PDF_INCL_DEPS
"""
Include all type dependencies.
"""

PDF_DEF_FWD = _ida_typeinf.PDF_DEF_FWD
"""
Allow forward declarations.
"""

PDF_DEF_BASE = _ida_typeinf.PDF_DEF_BASE
"""
Include base types: __int8, __int16, etc..
"""

PDF_HEADER_CMT = _ida_typeinf.PDF_HEADER_CMT
"""
Prepend output with a descriptive comment.
"""


def calc_number_of_children(*args) -> "int":
    r"""


    Calculate max number of lines of a formatted c data, when expanded (
    'PTV_EXPAND' ).
    
    calc_number_of_children(loc, tif, dont_deref_ptr=False) -> int
        @param loc: location of the data ( ALOC_STATIC  or  ALOC_CUSTOM )
                    (C++: const  argloc_t  &)
        @param tif: type info (C++: const  tinfo_t  &)
        @param dont_deref_ptr: consider 'ea' as the ptr value (C++: bool)
        @retval: 0 - data is not expandable
        @retval: -1 - error, see qerrno
        @retval: else - the max number of lines
    """
    return _ida_typeinf.calc_number_of_children(*args)
PCN_RADIX = _ida_typeinf.PCN_RADIX
"""
number base to use
"""

PCN_DEC = _ida_typeinf.PCN_DEC
"""
decimal
"""

PCN_HEX = _ida_typeinf.PCN_HEX
"""
hexadecimal
"""

PCN_OCT = _ida_typeinf.PCN_OCT
"""
octal
"""

PCN_CHR = _ida_typeinf.PCN_CHR
"""
character
"""

PCN_UNSIGNED = _ida_typeinf.PCN_UNSIGNED
"""
add 'u' suffix
"""

PCN_LZHEX = _ida_typeinf.PCN_LZHEX
"""
print leading zeroes for hexdecimal number
"""

PCN_NEGSIGN = _ida_typeinf.PCN_NEGSIGN
"""
print negated value (-N) for negative numbers
"""

PCN_DECSEXT = _ida_typeinf.PCN_DECSEXT
"""
automatically extend sign of signed decimal numbers
"""


def get_enum_member_expr(*args) -> "qstring *":
    r"""


    Return a C expression that can be used to represent an enum member. If
    the value does not correspond to any single enum member, this function
    tries to find a bitwise combination of enum members that correspond to
    it. If more than half of value bits do not match any enum members, it
    fails.
    
    get_enum_member_expr(tif, serial, value) -> str
        @param tif: enumeration type (C++: const  tinfo_t  &)
        @param serial: which enumeration member to use (0 means the first with
                       the given value) (C++: int)
        @param value: value to search in the enumeration type. only 32-bit
                      number can be handled yet (C++: uint64)
        @return: success
    """
    return _ida_typeinf.get_enum_member_expr(*args)
class til_symbol_t(object):
    r"""
    Proxy of C++ til_symbol_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = property(_ida_typeinf.til_symbol_t_name_get, _ida_typeinf.til_symbol_t_name_set)
    til = property(_ida_typeinf.til_symbol_t_til_get, _ida_typeinf.til_symbol_t_til_set)

    def __init__(self, *args):
        r"""


        __init__(self, n=None, t=None) -> til_symbol_t
            n: char const *
            t: til_t const *
        """
        _ida_typeinf.til_symbol_t_swiginit(self, _ida_typeinf.new_til_symbol_t(*args))
    __swig_destroy__ = _ida_typeinf.delete_til_symbol_t

# Register til_symbol_t in _ida_typeinf:
_ida_typeinf.til_symbol_t_swigregister(til_symbol_t)

class predicate_t(object):
    r"""
    Proxy of C++ predicate_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def should_display(self, *args) -> "bool":
        r"""


        should_display(self, til, name, type, fields) -> bool
            @param til (C++: const  til_t  *)
            @param name (C++: const char *)
            @param type (C++: const  type_t  *)
            @param fields (C++: const  p_list  *)
        """
        return _ida_typeinf.predicate_t_should_display(self, *args)

    def __init__(self, *args):
        r"""


        __init__(self) -> predicate_t
            self: PyObject *
        """
        if self.__class__ == predicate_t:
            _self = None
        else:
            _self = self
        _ida_typeinf.predicate_t_swiginit(self, _ida_typeinf.new_predicate_t(_self, *args))
    __swig_destroy__ = _ida_typeinf.delete_predicate_t
    def __disown__(self):
        self.this.disown()
        _ida_typeinf.disown_predicate_t(self)
        return weakref.proxy(self)

# Register predicate_t in _ida_typeinf:
_ida_typeinf.predicate_t_swigregister(predicate_t)


def choose_named_type(*args) -> "bool":
    r"""


    Choose a type from a type library.
    
    choose_named_type(out_sym, root_til, title, ntf_flags, predicate=None) -> bool
        @param out_sym: pointer to be filled with the chosen type (C++:
                        til_symbol_t  *)
        @param root_til: pointer to starting til (the function will inspect
                         the base tils if allowed by flags) (C++: const  til_t
                         *)
        @param title: title of listbox to display (C++: const char *)
        @param ntf_flags: combination of  Flags for named types (C++: int)
        @param predicate: predicate to select types to display (maybe NULL)
                          (C++: predicate_t  *)
        @return: false if nothing is chosen, otherwise true
    """
    return _ida_typeinf.choose_named_type(*args)

def choose_local_tinfo(*args) -> "uint32":
    r"""


    Choose a type from the local type library.
    
    choose_local_tinfo(ti, title, func=None, def_ord=0, ud=None) -> uint32
        @param ti: pointer to til (C++: const  til_t  *)
        @param title: title of listbox to display (C++: const char *)
        @param func: predicate to select types to display (maybe NULL) (C++:
                     local_tinfo_predicate_t  *)
        @param def_ord: ordinal to position cursor before choose (C++: uint32)
        @param ud: user data (C++: void *)
        @return: == 0 means nothing is chosen, otherwise an ordinal number
    """
    return _ida_typeinf.choose_local_tinfo(*args)

def choose_local_tinfo_and_delta(*args) -> "uint32":
    r"""


    Choose a type from the local type library and specify the pointer
    shift value.
    
    choose_local_tinfo_and_delta(delta, ti, title, func=None, def_ord=0, ud=None) -> uint32
        @param delta: pointer shift value (C++: int32  *)
        @param ti: pointer to til (C++: const  til_t  *)
        @param title: title of listbox to display (C++: const char *)
        @param func: predicate to select types to display (maybe NULL) (C++:
                     local_tinfo_predicate_t  *)
        @param def_ord: ordinal to position cursor before choose (C++: uint32)
        @param ud: user data (C++: void *)
        @return: == 0 means nothing is chosen, otherwise an ordinal number
    """
    return _ida_typeinf.choose_local_tinfo_and_delta(*args)

def gen_use_arg_tinfos(*args) -> "void":
    r"""


    gen_use_arg_tinfos(caller, fti, rargs, set_optype, is_stkarg_load, has_delay_slot)
        @param caller (C++: ea_t)
        @param fti (C++: func_type_data_t  *)
        @param rargs (C++: funcargvec_t  *)
        @param set_optype (C++: set_op_tinfo_t *)
        @param is_stkarg_load (C++: is_stkarg_load_t *)
        @param has_delay_slot (C++: has_delay_slot_t *)
    """
    return _ida_typeinf.gen_use_arg_tinfos(*args)

def idc_parse_decl(*args) -> "PyObject *":
    r"""


    idc_parse_decl(ti, decl, flags) -> PyObject *
        ti: til_t *
        decl: char const *
        flags: int
    """
    return _ida_typeinf.idc_parse_decl(*args)

def calc_type_size(*args) -> "PyObject *":
    r"""


    calc_type_size(ti, tp) -> PyObject *
    Returns the size of a type
    @param ti: Type info. 'None' can be passed.
    @param tp: type string
    @return:
        - None on failure
        - The size of the type
    """
    return _ida_typeinf.calc_type_size(*args)

def apply_type(*args) -> "bool":
    r"""


    apply_type(ti, type, fields, ea, flags) -> bool
    Apply the specified type to the address
    @param ti: Type info library. 'None' can be used.
    @param py_type: type string
    @param py_fields: fields string (may be empty or None)
    @param ea: the address of the object
    @param flags: combination of TINFO_... constants or 0
    @return: Boolean
    """
    return _ida_typeinf.apply_type(*args)

def get_arg_addrs(*args) -> "PyObject *":
    r"""


    get_arg_addrs(caller) -> PyObject *
    Retrieve addresses of argument initialization instructions
    
    @param caller: the address of the call instruction
    @return: list of instruction addresses
    """
    return _ida_typeinf.get_arg_addrs(*args)

def unpack_object_from_idb(*args) -> "PyObject *":
    r"""


    unpack_object_from_idb(ti, type, fields, ea, pio_flags=0) -> PyObject *
        ti: til_t *
        type: type_t const *
        fields: p_list const *
        ea: ea_t
        pio_flags: int
    """
    return _ida_typeinf.unpack_object_from_idb(*args)

def unpack_object_from_bv(*args) -> "PyObject *":
    r"""


    unpack_object_from_bv(ti, type, fields, bytes, pio_flags=0) -> PyObject *
    Unpacks a buffer into an object.
    Returns the error_t returned by idaapi.pack_object_to_idb
    @param ti: Type info. 'None' can be passed.
    @param tp: type string
    @param fields: fields string (may be empty or None)
    @param bytes: the bytes to unpack
    @param pio_flags: flags used while unpacking
    @return:
        - tuple(0, err) on failure
        - tuple(1, obj) on success
    """
    return _ida_typeinf.unpack_object_from_bv(*args)

def pack_object_to_idb(*args) -> "PyObject *":
    r"""


    pack_object_to_idb(py_obj, ti, type, fields, ea, pio_flags=0) -> PyObject *
    Write a typed object to the database.
    Raises an exception if wrong parameters were passed or conversion fails
    Returns the error_t returned by idaapi.pack_object_to_idb
    @param ti: Type info. 'None' can be passed.
    @param tp: type string
    @param fields: fields string (may be empty or None)
    @param ea: ea to be used while packing
    @param pio_flags: flags used while unpacking
    """
    return _ida_typeinf.pack_object_to_idb(*args)

def pack_object_to_bv(*args) -> "PyObject *":
    r"""


    pack_object_to_bv(py_obj, ti, type, fields, base_ea, pio_flags=0) -> PyObject *
    Packs a typed object to a string
    @param ti: Type info. 'None' can be passed.
    @param tp: type string
    @param fields: fields string (may be empty or None)
    @param base_ea: base ea used to relocate the pointers in the packed object
    @param pio_flags: flags used while unpacking
    @return:
        tuple(0, err_code) on failure
        tuple(1, packed_buf) on success
    """
    return _ida_typeinf.pack_object_to_bv(*args)
PT_FILE = _ida_typeinf.PT_FILE


def idc_parse_types(*args) -> "int":
    r"""


    idc_parse_types(input, flags) -> int
        input: char const *
        flags: int
    """
    return _ida_typeinf.idc_parse_types(*args)

def idc_get_type_raw(*args) -> "PyObject *":
    r"""


    idc_get_type_raw(ea) -> PyObject *
        ea: ea_t
    """
    return _ida_typeinf.idc_get_type_raw(*args)

def idc_get_local_type_raw(*args) -> "PyObject *":
    r"""


    idc_get_local_type_raw(ordinal) -> PyObject *
        ordinal: int
    """
    return _ida_typeinf.idc_get_local_type_raw(*args)

def idc_guess_type(*args) -> "size_t":
    r"""


    idc_guess_type(ea) -> str
        ea: ea_t
    """
    return _ida_typeinf.idc_guess_type(*args)

def idc_get_type(*args) -> "size_t":
    r"""


    idc_get_type(ea) -> str
        ea: ea_t
    """
    return _ida_typeinf.idc_get_type(*args)

def idc_set_local_type(*args) -> "int":
    r"""


    idc_set_local_type(ordinal, dcl, flags) -> int
        ordinal: int
        dcl: char const *
        flags: int
    """
    return _ida_typeinf.idc_set_local_type(*args)

def idc_get_local_type(*args) -> "int":
    r"""


    idc_get_local_type(ordinal, flags, buf, maxsize) -> int
        ordinal: int
        flags: int
        buf: char *
        maxsize: size_t
    """
    return _ida_typeinf.idc_get_local_type(*args)

def idc_print_type(*args) -> "PyObject *":
    r"""


    idc_print_type(type, fields, name, flags) -> PyObject *
        type: type_t const *
        fields: p_list const *
        name: char const *
        flags: int
    """
    return _ida_typeinf.idc_print_type(*args)

def idc_get_local_type_name(*args) -> "size_t":
    r"""


    idc_get_local_type_name(ordinal) -> str
        ordinal: int
    """
    return _ida_typeinf.idc_get_local_type_name(*args)

def get_named_type(*args) -> "PyObject *":
    r"""


    get_named_type(til, name, ntf_flags) -> PyObject *
    Get a type data by its name.
    @param til: the type library
    @param name: the type name
    @param ntf_flags: a combination of NTF_* constants
    @return:
        None on failure
        tuple(code, type_str, fields_str, cmt, field_cmts, sclass, value) on success
    """
    return _ida_typeinf.get_named_type(*args)

def get_named_type64(*args) -> "PyObject *":
    r"""


    See 'get_named_type()' above.If the value in the 'ti' library is
    32-bit, it will be sign-extended before being stored in the 'value'
    pointer.
    
    get_named_type64(til, name, ntf_flags) -> PyObject *
        til: til_t const *
        @param name (C++: const char *)
        @param ntf_flags (C++: int)
    """
    return _ida_typeinf.get_named_type64(*args)

def print_decls(*args) -> "PyObject *":
    r"""


    Print types (and possibly their dependencies) in a format suitable for
    use in a header file. This is the reverse 'parse_decls()' .
    
    print_decls(printer, til, py_ordinals, flags) -> PyObject *
        @param printer: a handler for printing text (C++: text_sink_t  &)
        @param til: the type library holding the ordinals (C++: til_t  *)
        py_ordinals: PyObject *
        @param flags: flags for the algorithm. A combination of PDF_*
                      constants (C++: uint32)
        @retval: >0 - the number of types exported
        @retval: 0 - an error occurred
        @retval: <0 - the negated number of types exported. There were minor
                      errors and the resulting output might not be compilable.
    """
    return _ida_typeinf.print_decls(*args)

def remove_tinfo_pointer(*args) -> "PyObject *":
    r"""


    Remove pointer of a type. (i.e. convert "char *" into "char").
    Optionally remove the "lp" (or similar) prefix of the input name. If
    the input type is not a pointer, then fail.
    
    remove_tinfo_pointer(tif, name, til) -> PyObject *
        @param tif (C++: tinfo_t  *)
        name: char const *
        @param til (C++: const  til_t  *)
    """
    return _ida_typeinf.remove_tinfo_pointer(*args)

def get_numbered_type(*args) -> "PyObject *":
    r"""


    Retrieve a type by its ordinal number.
    
    get_numbered_type(til, ordinal) -> PyObject *
        til: til_t const *
        @param ordinal (C++: uint32)
    """
    return _ida_typeinf.get_numbered_type(*args)

#<pycode(py_typeinf)>

import ida_idaapi
ida_idaapi._listify_types(
    reginfovec_t)

#</pycode(py_typeinf)>


if _BC695:
    BFI_NOCONST=0
    BFI_NOLOCS=0
    NTF_NOIDB=0
    PRVLOC_STKOFF=PRALOC_VERIFY
    PRVLOC_VERIFY=PRALOC_STKOFF
    TERR_TOOLONGNAME=TERR_WRONGNAME
    @bc695redef
    def add_til(name, flags=0):
        return _ida_typeinf.add_til(name, flags)
    add_til2=add_til
    def apply_decl(arg0, arg1, arg2=None, arg3=0):
        if type(arg0) in ida_idaapi.integer_types: # old apply_cdecl()
            return _ida_typeinf.apply_cdecl(cvar.idati, arg0, arg1, 0)
        else:
            assert(arg2 is not None)
            return _ida_typeinf.apply_cdecl(arg0, arg1, arg2, arg3)
    apply_cdecl2=apply_decl
    apply_tinfo2=apply_tinfo
    calc_c_cpp_name4=calc_c_cpp_name
    import ida_idaapi
    callregs_init_regs=ida_idaapi._BC695.dummy
    choose_local_type=choose_local_tinfo
    def choose_named_type2(root_til, title, ntf_flags, func, out_sym):
        class func_pred_t(predicate_t):
            def __init__(self, func):
                predicate_t.__init__(self)
                self.func = func
            def should_display(self, til, name, tp, flds):
                return self.func(name, tp, flds)
        fp = func_pred_t(func)
        return choose_named_type(out_sym, root_til, title, ntf_flags, fp)
    deref_ptr2=deref_ptr
    extract_varloc=extract_argloc
    const_vloc_visitor_t=const_aloc_visitor_t
    for_all_const_varlocs=for_all_const_arglocs
    for_all_varlocs=for_all_arglocs
    def gen_decorate_name3(name, mangle, cc):
        return gen_decorate_name(name, mangle, cc, None) # ATM gen_decorate_name doesn't use its tinfo_t
    get_enum_member_expr2=get_enum_member_expr
    get_idainfo_by_type3=get_idainfo_by_type
    def guess_func_tinfo2(pfn, tif):
        return guess_tinfo(pfn.start_ea, tif)
    @bc695redef
    def load_til(name, tildir=None, *args):
# 6.95 C++ prototypes
# idaman til_t *ida_export load_til(const char *tildir, const char *name, char *errbuf, size_t bufsize);
# idaman til_t *ida_export load_til2(                   const char *name, char *errbuf, size_t bufsize);
#
# 6.95 Python prototypes
# load_til(tildir, name)
# load_til(tildir, name, errbuf, bufsize)
# load_til2(name, errbuf, bufsize=0)
#
# -> it's virtually impossible to tell whether it's load_til2(),
# or load_til() that's called since they both take 2 first string
# arguments. We'll rely the contents of those strings...
        if name is None or name == "": # load_til(), with an empty tildir
            name = tildir
            tildir = ""
            return _ida_typeinf.load_til(name, tildir)
        else:
            return _ida_typeinf.load_til(name, tildir)
    load_til2=load_til
    lower_type2=lower_type
    optimize_varloc=optimize_argloc
    def parse_decl2(til, decl, tif, flags):
        return _ida_typeinf.parse_decl(tif, til, decl, flags)
    @bc695redef
    def print_type(ea, flags):
        if isinstance(flags, bool):
            flags = PRTYPE_1LINE if flags else 0
        return _ida_typeinf.print_type(ea, flags)
    def print_type2(ea, flags):
        return _ida_typeinf.print_type(ea, flags)
    print_type3=_ida_typeinf.print_type
    print_varloc=print_argloc
    def resolve_typedef2(til, p, *args):
        return _ida_typeinf.resolve_typedef(til, p)
    scattered_vloc_t=scattered_aloc_t
    set_compiler2=set_compiler
    varloc_t=argloc_t
    varpart_t=argpart_t
    verify_varloc=verify_argloc
    vloc_visitor_t=aloc_visitor_t
    def guess_tinfo(*args):
        if isinstance(args[1], tinfo_t): # 6.95: id, tinfo_t
            tid, tif = args
        else:                            # 7.00: tinfo_t, id
            tif, tid = args
        return _ida_typeinf.guess_tinfo(tif, tid)
    guess_tinfo2=guess_tinfo
    def find_tinfo_udt_member(*args):
        if isinstance(args[2], udt_member_t): # 6.95: typid, strmem_flags, udm
              typid, strmem_flags, udm = args
        else:                                 # 7.00: udm, typid, strmem_flags
              udm, typid, strmem_flags = args
        return _ida_typeinf.find_tinfo_udt_member(udm, typid, strmem_flags)
    def __tinfo_t_find_udt_member(self, *args):
        if isinstance(args[1], udt_member_t): # 6.95: strmem_flags, udm
              strmem_flags, udm = args
        else:                                 # 7.00: udm, strmem_flags
              udm, strmem_flags = args
        return _ida_typeinf.tinfo_t_find_udt_member(self, udm, strmem_flags)
    tinfo_t.find_udt_member=__tinfo_t_find_udt_member
    def save_tinfo(*args):
        if isinstance(args[4], tinfo_t): # 6.95: til_t, size_t, name, int, tinfo_t
            til, _ord, name, ntf_flags, tif = args
        else:                            # 7.00: tinfo_t, til_t, size_t, name, int
            tif, til, _ord, name, ntf_flags = args
        return _ida_typeinf.save_tinfo(tif, til, _ord, name, ntf_flags)



