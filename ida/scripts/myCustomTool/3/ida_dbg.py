# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.1
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

"""
IDA Plugin SDK API wrapper: dbg
"""

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _ida_dbg
else:
    import _ida_dbg

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """
    Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass
    """
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """
    Meta class to enforce nondynamic attributes (no new attributes) for a class
    """
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import weakref

SWIG_PYTHON_LEGACY_BOOL = _ida_dbg.SWIG_PYTHON_LEGACY_BOOL

import ida_idaapi


import sys
_BC695 = sys.modules["__main__"].IDAPYTHON_COMPAT_695_API

if _BC695:






    def bc695redef(func):
        ida_idaapi._BC695.replace_fun(func)
        return func

import ida_idd
class bpt_vec_t(object):
    r"""
    Proxy of C++ qvector< bpt_t > class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        __init__(self) -> bpt_vec_t
            x: qvector< bpt_t > const &
        """
        _ida_dbg.bpt_vec_t_swiginit(self, _ida_dbg.new_bpt_vec_t(*args))
    __swig_destroy__ = _ida_dbg.delete_bpt_vec_t

    def push_back(self, *args) -> "bpt_t &":
        r"""


        push_back(self, x)
            x: bpt_t const &
        """
        return _ida_dbg.bpt_vec_t_push_back(self, *args)

    def pop_back(self, *args) -> "void":
        r"""
        pop_back(self)
        """
        return _ida_dbg.bpt_vec_t_pop_back(self, *args)

    def size(self, *args) -> "size_t":
        r"""
        size(self) -> size_t
        """
        return _ida_dbg.bpt_vec_t_size(self, *args)

    def empty(self, *args) -> "bool":
        r"""
        empty(self) -> bool
        """
        return _ida_dbg.bpt_vec_t_empty(self, *args)

    def at(self, *args) -> "bpt_t const &":
        r"""


        at(self, _idx) -> bpt_t
            _idx: size_t
        """
        return _ida_dbg.bpt_vec_t_at(self, *args)

    def qclear(self, *args) -> "void":
        r"""
        qclear(self)
        """
        return _ida_dbg.bpt_vec_t_qclear(self, *args)

    def clear(self, *args) -> "void":
        r"""
        clear(self)
        """
        return _ida_dbg.bpt_vec_t_clear(self, *args)

    def resize(self, *args) -> "void":
        r"""


        resize(self, _newsize, x)
            _newsize: size_t
            x: bpt_t const &
        

        resize(self, _newsize)
            _newsize: size_t
        """
        return _ida_dbg.bpt_vec_t_resize(self, *args)

    def grow(self, *args) -> "void":
        r"""


        grow(self, x=bpt_t())
            x: bpt_t const &
        """
        return _ida_dbg.bpt_vec_t_grow(self, *args)

    def capacity(self, *args) -> "size_t":
        r"""
        capacity(self) -> size_t
        """
        return _ida_dbg.bpt_vec_t_capacity(self, *args)

    def reserve(self, *args) -> "void":
        r"""


        reserve(self, cnt)
            cnt: size_t
        """
        return _ida_dbg.bpt_vec_t_reserve(self, *args)

    def truncate(self, *args) -> "void":
        r"""
        truncate(self)
        """
        return _ida_dbg.bpt_vec_t_truncate(self, *args)

    def swap(self, *args) -> "void":
        r"""


        swap(self, r)
            r: qvector< bpt_t > &
        """
        return _ida_dbg.bpt_vec_t_swap(self, *args)

    def extract(self, *args) -> "bpt_t *":
        r"""
        extract(self) -> bpt_t
        """
        return _ida_dbg.bpt_vec_t_extract(self, *args)

    def inject(self, *args) -> "void":
        r"""


        inject(self, s, len)
            s: bpt_t *
            len: size_t
        """
        return _ida_dbg.bpt_vec_t_inject(self, *args)

    def begin(self, *args) -> "qvector< bpt_t >::const_iterator":
        r"""
        begin(self) -> bpt_t
        begin(self) -> bpt_t
        """
        return _ida_dbg.bpt_vec_t_begin(self, *args)

    def end(self, *args) -> "qvector< bpt_t >::const_iterator":
        r"""
        end(self) -> bpt_t
        end(self) -> bpt_t
        """
        return _ida_dbg.bpt_vec_t_end(self, *args)

    def insert(self, *args) -> "qvector< bpt_t >::iterator":
        r"""


        insert(self, it, x) -> bpt_t
            it: qvector< bpt_t >::iterator
            x: bpt_t const &
        """
        return _ida_dbg.bpt_vec_t_insert(self, *args)

    def erase(self, *args) -> "qvector< bpt_t >::iterator":
        r"""


        erase(self, it) -> bpt_t
            it: qvector< bpt_t >::iterator
        

        erase(self, first, last) -> bpt_t
            first: qvector< bpt_t >::iterator
            last: qvector< bpt_t >::iterator
        """
        return _ida_dbg.bpt_vec_t_erase(self, *args)

    def __len__(self, *args) -> "size_t":
        r"""
        __len__(self) -> size_t
        """
        return _ida_dbg.bpt_vec_t___len__(self, *args)

    def __getitem__(self, *args) -> "bpt_t const &":
        r"""


        __getitem__(self, i) -> bpt_t
            i: size_t
        """
        return _ida_dbg.bpt_vec_t___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        r"""


        __setitem__(self, i, v)
            i: size_t
            v: bpt_t const &
        """
        return _ida_dbg.bpt_vec_t___setitem__(self, *args)

    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator


# Register bpt_vec_t in _ida_dbg:
_ida_dbg.bpt_vec_t_swigregister(bpt_vec_t)

class tev_reg_values_t(object):
    r"""
    Proxy of C++ qvector< tev_reg_value_t > class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        __init__(self) -> tev_reg_values_t
            x: qvector< tev_reg_value_t > const &
        """
        _ida_dbg.tev_reg_values_t_swiginit(self, _ida_dbg.new_tev_reg_values_t(*args))
    __swig_destroy__ = _ida_dbg.delete_tev_reg_values_t

    def push_back(self, *args) -> "tev_reg_value_t &":
        r"""


        push_back(self, x)
            x: tev_reg_value_t const &
        """
        return _ida_dbg.tev_reg_values_t_push_back(self, *args)

    def pop_back(self, *args) -> "void":
        r"""
        pop_back(self)
        """
        return _ida_dbg.tev_reg_values_t_pop_back(self, *args)

    def size(self, *args) -> "size_t":
        r"""
        size(self) -> size_t
        """
        return _ida_dbg.tev_reg_values_t_size(self, *args)

    def empty(self, *args) -> "bool":
        r"""
        empty(self) -> bool
        """
        return _ida_dbg.tev_reg_values_t_empty(self, *args)

    def at(self, *args) -> "tev_reg_value_t const &":
        r"""


        at(self, _idx) -> tev_reg_value_t
            _idx: size_t
        """
        return _ida_dbg.tev_reg_values_t_at(self, *args)

    def qclear(self, *args) -> "void":
        r"""
        qclear(self)
        """
        return _ida_dbg.tev_reg_values_t_qclear(self, *args)

    def clear(self, *args) -> "void":
        r"""
        clear(self)
        """
        return _ida_dbg.tev_reg_values_t_clear(self, *args)

    def resize(self, *args) -> "void":
        r"""


        resize(self, _newsize, x)
            _newsize: size_t
            x: tev_reg_value_t const &
        

        resize(self, _newsize)
            _newsize: size_t
        """
        return _ida_dbg.tev_reg_values_t_resize(self, *args)

    def grow(self, *args) -> "void":
        r"""


        grow(self, x=tev_reg_value_t())
            x: tev_reg_value_t const &
        """
        return _ida_dbg.tev_reg_values_t_grow(self, *args)

    def capacity(self, *args) -> "size_t":
        r"""
        capacity(self) -> size_t
        """
        return _ida_dbg.tev_reg_values_t_capacity(self, *args)

    def reserve(self, *args) -> "void":
        r"""


        reserve(self, cnt)
            cnt: size_t
        """
        return _ida_dbg.tev_reg_values_t_reserve(self, *args)

    def truncate(self, *args) -> "void":
        r"""
        truncate(self)
        """
        return _ida_dbg.tev_reg_values_t_truncate(self, *args)

    def swap(self, *args) -> "void":
        r"""


        swap(self, r)
            r: qvector< tev_reg_value_t > &
        """
        return _ida_dbg.tev_reg_values_t_swap(self, *args)

    def extract(self, *args) -> "tev_reg_value_t *":
        r"""
        extract(self) -> tev_reg_value_t
        """
        return _ida_dbg.tev_reg_values_t_extract(self, *args)

    def inject(self, *args) -> "void":
        r"""


        inject(self, s, len)
            s: tev_reg_value_t *
            len: size_t
        """
        return _ida_dbg.tev_reg_values_t_inject(self, *args)

    def begin(self, *args) -> "qvector< tev_reg_value_t >::const_iterator":
        r"""
        begin(self) -> tev_reg_value_t
        begin(self) -> tev_reg_value_t
        """
        return _ida_dbg.tev_reg_values_t_begin(self, *args)

    def end(self, *args) -> "qvector< tev_reg_value_t >::const_iterator":
        r"""
        end(self) -> tev_reg_value_t
        end(self) -> tev_reg_value_t
        """
        return _ida_dbg.tev_reg_values_t_end(self, *args)

    def insert(self, *args) -> "qvector< tev_reg_value_t >::iterator":
        r"""


        insert(self, it, x) -> tev_reg_value_t
            it: qvector< tev_reg_value_t >::iterator
            x: tev_reg_value_t const &
        """
        return _ida_dbg.tev_reg_values_t_insert(self, *args)

    def erase(self, *args) -> "qvector< tev_reg_value_t >::iterator":
        r"""


        erase(self, it) -> tev_reg_value_t
            it: qvector< tev_reg_value_t >::iterator
        

        erase(self, first, last) -> tev_reg_value_t
            first: qvector< tev_reg_value_t >::iterator
            last: qvector< tev_reg_value_t >::iterator
        """
        return _ida_dbg.tev_reg_values_t_erase(self, *args)

    def __len__(self, *args) -> "size_t":
        r"""
        __len__(self) -> size_t
        """
        return _ida_dbg.tev_reg_values_t___len__(self, *args)

    def __getitem__(self, *args) -> "tev_reg_value_t const &":
        r"""


        __getitem__(self, i) -> tev_reg_value_t
            i: size_t
        """
        return _ida_dbg.tev_reg_values_t___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        r"""


        __setitem__(self, i, v)
            i: size_t
            v: tev_reg_value_t const &
        """
        return _ida_dbg.tev_reg_values_t___setitem__(self, *args)

    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator


# Register tev_reg_values_t in _ida_dbg:
_ida_dbg.tev_reg_values_t_swigregister(tev_reg_values_t)

class tevinforeg_vec_t(object):
    r"""
    Proxy of C++ qvector< tev_info_reg_t > class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        __init__(self) -> tevinforeg_vec_t
            x: qvector< tev_info_reg_t > const &
        """
        _ida_dbg.tevinforeg_vec_t_swiginit(self, _ida_dbg.new_tevinforeg_vec_t(*args))
    __swig_destroy__ = _ida_dbg.delete_tevinforeg_vec_t

    def push_back(self, *args) -> "tev_info_reg_t &":
        r"""


        push_back(self, x)
            x: tev_info_reg_t const &
        """
        return _ida_dbg.tevinforeg_vec_t_push_back(self, *args)

    def pop_back(self, *args) -> "void":
        r"""
        pop_back(self)
        """
        return _ida_dbg.tevinforeg_vec_t_pop_back(self, *args)

    def size(self, *args) -> "size_t":
        r"""
        size(self) -> size_t
        """
        return _ida_dbg.tevinforeg_vec_t_size(self, *args)

    def empty(self, *args) -> "bool":
        r"""
        empty(self) -> bool
        """
        return _ida_dbg.tevinforeg_vec_t_empty(self, *args)

    def at(self, *args) -> "tev_info_reg_t const &":
        r"""


        at(self, _idx) -> tev_info_reg_t
            _idx: size_t
        """
        return _ida_dbg.tevinforeg_vec_t_at(self, *args)

    def qclear(self, *args) -> "void":
        r"""
        qclear(self)
        """
        return _ida_dbg.tevinforeg_vec_t_qclear(self, *args)

    def clear(self, *args) -> "void":
        r"""
        clear(self)
        """
        return _ida_dbg.tevinforeg_vec_t_clear(self, *args)

    def resize(self, *args) -> "void":
        r"""


        resize(self, _newsize, x)
            _newsize: size_t
            x: tev_info_reg_t const &
        

        resize(self, _newsize)
            _newsize: size_t
        """
        return _ida_dbg.tevinforeg_vec_t_resize(self, *args)

    def grow(self, *args) -> "void":
        r"""


        grow(self, x=tev_info_reg_t())
            x: tev_info_reg_t const &
        """
        return _ida_dbg.tevinforeg_vec_t_grow(self, *args)

    def capacity(self, *args) -> "size_t":
        r"""
        capacity(self) -> size_t
        """
        return _ida_dbg.tevinforeg_vec_t_capacity(self, *args)

    def reserve(self, *args) -> "void":
        r"""


        reserve(self, cnt)
            cnt: size_t
        """
        return _ida_dbg.tevinforeg_vec_t_reserve(self, *args)

    def truncate(self, *args) -> "void":
        r"""
        truncate(self)
        """
        return _ida_dbg.tevinforeg_vec_t_truncate(self, *args)

    def swap(self, *args) -> "void":
        r"""


        swap(self, r)
            r: qvector< tev_info_reg_t > &
        """
        return _ida_dbg.tevinforeg_vec_t_swap(self, *args)

    def extract(self, *args) -> "tev_info_reg_t *":
        r"""
        extract(self) -> tev_info_reg_t
        """
        return _ida_dbg.tevinforeg_vec_t_extract(self, *args)

    def inject(self, *args) -> "void":
        r"""


        inject(self, s, len)
            s: tev_info_reg_t *
            len: size_t
        """
        return _ida_dbg.tevinforeg_vec_t_inject(self, *args)

    def begin(self, *args) -> "qvector< tev_info_reg_t >::const_iterator":
        r"""
        begin(self) -> tev_info_reg_t
        begin(self) -> tev_info_reg_t
        """
        return _ida_dbg.tevinforeg_vec_t_begin(self, *args)

    def end(self, *args) -> "qvector< tev_info_reg_t >::const_iterator":
        r"""
        end(self) -> tev_info_reg_t
        end(self) -> tev_info_reg_t
        """
        return _ida_dbg.tevinforeg_vec_t_end(self, *args)

    def insert(self, *args) -> "qvector< tev_info_reg_t >::iterator":
        r"""


        insert(self, it, x) -> tev_info_reg_t
            it: qvector< tev_info_reg_t >::iterator
            x: tev_info_reg_t const &
        """
        return _ida_dbg.tevinforeg_vec_t_insert(self, *args)

    def erase(self, *args) -> "qvector< tev_info_reg_t >::iterator":
        r"""


        erase(self, it) -> tev_info_reg_t
            it: qvector< tev_info_reg_t >::iterator
        

        erase(self, first, last) -> tev_info_reg_t
            first: qvector< tev_info_reg_t >::iterator
            last: qvector< tev_info_reg_t >::iterator
        """
        return _ida_dbg.tevinforeg_vec_t_erase(self, *args)

    def __len__(self, *args) -> "size_t":
        r"""
        __len__(self) -> size_t
        """
        return _ida_dbg.tevinforeg_vec_t___len__(self, *args)

    def __getitem__(self, *args) -> "tev_info_reg_t const &":
        r"""


        __getitem__(self, i) -> tev_info_reg_t
            i: size_t
        """
        return _ida_dbg.tevinforeg_vec_t___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        r"""


        __setitem__(self, i, v)
            i: size_t
            v: tev_info_reg_t const &
        """
        return _ida_dbg.tevinforeg_vec_t___setitem__(self, *args)

    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator


# Register tevinforeg_vec_t in _ida_dbg:
_ida_dbg.tevinforeg_vec_t_swigregister(tevinforeg_vec_t)

class memreg_infos_t(object):
    r"""
    Proxy of C++ qvector< memreg_info_t > class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        __init__(self) -> memreg_infos_t
            x: qvector< memreg_info_t > const &
        """
        _ida_dbg.memreg_infos_t_swiginit(self, _ida_dbg.new_memreg_infos_t(*args))
    __swig_destroy__ = _ida_dbg.delete_memreg_infos_t

    def push_back(self, *args) -> "memreg_info_t &":
        r"""


        push_back(self, x)
            x: memreg_info_t const &
        """
        return _ida_dbg.memreg_infos_t_push_back(self, *args)

    def pop_back(self, *args) -> "void":
        r"""
        pop_back(self)
        """
        return _ida_dbg.memreg_infos_t_pop_back(self, *args)

    def size(self, *args) -> "size_t":
        r"""
        size(self) -> size_t
        """
        return _ida_dbg.memreg_infos_t_size(self, *args)

    def empty(self, *args) -> "bool":
        r"""
        empty(self) -> bool
        """
        return _ida_dbg.memreg_infos_t_empty(self, *args)

    def at(self, *args) -> "memreg_info_t const &":
        r"""


        at(self, _idx) -> memreg_info_t
            _idx: size_t
        """
        return _ida_dbg.memreg_infos_t_at(self, *args)

    def qclear(self, *args) -> "void":
        r"""
        qclear(self)
        """
        return _ida_dbg.memreg_infos_t_qclear(self, *args)

    def clear(self, *args) -> "void":
        r"""
        clear(self)
        """
        return _ida_dbg.memreg_infos_t_clear(self, *args)

    def resize(self, *args) -> "void":
        r"""


        resize(self, _newsize, x)
            _newsize: size_t
            x: memreg_info_t const &
        

        resize(self, _newsize)
            _newsize: size_t
        """
        return _ida_dbg.memreg_infos_t_resize(self, *args)

    def grow(self, *args) -> "void":
        r"""


        grow(self, x=memreg_info_t())
            x: memreg_info_t const &
        """
        return _ida_dbg.memreg_infos_t_grow(self, *args)

    def capacity(self, *args) -> "size_t":
        r"""
        capacity(self) -> size_t
        """
        return _ida_dbg.memreg_infos_t_capacity(self, *args)

    def reserve(self, *args) -> "void":
        r"""


        reserve(self, cnt)
            cnt: size_t
        """
        return _ida_dbg.memreg_infos_t_reserve(self, *args)

    def truncate(self, *args) -> "void":
        r"""
        truncate(self)
        """
        return _ida_dbg.memreg_infos_t_truncate(self, *args)

    def swap(self, *args) -> "void":
        r"""


        swap(self, r)
            r: qvector< memreg_info_t > &
        """
        return _ida_dbg.memreg_infos_t_swap(self, *args)

    def extract(self, *args) -> "memreg_info_t *":
        r"""
        extract(self) -> memreg_info_t
        """
        return _ida_dbg.memreg_infos_t_extract(self, *args)

    def inject(self, *args) -> "void":
        r"""


        inject(self, s, len)
            s: memreg_info_t *
            len: size_t
        """
        return _ida_dbg.memreg_infos_t_inject(self, *args)

    def begin(self, *args) -> "qvector< memreg_info_t >::const_iterator":
        r"""
        begin(self) -> memreg_info_t
        begin(self) -> memreg_info_t
        """
        return _ida_dbg.memreg_infos_t_begin(self, *args)

    def end(self, *args) -> "qvector< memreg_info_t >::const_iterator":
        r"""
        end(self) -> memreg_info_t
        end(self) -> memreg_info_t
        """
        return _ida_dbg.memreg_infos_t_end(self, *args)

    def insert(self, *args) -> "qvector< memreg_info_t >::iterator":
        r"""


        insert(self, it, x) -> memreg_info_t
            it: qvector< memreg_info_t >::iterator
            x: memreg_info_t const &
        """
        return _ida_dbg.memreg_infos_t_insert(self, *args)

    def erase(self, *args) -> "qvector< memreg_info_t >::iterator":
        r"""


        erase(self, it) -> memreg_info_t
            it: qvector< memreg_info_t >::iterator
        

        erase(self, first, last) -> memreg_info_t
            first: qvector< memreg_info_t >::iterator
            last: qvector< memreg_info_t >::iterator
        """
        return _ida_dbg.memreg_infos_t_erase(self, *args)

    def __len__(self, *args) -> "size_t":
        r"""
        __len__(self) -> size_t
        """
        return _ida_dbg.memreg_infos_t___len__(self, *args)

    def __getitem__(self, *args) -> "memreg_info_t const &":
        r"""


        __getitem__(self, i) -> memreg_info_t
            i: size_t
        """
        return _ida_dbg.memreg_infos_t___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        r"""


        __setitem__(self, i, v)
            i: size_t
            v: memreg_info_t const &
        """
        return _ida_dbg.memreg_infos_t___setitem__(self, *args)

    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator


# Register memreg_infos_t in _ida_dbg:
_ida_dbg.memreg_infos_t_swigregister(memreg_infos_t)


def run_to(*args) -> "bool":
    r"""


    Execute the process until the given address is reached. If no process
    is active, a new process is started. Technically, the debugger sets up
    a temporary breakpoint at the given address, and continues (or starts)
    the execution of the whole process. So, all threads continue their
    execution! \sq{Type, Asynchronous function - available as Request,
    Notification, 'dbg_run_to' }
    
    run_to(ea, pid=pid_t(-1), tid=0) -> bool
        @param ea: target address (C++: ea_t)
        @param pid: not used yet. please do not specify this parameter. (C++:
                    pid_t)
        @param tid: not used yet. please do not specify this parameter. (C++:
                    thid_t)
    """
    return _ida_dbg.run_to(*args)

def request_run_to(*args) -> "bool":
    r"""


    Post a 'run_to()' request.
    
    request_run_to(ea, pid=pid_t(-1), tid=0) -> bool
        @param ea (C++: ea_t)
        @param pid (C++: pid_t)
        @param tid (C++: thid_t)
    """
    return _ida_dbg.request_run_to(*args)
dbg_null = _ida_dbg.dbg_null

dbg_process_start = _ida_dbg.dbg_process_start

dbg_process_exit = _ida_dbg.dbg_process_exit

dbg_process_attach = _ida_dbg.dbg_process_attach

dbg_process_detach = _ida_dbg.dbg_process_detach

dbg_thread_start = _ida_dbg.dbg_thread_start

dbg_thread_exit = _ida_dbg.dbg_thread_exit

dbg_library_load = _ida_dbg.dbg_library_load

dbg_library_unload = _ida_dbg.dbg_library_unload

dbg_information = _ida_dbg.dbg_information

dbg_exception = _ida_dbg.dbg_exception

dbg_suspend_process = _ida_dbg.dbg_suspend_process

dbg_bpt = _ida_dbg.dbg_bpt

dbg_trace = _ida_dbg.dbg_trace

dbg_request_error = _ida_dbg.dbg_request_error

dbg_step_into = _ida_dbg.dbg_step_into

dbg_step_over = _ida_dbg.dbg_step_over

dbg_run_to = _ida_dbg.dbg_run_to

dbg_step_until_ret = _ida_dbg.dbg_step_until_ret

dbg_bpt_changed = _ida_dbg.dbg_bpt_changed

dbg_started_loading_bpts = _ida_dbg.dbg_started_loading_bpts

dbg_finished_loading_bpts = _ida_dbg.dbg_finished_loading_bpts

dbg_last = _ida_dbg.dbg_last

BPTEV_ADDED = _ida_dbg.BPTEV_ADDED
"""
Breakpoint has been added.
"""

BPTEV_REMOVED = _ida_dbg.BPTEV_REMOVED
"""
Breakpoint has been removed.
"""

BPTEV_CHANGED = _ida_dbg.BPTEV_CHANGED
"""
Breakpoint has been modified.
"""


def run_requests(*args) -> "bool":
    r"""


    Execute requests until all requests are processed or an asynchronous
    function is called. \sq{Type, Synchronous function, Notification, none
    (synchronous function)}If called from a notification handler, the
    execution of requests will be postponed to the end of the execution of
    all notification handlers.
    """
    return _ida_dbg.run_requests(*args)

def get_running_request(*args) -> "ui_notification_t":
    r"""


    Get the current running request. \sq{Type, Synchronous function,
    Notification, none (synchronous function)}
    """
    return _ida_dbg.get_running_request(*args)

def is_request_running(*args) -> "bool":
    r"""


    Is a request currently running?
    """
    return _ida_dbg.is_request_running(*args)

def get_running_notification(*args) -> "dbg_notification_t":
    r"""


    Get the notification associated (if any) with the current running
    request. \sq{Type, Synchronous function, Notification, none
    (synchronous function)}
    """
    return _ida_dbg.get_running_notification(*args)

def clear_requests_queue(*args) -> "void":
    r"""


    Clear the queue of waiting requests. \sq{Type, Synchronous function,
    Notification, none (synchronous function)}If a request is currently
    running, this one isn't stopped.
    """
    return _ida_dbg.clear_requests_queue(*args)

def get_process_state(*args) -> "int":
    r"""


    Return the state of the currently debugged process. \sq{Type,
    Synchronous function, Notification, none (synchronous function)}
    """
    return _ida_dbg.get_process_state(*args)
DSTATE_SUSP = _ida_dbg.DSTATE_SUSP
"""
process is suspended and will not continue
"""

DSTATE_NOTASK = _ida_dbg.DSTATE_NOTASK
"""
no process is currently debugged
"""

DSTATE_RUN = _ida_dbg.DSTATE_RUN
"""
process is running
"""

DBGINV_MEMORY = _ida_dbg.DBGINV_MEMORY
"""
invalidate cached memory contents
"""

DBGINV_MEMCFG = _ida_dbg.DBGINV_MEMCFG
"""
invalidate cached process segmentation
"""

DBGINV_REGS = _ida_dbg.DBGINV_REGS
"""
invalidate cached register values
"""

DBGINV_ALL = _ida_dbg.DBGINV_ALL
"""
invalidate everything
"""

DBGINV_REDRAW = _ida_dbg.DBGINV_REDRAW
"""
refresh the screen
"""

DBGINV_NONE = _ida_dbg.DBGINV_NONE
"""
invalidate nothing
"""


def set_process_state(*args) -> "int":
    r"""


    Set new state for the debugged process. Notifies the IDA kernel about
    the change of the debugged process state. For example, a debugger
    module could call this function when it knows that the process is
    suspended for a short period of time. Some IDA API calls can be made
    only when the process is suspended. The process state is usually
    restored before returning control to the caller. You must know that it
    is ok to change the process state, doing it at arbitrary moments may
    crash the application or IDA. \sq{Type, Synchronous function,
    Notification, none (synchronous function)}
    
    set_process_state(newstate, p_thid, dbginv) -> int
        @param newstate: new process state (one of  Debugged process states )
                         if  DSTATE_NOTASK  is passed then the state is not
                         changed (C++: int)
        @param p_thid: ptr to new thread id. may be NULL or pointer to
                       NO_THREAD . the pointed variable will contain the old
                       thread id upon return (C++: thid_t  *)
        @param dbginv: Debugged process invalidation options (C++: int)
        @return: old debugger state (one of  Debugged process states )
    """
    return _ida_dbg.set_process_state(*args)

def invalidate_dbg_state(*args) -> "int":
    r"""


    Invalidate cached debugger information. \sq{Type, Synchronous
    function, Notification, none (synchronous function)}
    
    invalidate_dbg_state(dbginv) -> int
        @param dbginv: Debugged process invalidation options (C++: int)
        @return: current debugger state (one of  Debugged process states )
    """
    return _ida_dbg.invalidate_dbg_state(*args)

def start_process(*args) -> "int":
    r"""


    Start a process in the debugger. \sq{Type, Asynchronous function -
    available as Request, Notification, 'dbg_process_start' }You can also
    use the 'run_to()' function to easily start the execution of a process
    until a given address is reached.For all parameters, a NULL value
    indicates the debugger will take the value from the defined Process
    Options.
    
    start_process(path=None, args=None, sdir=None) -> int
        @param path: path to the executable to start (C++: const char *)
        @param args: arguments to pass to process (C++: const char *)
        @param sdir: starting directory for the process (C++: const char *)
        @retval: -1 - impossible to create the process
        @retval: 0 - the starting of the process was cancelled by the user
        @retval: 1 - the process was properly started
    """
    return _ida_dbg.start_process(*args)

def request_start_process(*args) -> "int":
    r"""


    Post a 'start_process()' request.
    
    request_start_process(path=None, args=None, sdir=None) -> int
        @param path (C++: const char *)
        @param args (C++: const char *)
        @param sdir (C++: const char *)
    """
    return _ida_dbg.request_start_process(*args)

def suspend_process(*args) -> "bool":
    r"""


    Suspend the process in the debugger. \sq{ Type,Synchronous function
    (if in a notification handler)Asynchronous function (everywhere
    else)available as Request, Notification,none (if in a notification
    handler) 'dbg_suspend_process' (everywhere else) }The
    'suspend_process()' function can be called from a notification handler
    to force the stopping of the process. In this case, no notification
    will be generated. When you suspend a process, the running command is
    always aborted.
    """
    return _ida_dbg.suspend_process(*args)

def request_suspend_process(*args) -> "bool":
    r"""


    Post a 'suspend_process()' request.
    """
    return _ida_dbg.request_suspend_process(*args)

def continue_process(*args) -> "bool":
    r"""


    Continue the execution of the process in the debugger. \sq{Type,
    Synchronous function - available as Request, Notification, none
    (synchronous function)}The 'continue_process()' function can be called
    from a notification handler to force the continuation of the process.
    In this case the request queue will not be examined, IDA will simply
    resume execution. Usually it makes sense to call
    'request_continue_process()' followed by 'run_requests()' , so that
    IDA will first start a queued request (if any) and then resume the
    application.
    """
    return _ida_dbg.continue_process(*args)

def request_continue_process(*args) -> "bool":
    r"""


    Post a 'continue_process()' request.This requires an explicit call to
    'run_requests()'
    """
    return _ida_dbg.request_continue_process(*args)

def exit_process(*args) -> "bool":
    r"""


    Terminate the debugging of the current process. \sq{Type, Asynchronous
    function - available as Request, Notification, 'dbg_process_exit' }
    """
    return _ida_dbg.exit_process(*args)

def request_exit_process(*args) -> "bool":
    r"""


    Post an 'exit_process()' request.
    """
    return _ida_dbg.request_exit_process(*args)

def get_processes(*args) -> "ssize_t":
    r"""


    Take a snapshot of running processes and return their description.
    \sq{Type, Synchronous function, Notification, none (synchronous
    function)}
    
    get_processes(proclist) -> ssize_t
        @param proclist (C++: procinfo_vec_t  *)
        @return: number of processes or -1 on error
    """
    return _ida_dbg.get_processes(*args)

def attach_process(*args) -> "int":
    r"""


    Attach the debugger to a running process. \sq{Type, Asynchronous
    function - available as Request, Notification, 'dbg_process_attach'
    }This function shouldn't be called as a request if 'NO_PROCESS' is
    used.
    
    attach_process(pid=pid_t(-1), event_id=-1) -> int
        @param pid: PID of the process to attach to. If  NO_PROCESS , a dialog
                    box will interactively ask the user for the process to
                    attach to. (C++: pid_t)
        @param event_id (C++: int)
        @retval: -4 - debugger was not inited
        @retval: -3 - the attaching is not supported
        @retval: -2 - impossible to find a compatible process
        @retval: -1 - impossible to attach to the given process (process died,
                      privilege needed, not supported by the debugger plugin,
                      ...)
        @retval: 0 - the user cancelled the attaching to the process
        @retval: 1 - the debugger properly attached to the process
    """
    return _ida_dbg.attach_process(*args)

def request_attach_process(*args) -> "int":
    r"""


    Post an 'attach_process()' request.
    
    request_attach_process(pid, event_id) -> int
        @param pid (C++: pid_t)
        @param event_id (C++: int)
    """
    return _ida_dbg.request_attach_process(*args)

def detach_process(*args) -> "bool":
    r"""


    Detach the debugger from the debugged process. \sq{Type, Asynchronous
    function - available as Request, Notification, 'dbg_process_detach' }
    """
    return _ida_dbg.detach_process(*args)

def request_detach_process(*args) -> "bool":
    r"""


    Post a 'detach_process()' request.
    """
    return _ida_dbg.request_detach_process(*args)

def is_debugger_busy(*args) -> "bool":
    r"""


    Is the debugger busy?. Some debuggers do not accept any commands while
    the debugged application is running. For such a debugger, it is unsafe
    to do anything with the database (even simple queries like get_byte
    may lead to undesired consequences). Returns: true if the debugged
    application is running under such a debugger
    """
    return _ida_dbg.is_debugger_busy(*args)

def get_thread_qty(*args) -> "int":
    r"""


    Get number of threads. \sq{Type, Synchronous function, Notification,
    none (synchronous function)}
    """
    return _ida_dbg.get_thread_qty(*args)

def getn_thread(*args) -> "thid_t":
    r"""


    Get the ID of a thread. \sq{Type, Synchronous function, Notification,
    none (synchronous function)}
    
    getn_thread(n) -> thid_t
        @param n: number of thread, is in range 0.. get_thread_qty() -1 (C++:
                  int)
        @return: NO_THREAD  if the thread doesn't exist.
    """
    return _ida_dbg.getn_thread(*args)

def get_current_thread(*args) -> "thid_t":
    r"""


    Get current thread ID. \sq{Type, Synchronous function, Notification,
    none (synchronous function)}
    """
    return _ida_dbg.get_current_thread(*args)

def getn_thread_name(*args) -> "char const *":
    r"""


    Get the NAME of a thread \sq{Type, Synchronous function, Notification,
    none (synchronous function)}
    
    getn_thread_name(n) -> char const *
        @param n: number of thread, is in range 0.. get_thread_qty() -1 or -1
                  for the current thread (C++: int)
        @return: thread name or NULL if the thread doesn't exist.
    """
    return _ida_dbg.getn_thread_name(*args)

def select_thread(*args) -> "bool":
    r"""


    Select the given thread as the current debugged thread. All thread
    related execution functions will work on this thread. The process must
    be suspended to select a new thread. \sq{Type, Synchronous function -
    available as request, Notification, none (synchronous function)}
    
    select_thread(tid) -> bool
        @param tid: ID of the thread to select (C++: thid_t)
        @return: false if the thread doesn't exist.
    """
    return _ida_dbg.select_thread(*args)

def request_select_thread(*args) -> "bool":
    r"""


    Post a 'select_thread()' request.
    
    request_select_thread(tid) -> bool
        @param tid (C++: thid_t)
    """
    return _ida_dbg.request_select_thread(*args)

def suspend_thread(*args) -> "int":
    r"""


    Suspend thread. Suspending a thread may deadlock the whole application
    if the suspended was owning some synchronization objects. \sq{Type,
    Synchronous function - available as request, Notification, none
    (synchronous function)}
    
    suspend_thread(tid) -> int
        @param tid: thread id (C++: thid_t)
        @retval: -1 - network error
        @retval: 0 - failed
        @retval: 1 - ok
    """
    return _ida_dbg.suspend_thread(*args)

def request_suspend_thread(*args) -> "int":
    r"""


    Post a 'suspend_thread()' request.
    
    request_suspend_thread(tid) -> int
        @param tid (C++: thid_t)
    """
    return _ida_dbg.request_suspend_thread(*args)

def resume_thread(*args) -> "int":
    r"""


    Resume thread. \sq{Type, Synchronous function - available as request,
    Notification, none (synchronous function)}
    
    resume_thread(tid) -> int
        @param tid: thread id (C++: thid_t)
        @retval: -1 - network error
        @retval: 0 - failed
        @retval: 1 - ok
    """
    return _ida_dbg.resume_thread(*args)

def request_resume_thread(*args) -> "int":
    r"""


    Post a 'resume_thread()' request.
    
    request_resume_thread(tid) -> int
        @param tid (C++: thid_t)
    """
    return _ida_dbg.request_resume_thread(*args)

def get_first_module(*args) -> "bool":
    r"""


    get_first_module(modinfo) -> bool
        @param modinfo (C++: modinfo_t  *)
    """
    return _ida_dbg.get_first_module(*args)

def get_next_module(*args) -> "bool":
    r"""


    get_next_module(modinfo) -> bool
        @param modinfo (C++: modinfo_t  *)
    """
    return _ida_dbg.get_next_module(*args)

def step_into(*args) -> "bool":
    r"""


    Execute one instruction in the current thread. Other threads are kept
    suspended. \sq{Type, Asynchronous function - available as Request,
    Notification, 'dbg_step_into' }
    """
    return _ida_dbg.step_into(*args)

def request_step_into(*args) -> "bool":
    r"""


    Post a 'step_into()' request.
    """
    return _ida_dbg.request_step_into(*args)

def step_over(*args) -> "bool":
    r"""


    Execute one instruction in the current thread, but without entering
    into functions. Others threads keep suspended. \sq{Type, Asynchronous
    function - available as Request, Notification, 'dbg_step_over' }
    """
    return _ida_dbg.step_over(*args)

def request_step_over(*args) -> "bool":
    r"""


    Post a 'step_over()' request.
    """
    return _ida_dbg.request_step_over(*args)

def step_until_ret(*args) -> "bool":
    r"""


    Execute instructions in the current thread until a function return
    instruction is executed (aka "step out"). Other threads are kept
    suspended. \sq{Type, Asynchronous function - available as Request,
    Notification, 'dbg_step_until_ret' }
    """
    return _ida_dbg.step_until_ret(*args)

def request_step_until_ret(*args) -> "bool":
    r"""


    Post a 'step_until_ret()' request.
    """
    return _ida_dbg.request_step_until_ret(*args)

def set_resume_mode(*args) -> "bool":
    r"""


    How to resume the application. Set resume mode but do not resume
    process.
    
    set_resume_mode(tid, mode) -> bool
        @param tid (C++: thid_t)
        @param mode (C++: resume_mode_t)
    """
    return _ida_dbg.set_resume_mode(*args)

def request_set_resume_mode(*args) -> "bool":
    r"""


    Post a 'set_resume_mode()' request.
    
    request_set_resume_mode(tid, mode) -> bool
        @param tid (C++: thid_t)
        @param mode (C++: resume_mode_t)
    """
    return _ida_dbg.request_set_resume_mode(*args)

def get_dbg_reg_info(*args) -> "bool":
    r"""


    Get register information \sq{Type, Synchronous function, Notification,
    none (synchronous function)}
    
    get_dbg_reg_info(regname, ri) -> bool
        @param regname (C++: const char *)
        @param ri (C++: register_info_t  *)
    """
    return _ida_dbg.get_dbg_reg_info(*args)

def get_sp_val(*args) -> "uint64 *":
    r"""


    Get value of the SP register for the current thread. Requires a
    suspended debugger.
    """
    return _ida_dbg.get_sp_val(*args)

def get_ip_val(*args) -> "uint64 *":
    r"""


    Get value of the IP (program counter) register for the current thread.
    Requires a suspended debugger.
    """
    return _ida_dbg.get_ip_val(*args)

def is_reg_integer(*args) -> "bool":
    r"""


    Does a register contain an integer value? \sq{Type, Synchronous
    function, Notification, none (synchronous function)}
    
    is_reg_integer(regname) -> bool
        @param regname (C++: const char *)
    """
    return _ida_dbg.is_reg_integer(*args)

def is_reg_float(*args) -> "bool":
    r"""


    Does a register contain a floating point value? \sq{Type, Synchronous
    function, Notification, none (synchronous function)}
    
    is_reg_float(regname) -> bool
        @param regname (C++: const char *)
    """
    return _ida_dbg.is_reg_float(*args)

def is_reg_custom(*args) -> "bool":
    r"""


    Does a register contain a value of a custom data type? \sq{Type,
    Synchronous function, Notification, none (synchronous function)}
    
    is_reg_custom(regname) -> bool
        @param regname (C++: const char *)
    """
    return _ida_dbg.is_reg_custom(*args)

def set_bptloc_string(*args) -> "int":
    r"""


    Helper function for 'bpt_location_t' .
    
    set_bptloc_string(s) -> int
        @param s (C++: const char *)
    """
    return _ida_dbg.set_bptloc_string(*args)

def get_bptloc_string(*args) -> "char const *":
    r"""


    Helper function for 'bpt_location_t' .
    
    get_bptloc_string(i) -> char const *
        @param i (C++: int)
    """
    return _ida_dbg.get_bptloc_string(*args)
BPLT_ABS = _ida_dbg.BPLT_ABS

BPLT_REL = _ida_dbg.BPLT_REL

BPLT_SYM = _ida_dbg.BPLT_SYM

BPLT_SRC = _ida_dbg.BPLT_SRC

class bpt_location_t(object):
    r"""
    Proxy of C++ bpt_location_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    info = property(_ida_dbg.bpt_location_t_info_get, _ida_dbg.bpt_location_t_info_set)
    index = property(_ida_dbg.bpt_location_t_index_get, _ida_dbg.bpt_location_t_index_set)
    loctype = property(_ida_dbg.bpt_location_t_loctype_get, _ida_dbg.bpt_location_t_loctype_set)

    def type(self, *args) -> "bpt_loctype_t":
        r"""


        Get bpt type.
        """
        return _ida_dbg.bpt_location_t_type(self, *args)

    def is_empty_path(self, *args) -> "bool":
        r"""


        No path/filename specified? ( 'BPLT_REL' , 'BPLT_SRC' )
        """
        return _ida_dbg.bpt_location_t_is_empty_path(self, *args)

    def path(self, *args) -> "char const *":
        r"""


        Get path/filename ( 'BPLT_REL' , 'BPLT_SRC' )
        """
        return _ida_dbg.bpt_location_t_path(self, *args)

    def symbol(self, *args) -> "char const *":
        r"""


        Get symbol name ( 'BPLT_SYM' )
        """
        return _ida_dbg.bpt_location_t_symbol(self, *args)

    def lineno(self, *args) -> "int":
        r"""


        Get line number ( 'BPLT_SRC' )
        """
        return _ida_dbg.bpt_location_t_lineno(self, *args)

    def offset(self, *args) -> "uval_t":
        r"""


        Get offset ( 'BPLT_REL' , 'BPLT_SYM' )
        """
        return _ida_dbg.bpt_location_t_offset(self, *args)

    def ea(self, *args) -> "ea_t":
        r"""


        Get address ( 'BPLT_ABS' )
        """
        return _ida_dbg.bpt_location_t_ea(self, *args)

    def __init__(self, *args):
        r"""
        __init__(self) -> bpt_location_t
        """
        _ida_dbg.bpt_location_t_swiginit(self, _ida_dbg.new_bpt_location_t(*args))

    def set_abs_bpt(self, *args) -> "void":
        r"""


        Specify an absolute address location.
        
        set_abs_bpt(self, a)
            @param a (C++: ea_t)
        """
        return _ida_dbg.bpt_location_t_set_abs_bpt(self, *args)

    def set_src_bpt(self, *args) -> "void":
        r"""


        Specify a source level location.
        
        set_src_bpt(self, fn, _lineno)
            @param fn (C++: const char *)
            @param _lineno (C++: int)
        """
        return _ida_dbg.bpt_location_t_set_src_bpt(self, *args)

    def set_sym_bpt(self, *args) -> "void":
        r"""


        Specify a symbolic location.
        
        set_sym_bpt(self, _symbol, _offset=0)
            @param _symbol (C++: const char *)
            @param _offset (C++: uval_t)
        """
        return _ida_dbg.bpt_location_t_set_sym_bpt(self, *args)

    def set_rel_bpt(self, *args) -> "void":
        r"""


        Specify a relative address location.
        
        set_rel_bpt(self, mod, _offset)
            @param mod (C++: const char *)
            @param _offset (C++: uval_t)
        """
        return _ida_dbg.bpt_location_t_set_rel_bpt(self, *args)

    def compare(self, *args) -> "int":
        r"""


        Lexically compare two breakpoint locations. Bpt locations are first
        compared based on type (i.e. 'BPLT_ABS' < 'BPLT_REL' ). 'BPLT_ABS'
        locations are compared based on their ea values. For all other
        location types, locations are first compared based on their string
        (path/filename/symbol), then their offset/lineno.
        
        compare(self, r) -> int
            @param r (C++: const  bpt_location_t  &)
        """
        return _ida_dbg.bpt_location_t_compare(self, *args)

    def __eq__(self, *args) -> "bool":
        r"""


        __eq__(self, r) -> bool
            r: bpt_location_t const &
        """
        return _ida_dbg.bpt_location_t___eq__(self, *args)

    def __ne__(self, *args) -> "bool":
        r"""


        __ne__(self, r) -> bool
            r: bpt_location_t const &
        """
        return _ida_dbg.bpt_location_t___ne__(self, *args)

    def __lt__(self, *args) -> "bool":
        r"""


        __lt__(self, r) -> bool
            r: bpt_location_t const &
        """
        return _ida_dbg.bpt_location_t___lt__(self, *args)

    def __gt__(self, *args) -> "bool":
        r"""


        __gt__(self, r) -> bool
            r: bpt_location_t const &
        """
        return _ida_dbg.bpt_location_t___gt__(self, *args)

    def __le__(self, *args) -> "bool":
        r"""


        __le__(self, r) -> bool
            r: bpt_location_t const &
        """
        return _ida_dbg.bpt_location_t___le__(self, *args)

    def __ge__(self, *args) -> "bool":
        r"""


        __ge__(self, r) -> bool
            r: bpt_location_t const &
        """
        return _ida_dbg.bpt_location_t___ge__(self, *args)
    __swig_destroy__ = _ida_dbg.delete_bpt_location_t

# Register bpt_location_t in _ida_dbg:
_ida_dbg.bpt_location_t_swigregister(bpt_location_t)

class bpt_t(object):
    r"""
    Proxy of C++ bpt_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    cb = property(_ida_dbg.bpt_t_cb_get, _ida_dbg.bpt_t_cb_set)
    loc = property(_ida_dbg.bpt_t_loc_get, _ida_dbg.bpt_t_loc_set)
    pid = property(_ida_dbg.bpt_t_pid_get, _ida_dbg.bpt_t_pid_set)
    tid = property(_ida_dbg.bpt_t_tid_get, _ida_dbg.bpt_t_tid_set)
    ea = property(_ida_dbg.bpt_t_ea_get, _ida_dbg.bpt_t_ea_set)
    type = property(_ida_dbg.bpt_t_type_get, _ida_dbg.bpt_t_type_set)
    pass_count = property(_ida_dbg.bpt_t_pass_count_get, _ida_dbg.bpt_t_pass_count_set)
    flags = property(_ida_dbg.bpt_t_flags_get, _ida_dbg.bpt_t_flags_set)
    props = property(_ida_dbg.bpt_t_props_get, _ida_dbg.bpt_t_props_set)
    size = property(_ida_dbg.bpt_t_size_get, _ida_dbg.bpt_t_size_set)
    cndidx = property(_ida_dbg.bpt_t_cndidx_get, _ida_dbg.bpt_t_cndidx_set)

    def __init__(self, *args):
        r"""
        __init__(self) -> bpt_t
        """
        _ida_dbg.bpt_t_swiginit(self, _ida_dbg.new_bpt_t(*args))

    def is_hwbpt(self, *args) -> "bool":
        r"""


        Is hardware breakpoint?
        """
        return _ida_dbg.bpt_t_is_hwbpt(self, *args)

    def enabled(self, *args) -> "bool":
        r"""


        Is breakpoint enabled?
        """
        return _ida_dbg.bpt_t_enabled(self, *args)

    def is_low_level(self, *args) -> "bool":
        r"""


        Is bpt condition calculated at low level?
        """
        return _ida_dbg.bpt_t_is_low_level(self, *args)

    def badbpt(self, *args) -> "bool":
        r"""


        Failed to write bpt to process memory?
        """
        return _ida_dbg.bpt_t_badbpt(self, *args)

    def listbpt(self, *args) -> "bool":
        r"""


        Include in the bpt list?
        """
        return _ida_dbg.bpt_t_listbpt(self, *args)

    def is_compiled(self, *args) -> "bool":
        r"""


        Condition has been compiled?
        """
        return _ida_dbg.bpt_t_is_compiled(self, *args)

    def is_active(self, *args) -> "bool":
        r"""


        Written completely to process?
        """
        return _ida_dbg.bpt_t_is_active(self, *args)

    def is_partially_active(self, *args) -> "bool":
        r"""


        Written partially to process?
        """
        return _ida_dbg.bpt_t_is_partially_active(self, *args)

    def is_inactive(self, *args) -> "bool":
        r"""


        Not written to process at all?
        """
        return _ida_dbg.bpt_t_is_inactive(self, *args)

    def is_page_bpt(self, *args) -> "bool":
        r"""


        Page breakpoint?
        """
        return _ida_dbg.bpt_t_is_page_bpt(self, *args)

    def get_size(self, *args) -> "int":
        r"""


        Get bpt size.
        """
        return _ida_dbg.bpt_t_get_size(self, *args)

    def set_abs_bpt(self, *args) -> "void":
        r"""


        Set bpt location to an absolute address.
        
        set_abs_bpt(self, a)
            @param a (C++: ea_t)
        """
        return _ida_dbg.bpt_t_set_abs_bpt(self, *args)

    def set_src_bpt(self, *args) -> "void":
        r"""


        Set bpt location to a source line.
        
        set_src_bpt(self, fn, lineno)
            @param fn (C++: const char *)
            @param lineno (C++: int)
        """
        return _ida_dbg.bpt_t_set_src_bpt(self, *args)

    def set_sym_bpt(self, *args) -> "void":
        r"""


        Set bpt location to a symbol.
        
        set_sym_bpt(self, sym, o)
            @param sym (C++: const char *)
            @param o (C++: uval_t)
        """
        return _ida_dbg.bpt_t_set_sym_bpt(self, *args)

    def set_rel_bpt(self, *args) -> "void":
        r"""


        Set bpt location to a relative address.
        
        set_rel_bpt(self, mod, o)
            @param mod (C++: const char *)
            @param o (C++: uval_t)
        """
        return _ida_dbg.bpt_t_set_rel_bpt(self, *args)

    def is_absbpt(self, *args) -> "bool":
        r"""


        Is absolute address breakpoint?
        """
        return _ida_dbg.bpt_t_is_absbpt(self, *args)

    def is_relbpt(self, *args) -> "bool":
        r"""


        Is relative address breakpoint?
        """
        return _ida_dbg.bpt_t_is_relbpt(self, *args)

    def is_symbpt(self, *args) -> "bool":
        r"""


        Is symbolic breakpoint?
        """
        return _ida_dbg.bpt_t_is_symbpt(self, *args)

    def is_srcbpt(self, *args) -> "bool":
        r"""


        Is source level breakpoint?
        """
        return _ida_dbg.bpt_t_is_srcbpt(self, *args)

    def is_tracemodebpt(self, *args) -> "bool":
        r"""


        Does breakpoint trace anything?
        """
        return _ida_dbg.bpt_t_is_tracemodebpt(self, *args)

    def is_traceonbpt(self, *args) -> "bool":
        r"""


        Is this a tracing breakpoint, and is tracing enabled?
        """
        return _ida_dbg.bpt_t_is_traceonbpt(self, *args)

    def is_traceoffbpt(self, *args) -> "bool":
        r"""


        Is this a tracing breakpoint, and is tracing disabled?
        """
        return _ida_dbg.bpt_t_is_traceoffbpt(self, *args)

    def set_trace_action(self, *args) -> "bool":
        r"""


        Configure tracing options.
        
        set_trace_action(self, enable, trace_types) -> bool
            @param enable (C++: bool)
            @param trace_types (C++: int)
        """
        return _ida_dbg.bpt_t_set_trace_action(self, *args)

    def get_cnd_elang_idx(self, *args) -> "size_t":
        r"""
        get_cnd_elang_idx(self) -> size_t
        """
        return _ida_dbg.bpt_t_get_cnd_elang_idx(self, *args)
    condition = property(_ida_dbg.bpt_t_condition_get, _ida_dbg.bpt_t_condition_set)
    elang = property(_ida_dbg.bpt_t_elang_get, _ida_dbg.bpt_t_elang_set)
    __swig_destroy__ = _ida_dbg.delete_bpt_t

# Register bpt_t in _ida_dbg:
_ida_dbg.bpt_t_swigregister(bpt_t)
BPT_BRK = _ida_dbg.BPT_BRK
"""
suspend execution upon hit
"""

BPT_TRACE = _ida_dbg.BPT_TRACE
"""
add trace information upon hit
"""

BPT_UPDMEM = _ida_dbg.BPT_UPDMEM
"""
refresh the memory layout and contents before evaluating bpt condition
"""

BPT_ENABLED = _ida_dbg.BPT_ENABLED
"""
enabled?
"""

BPT_LOWCND = _ida_dbg.BPT_LOWCND
"""
condition is calculated at low level (on the server side)
"""

BPT_TRACEON = _ida_dbg.BPT_TRACEON
"""
enable tracing when the breakpoint is reached
"""

BPT_TRACE_INSN = _ida_dbg.BPT_TRACE_INSN
"""
instruction tracing
"""

BPT_TRACE_FUNC = _ida_dbg.BPT_TRACE_FUNC
"""
function tracing
"""

BPT_TRACE_BBLK = _ida_dbg.BPT_TRACE_BBLK
"""
basic block tracing
"""

BPT_TRACE_TYPES = _ida_dbg.BPT_TRACE_TYPES
"""
trace insns, functions, and basic blocks. if any of 'BPT_TRACE_TYPES'
bits are set but 'BPT_TRACEON' is clear, then turn off tracing for the
specified trace types
"""

BPT_ELANG_MASK = _ida_dbg.BPT_ELANG_MASK

BPT_ELANG_SHIFT = _ida_dbg.BPT_ELANG_SHIFT
"""
index of the extlang (scripting language) of the condition
"""

BKPT_BADBPT = _ida_dbg.BKPT_BADBPT
"""
failed to write the bpt to the process memory (at least one location)
"""

BKPT_LISTBPT = _ida_dbg.BKPT_LISTBPT
"""
include in bpt list (user-defined bpt)
"""

BKPT_TRACE = _ida_dbg.BKPT_TRACE
"""
trace bpt; should not be deleted when the process gets suspended
"""

BKPT_ACTIVE = _ida_dbg.BKPT_ACTIVE
"""
active?
"""

BKPT_PARTIAL = _ida_dbg.BKPT_PARTIAL
"""
partially active? (some locations were not written yet)
"""

BKPT_CNDREADY = _ida_dbg.BKPT_CNDREADY
"""
condition has been compiled
"""

BKPT_FAKEPEND = _ida_dbg.BKPT_FAKEPEND
"""
bpt of the same type is active at the same address(es)

fake pending bpt: it is inactive but another
"""

BKPT_PAGE = _ida_dbg.BKPT_PAGE
"""
only after writing the bpt to the process.

written to the process as a page bpt. is available
"""


MOVBPT_OK = _ida_dbg.MOVBPT_OK

MOVBPT_NOT_FOUND = _ida_dbg.MOVBPT_NOT_FOUND

MOVBPT_DEST_BUSY = _ida_dbg.MOVBPT_DEST_BUSY

MOVBPT_BAD_TYPE = _ida_dbg.MOVBPT_BAD_TYPE


def get_bpt_qty(*args) -> "int":
    r"""


    Get number of breakpoints. \sq{Type, Synchronous function,
    Notification, none (synchronous function)}
    """
    return _ida_dbg.get_bpt_qty(*args)

def getn_bpt(*args) -> "bool":
    r"""


    Get the characteristics of a breakpoint. \sq{Type, Synchronous
    function, Notification, none (synchronous function)}
    
    getn_bpt(n, bpt) -> bool
        @param n: number of breakpoint, is in range 0.. get_bpt_qty() -1 (C++:
                  int)
        @param bpt: filled with the characteristics. (C++: bpt_t  *)
        @return: false if no breakpoint exists
    """
    return _ida_dbg.getn_bpt(*args)

def get_bpt(*args) -> "bool":
    r"""


    Get the characteristics of a breakpoint. \sq{Type, Synchronous
    function, Notification, none (synchronous function)}
    
    get_bpt(ea, bpt) -> bool
        @param ea: any address in the breakpoint range (C++: ea_t)
        @param bpt: if not NULL, is filled with the characteristics. (C++:
                    bpt_t  *)
        @return: false if no breakpoint exists
    """
    return _ida_dbg.get_bpt(*args)

def exist_bpt(*args) -> "bool":
    r"""


    Does a breakpoint exist at the given location?
    
    exist_bpt(ea) -> bool
        @param ea (C++: ea_t)
    """
    return _ida_dbg.exist_bpt(*args)

def add_bpt(*args) -> "bool":
    r"""


    Add a new breakpoint in the debugged process. \sq{Type, Synchronous
    function - available as request, Notification, none (synchronous
    function)}Only one breakpoint can exist at a given address.
    
    add_bpt(ea, size=0, type=BPT_DEFAULT) -> bool
        @param ea: any address in the process memory space. Depending on the
                   architecture, hardware breakpoints always be setup at
                   random address. For example, on x86, hardware breakpoints
                   should be aligned depending on their size. Moreover, on the
                   x86 architecture, it is impossible to setup more than 4
                   hardware breakpoints. (C++: ea_t)
        @param size: size of the breakpoint (irrelevant for software
                     breakpoints): As for the address, hardware breakpoints
                     can't always be setup with random size. (C++: asize_t)
        @param type: type of the breakpoint ( BPT_SOFT  for software
                     breakpoint) special case  BPT_DEFAULT  ( BPT_SOFT |
                     BPT_EXEC ): try to add instruction breakpoint of the
                     appropriate type as follows: software bpt if supported,
                     hwbpt otherwise (C++: bpttype_t)
    

    add_bpt(bpt) -> bool
        bpt: bpt_t const &
    """
    return _ida_dbg.add_bpt(*args)

def request_add_bpt(*args) -> "bool":
    r"""


    Post an 'add_bpt(ea_t, asize_t, bpttype_t)' request.
    
    request_add_bpt(ea, size=0, type=BPT_DEFAULT) -> bool
        @param ea (C++: ea_t)
        @param size (C++: asize_t)
        @param type (C++: bpttype_t)
    

    request_add_bpt(bpt) -> bool
        bpt: bpt_t const &
    """
    return _ida_dbg.request_add_bpt(*args)

def del_bpt(*args) -> "bool":
    r"""


    Delete an existing breakpoint in the debugged process. \sq{Type,
    Synchronous function - available as request, Notification, none
    (synchronous function)}
    
    del_bpt(ea) -> bool
        @param ea: any address in the breakpoint range (C++: ea_t)
    

    del_bpt(bptloc) -> bool
        bptloc: bpt_location_t const &
    """
    return _ida_dbg.del_bpt(*args)

def request_del_bpt(*args) -> "bool":
    r"""


    Post a 'del_bpt(ea_t)' request.
    
    request_del_bpt(ea) -> bool
        @param ea (C++: ea_t)
    

    request_del_bpt(bptloc) -> bool
        bptloc: bpt_location_t const &
    """
    return _ida_dbg.request_del_bpt(*args)

def update_bpt(*args) -> "bool":
    r"""


    Update modifiable characteristics of an existing breakpoint. To update
    the breakpoint location, use 'change_bptlocs()' \sq{Type, Synchronous
    function, Notification, none (synchronous function)}Only the following
    fields can be modified: 'bpt_t::cndbody'  'bpt_t::pass_count'
    'bpt_t::flags'  'bpt_t::size'  'bpt_t::type' Changing some properties
    will require removing and then re-adding the breakpoint to the process
    memory (or the debugger backend), which can lead to race conditions
    (i.e., breakpoint(s) can be missed) in case the process is not
    suspended. Here are a list of scenarios that will require the
    breakpoint to be removed & then re-added: 'bpt_t::size' is modified
    'bpt_t::type' is modified 'bpt_t::flags' 's BPT_ENABLED is modified
    'bpt_t::flags' 's BPT_LOWCND is changed 'bpt_t::flags' 's BPT_LOWCND
    remains set, but cndbody changed
    
    update_bpt(bpt) -> bool
        @param bpt (C++: const  bpt_t  *)
    """
    return _ida_dbg.update_bpt(*args)

def find_bpt(*args) -> "bool":
    r"""


    Find a breakpoint by location. \sq{Type, Synchronous function -
    available as request, Notification, none (synchronous function)}
    
    find_bpt(bptloc, bpt) -> bool
        @param bptloc: Breakpoint location (C++: const  bpt_location_t  &)
        @param bpt: bpt is filled if the breakpoint was found (C++: bpt_t  *)
    """
    return _ida_dbg.find_bpt(*args)

def enable_bpt(*args) -> "bool":
    r"""


    enable_bpt(ea, enable=True) -> bool
        @param ea (C++: ea_t)
        @param enable (C++: bool)
    

    enable_bpt(bptloc, enable=True) -> bool
        bptloc: bpt_location_t const &
        @param enable (C++: bool)
    """
    return _ida_dbg.enable_bpt(*args)

def disable_bpt(*args) -> "bool":
    r"""


    disable_bpt(ea) -> bool
        @param ea (C++: ea_t)
    

    disable_bpt(bptloc) -> bool
        bptloc: bpt_location_t const &
    """
    return _ida_dbg.disable_bpt(*args)

def request_enable_bpt(*args) -> "bool":
    r"""


    request_enable_bpt(ea, enable=True) -> bool
        @param ea (C++: ea_t)
        @param enable (C++: bool)
    

    request_enable_bpt(bptloc, enable=True) -> bool
        bptloc: bpt_location_t const &
        @param enable (C++: bool)
    """
    return _ida_dbg.request_enable_bpt(*args)

def request_disable_bpt(*args) -> "bool":
    r"""


    request_disable_bpt(ea) -> bool
        @param ea (C++: ea_t)
    

    request_disable_bpt(bptloc) -> bool
        bptloc: bpt_location_t const &
    """
    return _ida_dbg.request_disable_bpt(*args)

def check_bpt(*args) -> "int":
    r"""


    Check the breakpoint at the specified address.
    
    check_bpt(ea) -> int
        @param ea (C++: ea_t)
        @return: one of  Breakpoint status codes
    """
    return _ida_dbg.check_bpt(*args)
BPTCK_NONE = _ida_dbg.BPTCK_NONE
"""
breakpoint does not exist
"""

BPTCK_NO = _ida_dbg.BPTCK_NO
"""
breakpoint is disabled
"""

BPTCK_YES = _ida_dbg.BPTCK_YES
"""
breakpoint is enabled
"""

BPTCK_ACT = _ida_dbg.BPTCK_ACT
"""
breakpoint is active (written to the process)
"""


def set_trace_size(*args) -> "bool":
    r"""


    Specify the new size of the circular buffer. \sq{Type, Synchronous
    function, Notification, none (synchronous function)}If you specify 0,
    all available memory can be quickly used !!!
    
    set_trace_size(size) -> bool
        @param size: if 0, buffer isn't circular and events are never removed.
                     If the new size is smaller than the existing number of
                     trace events, a corresponding number of trace events are
                     removed. (C++: int)
    """
    return _ida_dbg.set_trace_size(*args)

def clear_trace(*args) -> "void":
    r"""


    Clear all events in the trace buffer. \sq{Type, Synchronous function -
    available as request, Notification, none (synchronous function)}
    """
    return _ida_dbg.clear_trace(*args)

def request_clear_trace(*args) -> "void":
    r"""


    Post a 'clear_trace()' request.
    """
    return _ida_dbg.request_clear_trace(*args)

def is_step_trace_enabled(*args) -> "bool":
    r"""


    Get current state of step tracing. \sq{Type, Synchronous function,
    Notification, none (synchronous function)}
    """
    return _ida_dbg.is_step_trace_enabled(*args)

def enable_step_trace(*args) -> "bool":
    r"""


    enable_step_trace(enable=1) -> bool
        @param enable (C++: int)
    """
    return _ida_dbg.enable_step_trace(*args)

def disable_step_trace(*args) -> "bool":
    r"""
    disable_step_trace() -> bool
    """
    return _ida_dbg.disable_step_trace(*args)

def request_enable_step_trace(*args) -> "bool":
    r"""


    request_enable_step_trace(enable=1) -> bool
        @param enable (C++: int)
    """
    return _ida_dbg.request_enable_step_trace(*args)

def request_disable_step_trace(*args) -> "bool":
    r"""
    request_disable_step_trace() -> bool
    """
    return _ida_dbg.request_disable_step_trace(*args)
ST_OVER_DEBUG_SEG = _ida_dbg.ST_OVER_DEBUG_SEG
"""
step tracing will be disabled when IP is in a debugger segment
"""

ST_OVER_LIB_FUNC = _ida_dbg.ST_OVER_LIB_FUNC
"""
step tracing will be disabled when IP is in a library function
"""

ST_ALREADY_LOGGED = _ida_dbg.ST_ALREADY_LOGGED
"""
step tracing will be disabled when IP is already logged
"""

ST_SKIP_LOOPS = _ida_dbg.ST_SKIP_LOOPS
"""
step tracing will try to skip loops already recorded
"""

ST_DIFFERENTIAL = _ida_dbg.ST_DIFFERENTIAL
"""
tracing: log only new instructions (not previously logged)
"""

ST_OPTIONS_MASK = _ida_dbg.ST_OPTIONS_MASK
"""
mask of available options, to ensure compatibility with newer IDA
versions
"""

ST_OPTIONS_DEFAULT = _ida_dbg.ST_OPTIONS_DEFAULT

IT_LOG_SAME_IP = _ida_dbg.IT_LOG_SAME_IP
"""
specific options for instruction tracing (see
'set_insn_trace_options()' )

instruction tracing will log new instructions even when IP doesn't
change
"""

FT_LOG_RET = _ida_dbg.FT_LOG_RET
"""
specific options for function tracing (see 'set_func_trace_options()'
)

function tracing will log returning instructions
"""

BT_LOG_INSTS = _ida_dbg.BT_LOG_INSTS
"""
specific options for basic block tracing (see
'set_bblk_trace_options()' )

log all instructions in the current basic block
"""


def get_step_trace_options(*args) -> "int":
    r"""


    Get current step tracing options. \sq{Type, Synchronous function,
    Notification, none (synchronous function)}
    """
    return _ida_dbg.get_step_trace_options(*args)

def set_step_trace_options(*args) -> "void":
    r"""


    Modify step tracing options. \sq{Type, Synchronous function -
    available as request, Notification, none (synchronous function)}
    
    set_step_trace_options(options)
        @param options (C++: int)
    """
    return _ida_dbg.set_step_trace_options(*args)

def request_set_step_trace_options(*args) -> "void":
    r"""


    Post a 'set_step_trace_options()' request.
    
    request_set_step_trace_options(options)
        @param options (C++: int)
    """
    return _ida_dbg.request_set_step_trace_options(*args)

def is_insn_trace_enabled(*args) -> "bool":
    r"""


    Get current state of instruction tracing. \sq{Type, Synchronous
    function, Notification, none (synchronous function)}
    """
    return _ida_dbg.is_insn_trace_enabled(*args)

def enable_insn_trace(*args) -> "bool":
    r"""


    enable_insn_trace(enable=True) -> bool
        @param enable (C++: bool)
    """
    return _ida_dbg.enable_insn_trace(*args)

def disable_insn_trace(*args) -> "bool":
    r"""
    disable_insn_trace() -> bool
    """
    return _ida_dbg.disable_insn_trace(*args)

def request_enable_insn_trace(*args) -> "bool":
    r"""


    request_enable_insn_trace(enable=True) -> bool
        @param enable (C++: bool)
    """
    return _ida_dbg.request_enable_insn_trace(*args)

def request_disable_insn_trace(*args) -> "bool":
    r"""
    request_disable_insn_trace() -> bool
    """
    return _ida_dbg.request_disable_insn_trace(*args)

def get_insn_trace_options(*args) -> "int":
    r"""


    Get current instruction tracing options. Also see 'IT_LOG_SAME_IP'
    \sq{Type, Synchronous function, Notification, none (synchronous
    function)}
    """
    return _ida_dbg.get_insn_trace_options(*args)

def set_insn_trace_options(*args) -> "void":
    r"""


    Modify instruction tracing options. \sq{Type, Synchronous function -
    available as request, Notification, none (synchronous function)}
    
    set_insn_trace_options(options)
        @param options (C++: int)
    """
    return _ida_dbg.set_insn_trace_options(*args)

def request_set_insn_trace_options(*args) -> "void":
    r"""


    Post a 'set_insn_trace_options()' request.
    
    request_set_insn_trace_options(options)
        @param options (C++: int)
    """
    return _ida_dbg.request_set_insn_trace_options(*args)

def is_func_trace_enabled(*args) -> "bool":
    r"""


    Get current state of functions tracing. \sq{Type, Synchronous
    function, Notification, none (synchronous function)}
    """
    return _ida_dbg.is_func_trace_enabled(*args)

def enable_func_trace(*args) -> "bool":
    r"""


    enable_func_trace(enable=True) -> bool
        @param enable (C++: bool)
    """
    return _ida_dbg.enable_func_trace(*args)

def disable_func_trace(*args) -> "bool":
    r"""
    disable_func_trace() -> bool
    """
    return _ida_dbg.disable_func_trace(*args)

def request_enable_func_trace(*args) -> "bool":
    r"""


    request_enable_func_trace(enable=True) -> bool
        @param enable (C++: bool)
    """
    return _ida_dbg.request_enable_func_trace(*args)

def request_disable_func_trace(*args) -> "bool":
    r"""
    request_disable_func_trace() -> bool
    """
    return _ida_dbg.request_disable_func_trace(*args)

def get_func_trace_options(*args) -> "int":
    r"""


    Get current function tracing options. Also see 'FT_LOG_RET' \sq{Type,
    Synchronous function, Notification, none (synchronous function)}
    """
    return _ida_dbg.get_func_trace_options(*args)

def set_func_trace_options(*args) -> "void":
    r"""


    Modify function tracing options. \sq{Type, Synchronous function -
    available as request, Notification, none (synchronous function)}
    
    set_func_trace_options(options)
        @param options (C++: int)
    """
    return _ida_dbg.set_func_trace_options(*args)

def request_set_func_trace_options(*args) -> "void":
    r"""


    Post a 'set_func_trace_options()' request.
    
    request_set_func_trace_options(options)
        @param options (C++: int)
    """
    return _ida_dbg.request_set_func_trace_options(*args)

def enable_bblk_trace(*args) -> "bool":
    r"""


    enable_bblk_trace(enable=True) -> bool
        @param enable (C++: bool)
    """
    return _ida_dbg.enable_bblk_trace(*args)

def disable_bblk_trace(*args) -> "bool":
    r"""
    disable_bblk_trace() -> bool
    """
    return _ida_dbg.disable_bblk_trace(*args)

def request_enable_bblk_trace(*args) -> "bool":
    r"""


    request_enable_bblk_trace(enable=True) -> bool
        @param enable (C++: bool)
    """
    return _ida_dbg.request_enable_bblk_trace(*args)

def request_disable_bblk_trace(*args) -> "bool":
    r"""
    request_disable_bblk_trace() -> bool
    """
    return _ida_dbg.request_disable_bblk_trace(*args)

def is_bblk_trace_enabled(*args) -> "bool":
    r"""
    is_bblk_trace_enabled() -> bool
    """
    return _ida_dbg.is_bblk_trace_enabled(*args)

def get_bblk_trace_options(*args) -> "int":
    r"""


    Get current basic block tracing options. Also see 'BT_LOG_INSTS'
    \sq{Type, Synchronous function, Notification, none (synchronous
    function)}
    """
    return _ida_dbg.get_bblk_trace_options(*args)

def set_bblk_trace_options(*args) -> "void":
    r"""


    Modify basic block tracing options (see 'BT_LOG_INSTS' )
    
    set_bblk_trace_options(options)
        @param options (C++: int)
    """
    return _ida_dbg.set_bblk_trace_options(*args)

def request_set_bblk_trace_options(*args) -> "void":
    r"""


    Post a 'set_bblk_trace_options()' request.
    
    request_set_bblk_trace_options(options)
        @param options (C++: int)
    """
    return _ida_dbg.request_set_bblk_trace_options(*args)
tev_none = _ida_dbg.tev_none

tev_insn = _ida_dbg.tev_insn

tev_call = _ida_dbg.tev_call

tev_ret = _ida_dbg.tev_ret

tev_bpt = _ida_dbg.tev_bpt

tev_mem = _ida_dbg.tev_mem

tev_event = _ida_dbg.tev_event

tev_max = _ida_dbg.tev_max

class tev_info_t(object):
    r"""
    Proxy of C++ tev_info_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    type = property(_ida_dbg.tev_info_t_type_get, _ida_dbg.tev_info_t_type_set)
    tid = property(_ida_dbg.tev_info_t_tid_get, _ida_dbg.tev_info_t_tid_set)
    ea = property(_ida_dbg.tev_info_t_ea_get, _ida_dbg.tev_info_t_ea_set)

    def __init__(self, *args):
        r"""
        __init__(self) -> tev_info_t
        """
        _ida_dbg.tev_info_t_swiginit(self, _ida_dbg.new_tev_info_t(*args))
    __swig_destroy__ = _ida_dbg.delete_tev_info_t

# Register tev_info_t in _ida_dbg:
_ida_dbg.tev_info_t_swigregister(tev_info_t)

class memreg_info_t(object):
    r"""
    Proxy of C++ memreg_info_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    ea = property(_ida_dbg.memreg_info_t_ea_get, _ida_dbg.memreg_info_t_ea_set)

    def get_bytes(self, *args) -> "PyObject *":
        r"""
        get_bytes(self) -> PyObject *
        """
        return _ida_dbg.memreg_info_t_get_bytes(self, *args)

    bytes = property(get_bytes)


    def __init__(self, *args):
        r"""
        __init__(self) -> memreg_info_t
        """
        _ida_dbg.memreg_info_t_swiginit(self, _ida_dbg.new_memreg_info_t(*args))
    __swig_destroy__ = _ida_dbg.delete_memreg_info_t

# Register memreg_info_t in _ida_dbg:
_ida_dbg.memreg_info_t_swigregister(memreg_info_t)


def get_tev_qty(*args) -> "int":
    r"""


    Get number of trace events available in trace buffer. \sq{Type,
    Synchronous function, Notification, none (synchronous function)}
    """
    return _ida_dbg.get_tev_qty(*args)

def get_tev_info(*args) -> "bool":
    r"""


    Get main information about a trace event. \sq{Type, Synchronous
    function, Notification, none (synchronous function)}
    
    get_tev_info(n, tev_info) -> bool
        @param n: number of trace event, is in range 0.. get_tev_qty() -1. 0
                  represents the latest added trace event. (C++: int)
        @param tev_info: result (C++: tev_info_t  *)
        @return: success
    """
    return _ida_dbg.get_tev_info(*args)

def get_insn_tev_reg_val(*args) -> "bool":
    r"""


    Read a register value from an instruction trace event. \sq{Type,
    Synchronous function, Notification, none (synchronous function)}This
    is the value of the register before the execution of the instruction.
    
    get_insn_tev_reg_val(n, regname, regval) -> bool
        @param n: number of trace event, is in range 0.. get_tev_qty() -1. 0
                  represents the latest added trace event. (C++: int)
        @param regname: name of desired register (C++: const char *)
        @param regval: result (C++: regval_t  *)
        @return: false if not an instruction event.
    """
    return _ida_dbg.get_insn_tev_reg_val(*args)

def get_insn_tev_reg_mem(*args) -> "bool":
    r"""


    Read the memory pointed by register values from an instruction trace
    event. \sq{Type, Synchronous function, Notification, none (synchronous
    function)}
    
    get_insn_tev_reg_mem(n, memmap) -> bool
        @param n: number of trace event, is in range 0.. get_tev_qty() -1. 0
                  represents the latest added trace event. (C++: int)
        @param memmap: result (C++: memreg_infos_t  *)
        @return: false if not an instruction event or no memory is available
    """
    return _ida_dbg.get_insn_tev_reg_mem(*args)

def get_insn_tev_reg_result(*args) -> "bool":
    r"""


    Read the resulting register value from an instruction trace event.
    \sq{Type, Synchronous function, Notification, none (synchronous
    function)}
    
    get_insn_tev_reg_result(n, regname, regval) -> bool
        @param n: number of trace event, is in range 0.. get_tev_qty() -1. 0
                  represents the latest added trace event. (C++: int)
        @param regname: name of desired register (C++: const char *)
        @param regval: result (C++: regval_t  *)
        @return: false if not an instruction trace event or register wasn't
                 modified.
    """
    return _ida_dbg.get_insn_tev_reg_result(*args)

def get_call_tev_callee(*args) -> "ea_t":
    r"""


    Get the called function from a function call trace event. \sq{Type,
    Synchronous function, Notification, none (synchronous function)}
    
    get_call_tev_callee(n) -> ea_t
        @param n: number of trace event, is in range 0.. get_tev_qty() -1. 0
                  represents the latest added trace event. (C++: int)
        @return: BADADDR  if not a function call event.
    """
    return _ida_dbg.get_call_tev_callee(*args)

def get_ret_tev_return(*args) -> "ea_t":
    r"""


    Get the return address from a function return trace event. \sq{Type,
    Synchronous function, Notification, none (synchronous function)}
    
    get_ret_tev_return(n) -> ea_t
        @param n: number of trace event, is in range 0.. get_tev_qty() -1. 0
                  represents the latest added trace event. (C++: int)
        @return: BADADDR  if not a function return event.
    """
    return _ida_dbg.get_ret_tev_return(*args)

def get_bpt_tev_ea(*args) -> "ea_t":
    r"""


    Get the address associated to a read, read/write or execution trace
    event. \sq{Type, Synchronous function, Notification, none (synchronous
    function)}Usually, a breakpoint is associated with a read, read/write
    or execution trace event. However, the returned address could be any
    address in the range of this breakpoint. If the breakpoint was deleted
    after the trace event, the address no longer corresponds to a valid
    breakpoint.
    
    get_bpt_tev_ea(n) -> ea_t
        @param n: number of trace event, is in range 0.. get_tev_qty() -1. 0
                  represents the latest added trace event. (C++: int)
        @return: BADADDR  if not a read, read/write or execution trace event.
    """
    return _ida_dbg.get_bpt_tev_ea(*args)

def get_tev_memory_info(*args) -> "bool":
    r"""


    Get the memory layout, if any, for the specified tev object. \sq{Type,
    Synchronous function, Notification, none (synchronous function)}
    
    get_tev_memory_info(n, mi) -> bool
        @param n: number of trace event, is in range 0.. get_tev_qty() -1. 0
                  represents the latest added trace event. (C++: int)
        @param mi: result (C++: meminfo_vec_t  *)
        @return: false if the tev_t object is not of type  tev_mem , true
                 otherwise, with the new memory layout in "mi".
    """
    return _ida_dbg.get_tev_memory_info(*args)

def get_tev_event(*args) -> "bool":
    r"""


    Get the corresponding debug event, if any, for the specified tev
    object. \sq{Type, Synchronous function, Notification, none
    (synchronous function)}
    
    get_tev_event(n, d) -> bool
        @param n: number of trace event, is in range 0.. get_tev_qty() -1. 0
                  represents the latest added trace event. (C++: int)
        @param d: result (C++: debug_event_t  *)
        @return: false if the tev_t object doesn't have any associated debug
                 event, true otherwise, with the debug event in "d".
    """
    return _ida_dbg.get_tev_event(*args)

def get_trace_base_address(*args) -> "ea_t":
    r"""


    Get the base address of the current trace. \sq{Type, Synchronous
    function, Notification, none (synchronous function)}
    """
    return _ida_dbg.get_trace_base_address(*args)

def set_trace_base_address(*args) -> "void":
    r"""


    Set the base address of the current trace. \sq{Type, Synchronous
    function, Notification, none (synchronous function)}
    
    set_trace_base_address(ea)
        @param ea (C++: ea_t)
    """
    return _ida_dbg.set_trace_base_address(*args)

def dbg_add_thread(*args) -> "void":
    r"""


    Add a thread to the current trace. \sq{Type, Synchronous function,
    Notification, none (synchronous function)}
    
    dbg_add_thread(tid)
        @param tid (C++: thid_t)
    """
    return _ida_dbg.dbg_add_thread(*args)

def dbg_del_thread(*args) -> "void":
    r"""


    Delete a thread from the current trace. \sq{Type, Synchronous
    function, Notification, none (synchronous function)}
    
    dbg_del_thread(tid)
        @param tid (C++: thid_t)
    """
    return _ida_dbg.dbg_del_thread(*args)

def dbg_add_tev(*args) -> "void":
    r"""


    Add a new trace element to the current trace. \sq{Type, Synchronous
    function, Notification, none (synchronous function)}
    
    dbg_add_tev(type, tid, address)
        @param type (C++: tev_type_t)
        @param tid (C++: thid_t)
        @param address (C++: ea_t)
    """
    return _ida_dbg.dbg_add_tev(*args)
class tev_reg_value_t(object):
    r"""
    Proxy of C++ tev_reg_value_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    value = property(_ida_dbg.tev_reg_value_t_value_get, _ida_dbg.tev_reg_value_t_value_set)
    reg_idx = property(_ida_dbg.tev_reg_value_t_reg_idx_get, _ida_dbg.tev_reg_value_t_reg_idx_set)

    def __init__(self, *args):
        r"""


        __init__(self, _reg_idx=-1, _value=uint64(-1)) -> tev_reg_value_t
            _reg_idx: int
            _value: uint64
        """
        _ida_dbg.tev_reg_value_t_swiginit(self, _ida_dbg.new_tev_reg_value_t(*args))
    __swig_destroy__ = _ida_dbg.delete_tev_reg_value_t

# Register tev_reg_value_t in _ida_dbg:
_ida_dbg.tev_reg_value_t_swigregister(tev_reg_value_t)

class tev_info_reg_t(object):
    r"""
    Proxy of C++ tev_info_reg_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    info = property(_ida_dbg.tev_info_reg_t_info_get, _ida_dbg.tev_info_reg_t_info_set)
    registers = property(_ida_dbg.tev_info_reg_t_registers_get, _ida_dbg.tev_info_reg_t_registers_set)

    def __init__(self, *args):
        r"""
        __init__(self) -> tev_info_reg_t
        """
        _ida_dbg.tev_info_reg_t_swiginit(self, _ida_dbg.new_tev_info_reg_t(*args))
    __swig_destroy__ = _ida_dbg.delete_tev_info_reg_t

# Register tev_info_reg_t in _ida_dbg:
_ida_dbg.tev_info_reg_t_swigregister(tev_info_reg_t)

SAVE_ALL_VALUES = _ida_dbg.SAVE_ALL_VALUES

SAVE_DIFF = _ida_dbg.SAVE_DIFF

SAVE_NONE = _ida_dbg.SAVE_NONE


def dbg_add_many_tevs(*args) -> "bool":
    r"""


    Add many new trace elements to the current trace. \sq{Type,
    Synchronous function, Notification, none (synchronous function)}
    
    dbg_add_many_tevs(new_tevs) -> bool
        @param new_tevs (C++: tevinforeg_vec_t  *)
        @return: false if the operation failed for any  tev_info_t  object
    """
    return _ida_dbg.dbg_add_many_tevs(*args)

def dbg_add_insn_tev(*args) -> "bool":
    r"""


    Add a new instruction trace element to the current trace. \sq{Type,
    Synchronous function, Notification, none (synchronous function)}
    
    dbg_add_insn_tev(tid, ea, save=SAVE_DIFF) -> bool
        @param tid (C++: thid_t)
        @param ea (C++: ea_t)
        @param save (C++: save_reg_values_t)
        @return: false if the operation failed, true otherwise
    """
    return _ida_dbg.dbg_add_insn_tev(*args)

def dbg_add_bpt_tev(*args) -> "bool":
    r"""


    Add a new breakpoint trace element to the current trace. \sq{Type,
    Synchronous function, Notification, none (synchronous function)}
    
    dbg_add_bpt_tev(tid, ea, bp) -> bool
        @param tid (C++: thid_t)
        @param ea (C++: ea_t)
        @param bp (C++: ea_t)
        @return: false if the operation failed, true otherwise
    """
    return _ida_dbg.dbg_add_bpt_tev(*args)

def dbg_add_call_tev(*args) -> "void":
    r"""


    Add a new call trace element to the current trace. \sq{Type,
    Synchronous function, Notification, none (synchronous function)}
    
    dbg_add_call_tev(tid, caller, callee)
        @param tid (C++: thid_t)
        @param caller (C++: ea_t)
        @param callee (C++: ea_t)
    """
    return _ida_dbg.dbg_add_call_tev(*args)

def dbg_add_ret_tev(*args) -> "void":
    r"""


    Add a new return trace element to the current trace. \sq{Type,
    Synchronous function, Notification, none (synchronous function)}
    
    dbg_add_ret_tev(tid, ret_insn, return_to)
        @param tid (C++: thid_t)
        @param ret_insn (C++: ea_t)
        @param return_to (C++: ea_t)
    """
    return _ida_dbg.dbg_add_ret_tev(*args)

def dbg_add_debug_event(*args) -> "void":
    r"""


    Add a new debug event to the current trace. \sq{Type, Synchronous
    function, Notification, none (synchronous function)}
    
    dbg_add_debug_event(event)
        @param event (C++: debug_event_t  *)
    """
    return _ida_dbg.dbg_add_debug_event(*args)

def load_trace_file(*args) -> "qstring *":
    r"""


    Load a recorded trace file in the trace window. If the call succeeds
    and 'buf' is not null, the description of the trace stored in the
    binary trace file will be returned in 'buf'
    
    load_trace_file(filename) -> str
        @param filename (C++: const char *)
    """
    return _ida_dbg.load_trace_file(*args)

def save_trace_file(*args) -> "bool":
    r"""


    Save the current trace in the specified file.
    
    save_trace_file(filename, description) -> bool
        @param filename (C++: const char *)
        @param description (C++: const char *)
    """
    return _ida_dbg.save_trace_file(*args)

def is_valid_trace_file(*args) -> "bool":
    r"""


    Is the specified file a valid trace file for the current database?
    
    is_valid_trace_file(filename) -> bool
        @param filename (C++: const char *)
    """
    return _ida_dbg.is_valid_trace_file(*args)

def set_trace_file_desc(*args) -> "bool":
    r"""


    Change the description of the specified trace file.
    
    set_trace_file_desc(filename, description) -> bool
        @param filename (C++: const char *)
        @param description (C++: const char *)
    """
    return _ida_dbg.set_trace_file_desc(*args)

def get_trace_file_desc(*args) -> "qstring *":
    r"""


    Get the file header of the specified trace file.
    
    get_trace_file_desc(filename) -> str
        @param filename (C++: const char *)
    """
    return _ida_dbg.get_trace_file_desc(*args)

def choose_trace_file(*args) -> "qstring *":
    r"""


    Show the choose trace dialog.
    """
    return _ida_dbg.choose_trace_file(*args)

def diff_trace_file(*args) -> "bool":
    r"""


    Show difference between the current trace and the one from 'filename'.
    
    diff_trace_file(filename) -> bool
        @param filename (C++: const char *)
    """
    return _ida_dbg.diff_trace_file(*args)

def graph_trace(*args) -> "bool":
    r"""


    Show the trace callgraph.
    """
    return _ida_dbg.graph_trace(*args)

def set_highlight_trace_options(*args) -> "void":
    r"""


    Set highlight trace parameters.
    
    set_highlight_trace_options(hilight, color, diff)
        @param hilight (C++: bool)
        @param color (C++: bgcolor_t)
        @param diff (C++: bgcolor_t)
    """
    return _ida_dbg.set_highlight_trace_options(*args)

def set_trace_platform(*args) -> "void":
    r"""


    Set platform name of current trace.
    
    set_trace_platform(platform)
        @param platform (C++: const char *)
    """
    return _ida_dbg.set_trace_platform(*args)

def get_trace_platform(*args) -> "char const *":
    r"""


    Get platform name of current trace.
    """
    return _ida_dbg.get_trace_platform(*args)

def set_trace_dynamic_register_set(*args) -> "void":
    r"""


    Set dynamic register set of current trace.
    
    set_trace_dynamic_register_set(idaregs)
        @param idaregs (C++: dynamic_register_set_t  &)
    """
    return _ida_dbg.set_trace_dynamic_register_set(*args)

def get_trace_dynamic_register_set(*args) -> "void":
    r"""


    Get dynamic register set of current trace.
    
    get_trace_dynamic_register_set(idaregs)
        @param idaregs (C++: dynamic_register_set_t  *)
    """
    return _ida_dbg.get_trace_dynamic_register_set(*args)
DEC_NOTASK = _ida_dbg.DEC_NOTASK

DEC_ERROR = _ida_dbg.DEC_ERROR

DEC_TIMEOUT = _ida_dbg.DEC_TIMEOUT

WFNE_ANY = _ida_dbg.WFNE_ANY
"""
return the first event (even if it doesn't suspend the process)
"""

WFNE_SUSP = _ida_dbg.WFNE_SUSP
"""
wait until the process gets suspended
"""

WFNE_SILENT = _ida_dbg.WFNE_SILENT
"""
1: be slient, 0:display modal boxes if necessary
"""

WFNE_CONT = _ida_dbg.WFNE_CONT
"""
continue from the suspended state
"""

WFNE_NOWAIT = _ida_dbg.WFNE_NOWAIT
"""
(to be used with 'WFNE_CONT' )

do not wait for any event, immediately return 'DEC_TIMEOUT'
"""

WFNE_USEC = _ida_dbg.WFNE_USEC
"""
(minimum non-zero timeout is 40000us)

timeout is specified in microseconds
"""

DOPT_SEGM_MSGS = _ida_dbg.DOPT_SEGM_MSGS
"""
log debugger segments modifications
"""

DOPT_START_BPT = _ida_dbg.DOPT_START_BPT
"""
break on process start
"""

DOPT_THREAD_MSGS = _ida_dbg.DOPT_THREAD_MSGS
"""
log thread starts/exits
"""

DOPT_THREAD_BPT = _ida_dbg.DOPT_THREAD_BPT
"""
break on thread start/exit
"""

DOPT_BPT_MSGS = _ida_dbg.DOPT_BPT_MSGS
"""
log breakpoints
"""

DOPT_LIB_MSGS = _ida_dbg.DOPT_LIB_MSGS
"""
log library loads/unloads
"""

DOPT_LIB_BPT = _ida_dbg.DOPT_LIB_BPT
"""
break on library load/unload
"""

DOPT_INFO_MSGS = _ida_dbg.DOPT_INFO_MSGS
"""
log debugging info events
"""

DOPT_INFO_BPT = _ida_dbg.DOPT_INFO_BPT
"""
break on debugging information
"""

DOPT_REAL_MEMORY = _ida_dbg.DOPT_REAL_MEMORY
"""
do not hide breakpoint instructions
"""

DOPT_REDO_STACK = _ida_dbg.DOPT_REDO_STACK
"""
reconstruct the stack
"""

DOPT_ENTRY_BPT = _ida_dbg.DOPT_ENTRY_BPT
"""
break on program entry point
"""

DOPT_EXCDLG = _ida_dbg.DOPT_EXCDLG
"""
exception dialogs:
"""

EXCDLG_NEVER = _ida_dbg.EXCDLG_NEVER
"""
never display exception dialogs
"""

EXCDLG_UNKNOWN = _ida_dbg.EXCDLG_UNKNOWN
"""
display for unknown exceptions
"""

EXCDLG_ALWAYS = _ida_dbg.EXCDLG_ALWAYS
"""
always display
"""

DOPT_LOAD_DINFO = _ida_dbg.DOPT_LOAD_DINFO
"""
automatically load debug files (pdb)
"""

DOPT_END_BPT = _ida_dbg.DOPT_END_BPT
"""
evaluate event condition on process end
"""

DOPT_TEMP_HWBPT = _ida_dbg.DOPT_TEMP_HWBPT
"""
when possible use hardware bpts for temp bpts
"""


def wait_for_next_event(*args) -> "dbg_event_code_t":
    r"""


    Wait for the next event.This function (optionally) resumes the process
    execution, and waits for a debugger event until a possible timeout
    occurs.
    
    wait_for_next_event(wfne, timeout) -> dbg_event_code_t
        @param wfne: combination of  Wait for debugger event flags  constants
                     (C++: int)
        @param timeout: number of seconds to wait, -1-infinity (C++: int)
        @return: either an event_id_t (if > 0), or a dbg_event_code_t (if <=
                 0)
    """
    return _ida_dbg.wait_for_next_event(*args)

def get_debug_event(*args) -> "debug_event_t const *":
    r"""


    Get the current debugger event.
    """
    return _ida_dbg.get_debug_event(*args)

def set_debugger_options(*args) -> "uint":
    r"""


    Set debugger options. Replaces debugger options with the specification
    combination 'Debugger options'
    
    set_debugger_options(options) -> uint
        @param options (C++: uint)
        @return: the old debugger options
    """
    return _ida_dbg.set_debugger_options(*args)

def set_remote_debugger(*args) -> "void":
    r"""


    Set remote debugging options. Should be used before starting the
    debugger.
    
    set_remote_debugger(host, _pass, port=-1)
        @param host: If empty, IDA will use local debugger. If NULL, the host
                     will not be set. (C++: const char *)
        pass: char const *
        @param port: If -1, the default port number will be used (C++: int)
    """
    return _ida_dbg.set_remote_debugger(*args)

def get_process_options(*args) -> "qstring *, qstring *, qstring *, qstring *, qstring *, int *":
    r"""


    Get process options. Any of the arguments may be NULL
    """
    return _ida_dbg.get_process_options(*args)

def set_process_options(*args) -> "void":
    r"""


    Set process options. Any of the arguments may be NULL, which means 'do
    not modify'
    
    set_process_options(path, args, sdir, host, _pass, port)
        @param path (C++: const char *)
        @param args (C++: const char *)
        @param sdir (C++: const char *)
        @param host (C++: const char *)
        pass: char const *
        @param port (C++: int)
    """
    return _ida_dbg.set_process_options(*args)

def retrieve_exceptions(*args) -> "excvec_t *":
    r"""


    Retrieve the exception information. You may freely modify the returned
    vector and add/edit/delete exceptions You must call
    'store_exceptions()' after any modifications Note: exceptions with
    code zero, multiple exception codes or names are prohibited
    """
    return _ida_dbg.retrieve_exceptions(*args)

def store_exceptions(*args) -> "bool":
    r"""


    Update the exception information stored in the debugger module by
    invoking its dbg->set_exception_info callback
    """
    return _ida_dbg.store_exceptions(*args)

def define_exception(*args) -> "char const *":
    r"""


    Convenience function: define new exception code.
    
    define_exception(code, name, desc, flags) -> char const *
        @param code: exception code (cannot be 0) (C++: uint)
        @param name: exception name (cannot be empty or NULL) (C++: const char
                     *)
        @param desc: exception description (maybe NULL) (C++: const char *)
        @param flags: combination of  Exception info flags (C++: int)
        @return: failure message or NULL. You must call  store_exceptions()
                 if this function succeeds
    """
    return _ida_dbg.define_exception(*args)
class eval_ctx_t(object):
    r"""
    Proxy of C++ eval_ctx_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        __init__(self, _ea) -> eval_ctx_t
            _ea: ea_t
        """
        _ida_dbg.eval_ctx_t_swiginit(self, _ida_dbg.new_eval_ctx_t(*args))
    ea = property(_ida_dbg.eval_ctx_t_ea_get, _ida_dbg.eval_ctx_t_ea_set)
    __swig_destroy__ = _ida_dbg.delete_eval_ctx_t

# Register eval_ctx_t in _ida_dbg:
_ida_dbg.eval_ctx_t_swigregister(eval_ctx_t)

SRCIT_NONE = _ida_dbg.SRCIT_NONE

SRCIT_MODULE = _ida_dbg.SRCIT_MODULE

SRCIT_FUNC = _ida_dbg.SRCIT_FUNC

SRCIT_STMT = _ida_dbg.SRCIT_STMT

SRCIT_EXPR = _ida_dbg.SRCIT_EXPR

SRCIT_STTVAR = _ida_dbg.SRCIT_STTVAR

SRCIT_LOCVAR = _ida_dbg.SRCIT_LOCVAR

SRCDBG_PROV_VERSION = _ida_dbg.SRCDBG_PROV_VERSION


def create_source_viewer(*args) -> "source_view_t *":
    r"""


    Create a source code view.
    
    create_source_viewer(out_ccv, parent, custview, sf, lines, lnnum, colnum, flags) -> source_view_t *
        @param out_ccv (C++: TWidget **)
        @param parent (C++: TWidget *)
        @param custview (C++: TWidget *)
        @param sf (C++: source_file_ptr)
        @param lines (C++: strvec_t  *)
        @param lnnum (C++: int)
        @param colnum (C++: int)
        @param flags (C++: int)
    """
    return _ida_dbg.create_source_viewer(*args)

def get_dbg_byte(*args) -> "bool":
    r"""


    Get one byte of the debugged process memory.
    
    get_dbg_byte(x, ea) -> bool
        @param x: pointer to byte value (C++: uint32  *)
        @param ea: linear address (C++: ea_t)
        @return: true success
    """
    return _ida_dbg.get_dbg_byte(*args)

def put_dbg_byte(*args) -> "bool":
    r"""


    Change one byte of the debugged process memory.
    
    put_dbg_byte(ea, x) -> bool
        @param ea: linear address (C++: ea_t)
        @param x: byte value (C++: uint32)
        @return: true if the process memory has been modified
    """
    return _ida_dbg.put_dbg_byte(*args)

def invalidate_dbgmem_config(*args) -> "void":
    r"""


    Invalidate the debugged process memory configuration. Call this
    function if the debugged process might have changed its memory layout
    (allocated more memory, for example)
    """
    return _ida_dbg.invalidate_dbgmem_config(*args)

def invalidate_dbgmem_contents(*args) -> "void":
    r"""


    Invalidate the debugged process memory contents. Call this function
    each time the process has been stopped or the process memory is
    modified. If ea == 'BADADDR' , then the whole memory contents will be
    invalidated
    
    invalidate_dbgmem_contents(ea, size)
        @param ea (C++: ea_t)
        @param size (C++: asize_t)
    """
    return _ida_dbg.invalidate_dbgmem_contents(*args)

def is_debugger_on(*args) -> "bool":
    r"""


    Is the debugger currently running?
    """
    return _ida_dbg.is_debugger_on(*args)

def is_debugger_memory(*args) -> "bool":
    r"""


    Is the address mapped to debugger memory?
    
    is_debugger_memory(ea) -> bool
        @param ea (C++: ea_t)
    """
    return _ida_dbg.is_debugger_memory(*args)

def get_tev_ea(*args) -> "ea_t":
    r"""


    get_tev_ea(n) -> ea_t
        @param n (C++: int)
    """
    return _ida_dbg.get_tev_ea(*args)

def get_tev_type(*args) -> "int":
    r"""


    get_tev_type(n) -> int
        @param n (C++: int)
    """
    return _ida_dbg.get_tev_type(*args)

def get_tev_tid(*args) -> "int":
    r"""


    get_tev_tid(n) -> int
        @param n (C++: int)
    """
    return _ida_dbg.get_tev_tid(*args)

def get_module_info(*args) -> "bool":
    r"""


    get_module_info(ea, modinfo) -> bool
        @param ea (C++: ea_t)
        @param modinfo (C++: modinfo_t  *)
    """
    return _ida_dbg.get_module_info(*args)

def bring_debugger_to_front(*args) -> "void":
    r"""
    bring_debugger_to_front()
    """
    return _ida_dbg.bring_debugger_to_front(*args)

def collect_stack_trace(*args) -> "bool":
    r"""


    collect_stack_trace(tid, trace) -> bool
        @param tid (C++: thid_t)
        @param trace (C++: call_stack_t  *)
    """
    return _ida_dbg.collect_stack_trace(*args)

def get_debugger_event_cond(*args) -> "char const *":
    r"""
    get_debugger_event_cond() -> char const *
    """
    return _ida_dbg.get_debugger_event_cond(*args)

def set_debugger_event_cond(*args) -> "void":
    r"""


    set_debugger_event_cond(evcond)
        @param evcond (C++: const char *)
    """
    return _ida_dbg.set_debugger_event_cond(*args)

def load_debugger(*args) -> "bool":
    r"""


    load_debugger(dbgname, use_remote) -> bool
        @param dbgname (C++: const char *)
        @param use_remote (C++: bool)
    """
    return _ida_dbg.load_debugger(*args)

def set_manual_regions(*args) -> "void":
    r"""


    set_manual_regions(ranges)
        @param ranges (C++: const  meminfo_vec_t  *)
    """
    return _ida_dbg.set_manual_regions(*args)

def edit_manual_regions(*args) -> "void":
    r"""
    edit_manual_regions()
    """
    return _ida_dbg.edit_manual_regions(*args)

def enable_manual_regions(*args) -> "void":
    r"""


    enable_manual_regions(enable)
        @param enable (C++: bool)
    """
    return _ida_dbg.enable_manual_regions(*args)

def hide_all_bpts(*args) -> "int":
    r"""
    hide_all_bpts() -> int
    """
    return _ida_dbg.hide_all_bpts(*args)

def handle_debug_event(*args) -> "int":
    r"""


    handle_debug_event(ev, rqflags) -> int
        @param ev (C++: const  debug_event_t  *)
        @param rqflags (C++: int)
    """
    return _ida_dbg.handle_debug_event(*args)

def add_virt_module(*args) -> "bool":
    r"""


    add_virt_module(mod) -> bool
        @param mod (C++: const  modinfo_t  *)
    """
    return _ida_dbg.add_virt_module(*args)

def del_virt_module(*args) -> "bool":
    r"""


    del_virt_module(base) -> bool
        @param base (C++: const ea_t)
    """
    return _ida_dbg.del_virt_module(*args)

def internal_ioctl(*args) -> "int":
    r"""


    internal_ioctl(fn, buf, poutbuf, poutsize) -> int
        @param fn (C++: int)
        @param buf (C++: const void *)
        @param poutbuf (C++: void **)
        @param poutsize (C++: ssize_t  *)
    """
    return _ida_dbg.internal_ioctl(*args)

def read_dbg_memory(*args) -> "ssize_t":
    r"""


    read_dbg_memory(ea, buffer, size) -> ssize_t
        @param ea (C++: ea_t)
        @param buffer (C++: void *)
        @param size (C++: size_t)
    """
    return _ida_dbg.read_dbg_memory(*args)

def get_reg_vals(*args) -> "int":
    r"""


    get_reg_vals(tid, clsmask, values) -> int
        @param tid (C++: thid_t)
        @param clsmask (C++: int)
        @param values (C++: regval_t  *)
    """
    return _ida_dbg.get_reg_vals(*args)

def get_dbg_memory_info(*args) -> "int":
    r"""


    get_dbg_memory_info(ranges) -> int
        @param ranges (C++: meminfo_vec_t  *)
    """
    return _ida_dbg.get_dbg_memory_info(*args)

def set_bpt_group(*args) -> "void":
    r"""


    set_bpt_group(bpt, grp_name)
        @param bpt (C++: bpt_t  &)
        @param grp_name (C++: const char *)
    """
    return _ida_dbg.set_bpt_group(*args)

def set_bptloc_group(*args) -> "bool":
    r"""


    set_bptloc_group(bptloc, grp_name) -> bool
        @param bptloc (C++: const  bpt_location_t  &)
        @param grp_name (C++: const char *)
    """
    return _ida_dbg.set_bptloc_group(*args)

def get_bpt_group(*args) -> "qstring *":
    r"""


    get_bpt_group(bptloc) -> str
        @param bptloc (C++: const  bpt_location_t  &)
    """
    return _ida_dbg.get_bpt_group(*args)

def rename_bptgrp(*args) -> "bool":
    r"""


    rename_bptgrp(old_name, new_name) -> bool
        @param old_name (C++: const char *)
        @param new_name (C++: const char *)
    """
    return _ida_dbg.rename_bptgrp(*args)

def del_bptgrp(*args) -> "bool":
    r"""


    del_bptgrp(name) -> bool
        @param name (C++: const char *)
    """
    return _ida_dbg.del_bptgrp(*args)

def get_grp_bpts(*args) -> "ssize_t":
    r"""


    get_grp_bpts(bpts, grp_name) -> ssize_t
        @param bpts (C++: bpt_vec_t  *)
        @param grp_name (C++: const char *)
    """
    return _ida_dbg.get_grp_bpts(*args)

def get_srcinfo_provider(*args) -> "srcinfo_provider_t *":
    r"""


    get_srcinfo_provider(name) -> srcinfo_provider_t *
        @param name (C++: const char *)
    """
    return _ida_dbg.get_srcinfo_provider(*args)

def get_global_var(*args) -> "bool":
    r"""


    get_global_var(prov, ea, name, out) -> bool
        @param prov (C++: srcinfo_provider_t  *)
        @param ea (C++: ea_t)
        @param name (C++: const char *)
        @param out (C++: source_item_ptr  *)
    """
    return _ida_dbg.get_global_var(*args)

def get_local_var(*args) -> "bool":
    r"""


    get_local_var(prov, ea, name, out) -> bool
        @param prov (C++: srcinfo_provider_t  *)
        @param ea (C++: ea_t)
        @param name (C++: const char *)
        @param out (C++: source_item_ptr  *)
    """
    return _ida_dbg.get_local_var(*args)

def get_local_vars(*args) -> "bool":
    r"""


    get_local_vars(prov, ea, out) -> bool
        @param prov (C++: srcinfo_provider_t  *)
        @param ea (C++: ea_t)
        @param out (C++: source_items_t  *)
    """
    return _ida_dbg.get_local_vars(*args)

def add_path_mapping(*args) -> "void":
    r"""


    add_path_mapping(src, dst)
        @param src (C++: const char *)
        @param dst (C++: const char *)
    """
    return _ida_dbg.add_path_mapping(*args)

def get_current_source_file(*args) -> "qstring *":
    r"""
    get_current_source_file() -> str
    """
    return _ida_dbg.get_current_source_file(*args)

def get_current_source_line(*args) -> "int":
    r"""
    get_current_source_line() -> int
    """
    return _ida_dbg.get_current_source_line(*args)

def srcdbg_step_into(*args) -> "bool":
    r"""
    srcdbg_step_into() -> bool
    """
    return _ida_dbg.srcdbg_step_into(*args)

def srcdbg_request_step_into(*args) -> "bool":
    r"""
    srcdbg_request_step_into() -> bool
    """
    return _ida_dbg.srcdbg_request_step_into(*args)

def srcdbg_step_over(*args) -> "bool":
    r"""
    srcdbg_step_over() -> bool
    """
    return _ida_dbg.srcdbg_step_over(*args)

def srcdbg_request_step_over(*args) -> "bool":
    r"""
    srcdbg_request_step_over() -> bool
    """
    return _ida_dbg.srcdbg_request_step_over(*args)

def srcdbg_step_until_ret(*args) -> "bool":
    r"""
    srcdbg_step_until_ret() -> bool
    """
    return _ida_dbg.srcdbg_step_until_ret(*args)

def srcdbg_request_step_until_ret(*args) -> "bool":
    r"""
    srcdbg_request_step_until_ret() -> bool
    """
    return _ida_dbg.srcdbg_request_step_until_ret(*args)

def dbg_bin_search(*args) -> "uint64 *, qstring *":
    r"""


    dbg_bin_search(start_ea, end_ea, data, srch_flags) -> str
        @param start_ea (C++: ea_t)
        @param end_ea (C++: ea_t)
        @param data (C++: const  compiled_binpat_vec_t  &)
        @param srch_flags (C++: int)
    """
    return _ida_dbg.dbg_bin_search(*args)

def get_manual_regions(*args) -> "PyObject *":
    r"""


    get_manual_regions(ranges)
    Returns the manual memory regions
    @return: list(start_ea, end_ea, name, sclass, sbase, bitness, perm)
    """
    return _ida_dbg.get_manual_regions(*args)

def dbg_is_loaded(*args) -> "bool":
    r"""


    dbg_is_loaded() -> bool
    Checks if a debugger is loaded
    @return: Boolean
    """
    return _ida_dbg.dbg_is_loaded(*args)

def refresh_debugger_memory(*args) -> "PyObject *":
    r"""


    refresh_debugger_memory() -> PyObject *
    Refreshes the debugger memory
    @return: Nothing
    """
    return _ida_dbg.refresh_debugger_memory(*args)
class DBG_Hooks(object):
    r"""
    Proxy of C++ DBG_Hooks class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        __init__(self, _flags=0) -> DBG_Hooks
            _flags: uint32
        """
        if self.__class__ == DBG_Hooks:
            _self = None
        else:
            _self = self
        _ida_dbg.DBG_Hooks_swiginit(self, _ida_dbg.new_DBG_Hooks(_self, *args))

    def hook(self, *args) -> "bool":
        r"""
        hook(self) -> bool
        """
        return _ida_dbg.DBG_Hooks_hook(self, *args)

    def unhook(self, *args) -> "bool":
        r"""
        unhook(self) -> bool
        """
        return _ida_dbg.DBG_Hooks_unhook(self, *args)

    def dbg_process_start(self, *args) -> "void":
        r"""


        This event notification is also an asynchronous function result
        notification for 'start_process()' !
        
        dbg_process_start(self, pid, tid, ea, modinfo_name, modinfo_base, modinfo_size)
            pid: pid_t
            tid: thid_t
            ea: ea_t
            modinfo_name: char const *
            modinfo_base: ea_t
            modinfo_size: asize_t
        """
        return _ida_dbg.DBG_Hooks_dbg_process_start(self, *args)

    def dbg_process_exit(self, *args) -> "void":
        r"""


        This event notification is also an asynchronous function result
        notification for 'start_process()' !
        
        dbg_process_exit(self, pid, tid, ea, exit_code)
            pid: pid_t
            tid: thid_t
            ea: ea_t
            exit_code: int
        """
        return _ida_dbg.DBG_Hooks_dbg_process_exit(self, *args)

    def dbg_process_attach(self, *args) -> "void":
        r"""


        This event notification is also an asynchronous function result
        notification for 'start_process()' !
        
        dbg_process_attach(self, pid, tid, ea, modinfo_name, modinfo_base, modinfo_size)
            pid: pid_t
            tid: thid_t
            ea: ea_t
            modinfo_name: char const *
            modinfo_base: ea_t
            modinfo_size: asize_t
        """
        return _ida_dbg.DBG_Hooks_dbg_process_attach(self, *args)

    def dbg_process_detach(self, *args) -> "void":
        r"""


        This event notification is also an asynchronous function result
        notification for 'start_process()' !
        
        dbg_process_detach(self, pid, tid, ea)
            pid: pid_t
            tid: thid_t
            ea: ea_t
        """
        return _ida_dbg.DBG_Hooks_dbg_process_detach(self, *args)

    def dbg_thread_start(self, *args) -> "void":
        r"""


        dbg_thread_start(self, pid, tid, ea)
            pid: pid_t
            tid: thid_t
            ea: ea_t
        """
        return _ida_dbg.DBG_Hooks_dbg_thread_start(self, *args)

    def dbg_thread_exit(self, *args) -> "void":
        r"""


        dbg_thread_exit(self, pid, tid, ea, exit_code)
            pid: pid_t
            tid: thid_t
            ea: ea_t
            exit_code: int
        """
        return _ida_dbg.DBG_Hooks_dbg_thread_exit(self, *args)

    def dbg_library_load(self, *args) -> "void":
        r"""


        dbg_library_load(self, pid, tid, ea, modinfo_name, modinfo_base, modinfo_size)
            pid: pid_t
            tid: thid_t
            ea: ea_t
            modinfo_name: char const *
            modinfo_base: ea_t
            modinfo_size: asize_t
        """
        return _ida_dbg.DBG_Hooks_dbg_library_load(self, *args)

    def dbg_library_unload(self, *args) -> "void":
        r"""


        dbg_library_unload(self, pid, tid, ea, info)
            pid: pid_t
            tid: thid_t
            ea: ea_t
            info: char const *
        """
        return _ida_dbg.DBG_Hooks_dbg_library_unload(self, *args)

    def dbg_information(self, *args) -> "void":
        r"""


        dbg_information(self, pid, tid, ea, info)
            pid: pid_t
            tid: thid_t
            ea: ea_t
            info: char const *
        """
        return _ida_dbg.DBG_Hooks_dbg_information(self, *args)

    def dbg_exception(self, *args) -> "int":
        r"""


        dbg_exception(self, pid, tid, ea, exc_code, exc_can_cont, exc_ea, exc_info) -> int
            pid: pid_t
            tid: thid_t
            ea: ea_t
            exc_code: int
            exc_can_cont: bool
            exc_ea: ea_t
            exc_info: char const *
        """
        return _ida_dbg.DBG_Hooks_dbg_exception(self, *args)

    def dbg_suspend_process(self, *args) -> "void":
        r"""


        The process is now suspended.This event notification is also an
        asynchronous function result notification for 'suspend_process()' !
        """
        return _ida_dbg.DBG_Hooks_dbg_suspend_process(self, *args)

    def dbg_bpt(self, *args) -> "int":
        r"""


        A user defined breakpoint was reached.
        
        dbg_bpt(self, tid, bptea) -> int
            @param tid (C++: thid_t)
            @param bptea (C++: ea_t)
        """
        return _ida_dbg.DBG_Hooks_dbg_bpt(self, *args)

    def dbg_trace(self, *args) -> "int":
        r"""


        A step occurred (one instruction was executed). This event
        notification is only generated if step tracing is enabled.
        
        dbg_trace(self, tid, ip) -> int
            @param tid: thread ID  (C++: thid_t)
            @param ip: current instruction pointer. usually points after the
                       executed instruction  (C++: ea_t)
            @retval: 1 - do not log this trace event
            @retval: 0 - log it
        """
        return _ida_dbg.DBG_Hooks_dbg_trace(self, *args)

    def dbg_request_error(self, *args) -> "void":
        r"""


        An error occurred during the processing of a request.
        
        dbg_request_error(self, failed_command, failed_dbg_notification)
            @param failed_command (C++: ui_notification_t)
            @param failed_dbg_notification (C++: dbg_notification_t)
        """
        return _ida_dbg.DBG_Hooks_dbg_request_error(self, *args)

    def dbg_step_into(self, *args) -> "void":
        r"""
        dbg_step_into(self)
        """
        return _ida_dbg.DBG_Hooks_dbg_step_into(self, *args)

    def dbg_step_over(self, *args) -> "void":
        r"""
        dbg_step_over(self)
        """
        return _ida_dbg.DBG_Hooks_dbg_step_over(self, *args)

    def dbg_run_to(self, *args) -> "void":
        r"""


        dbg_run_to(self, pid, tid, ea)
            pid: pid_t
            tid: thid_t
            ea: ea_t
        """
        return _ida_dbg.DBG_Hooks_dbg_run_to(self, *args)

    def dbg_step_until_ret(self, *args) -> "void":
        r"""
        dbg_step_until_ret(self)
        """
        return _ida_dbg.DBG_Hooks_dbg_step_until_ret(self, *args)

    def dbg_bpt_changed(self, *args) -> "void":
        r"""


        Breakpoint has been changed.
        
        dbg_bpt_changed(self, bptev_code, bpt)
            @param bptev_code: Breakpoint modification events  (C++: int)
            @param bpt (C++: bpt_t *)
        """
        return _ida_dbg.DBG_Hooks_dbg_bpt_changed(self, *args)

    def dbg_started_loading_bpts(self, *args) -> "void":
        r"""


        Started loading breakpoint info from idb.
        """
        return _ida_dbg.DBG_Hooks_dbg_started_loading_bpts(self, *args)

    def dbg_finished_loading_bpts(self, *args) -> "void":
        r"""


        Finished loading breakpoint info from idb.
        """
        return _ida_dbg.DBG_Hooks_dbg_finished_loading_bpts(self, *args)
    __swig_destroy__ = _ida_dbg.delete_DBG_Hooks
    def __disown__(self):
        self.this.disown()
        _ida_dbg.disown_DBG_Hooks(self)
        return weakref.proxy(self)

# Register DBG_Hooks in _ida_dbg:
_ida_dbg.DBG_Hooks_swigregister(DBG_Hooks)


def list_bptgrps(*args) -> "PyObject *":
    r"""


    list_bptgrps(bptgrps) -> size_t
        @param bptgrps (C++: qstrvec_t  *)
    """
    return _ida_dbg.list_bptgrps(*args)

def move_bpt_to_grp(*args) -> "void":
    r"""


    move_bpt_to_grp(bpt, grp_name)
    Sets new group for the breakpoint
    """
    return _ida_dbg.move_bpt_to_grp(*args)

def internal_get_sreg_base(*args) -> "ea_t":
    r"""


    internal_get_sreg_base(tid, sreg_value) -> ea_t
    Get the sreg base, for the given thread.
    
    @return: The sreg base, or BADADDR on failure.
    """
    return _ida_dbg.internal_get_sreg_base(*args)

def write_dbg_memory(*args) -> "ssize_t":
    r"""


    write_dbg_memory(ea, py_buf, size=size_t(-1)) -> ssize_t
        @param ea (C++: ea_t)
        py_buf: PyObject *
        @param size (C++: size_t)
    """
    return _ida_dbg.write_dbg_memory(*args)

def dbg_can_query(*args) -> "bool":
    r"""


    dbg_can_query() -> bool
    This function can be used to check if the debugger can be queried:
      - debugger is loaded
      - process is suspended
      - process is not suspended but can take requests. In this case some requests like
        memory read/write, bpt management succeed and register querying will fail.
        Check if idaapi.get_process_state() < 0 to tell if the process is suspended
    @return: Boolean
    """
    return _ida_dbg.dbg_can_query(*args)

def set_reg_val(*args) -> "PyObject *":
    r"""


    Write a register value to the current thread. \sq{Type, Synchronous
    function - available as Request, Notification, none (synchronous
    function)}
    
    set_reg_val(regname, o) -> PyObject
        @param regname (C++: const char *)
        o: PyObject *
    

    set_reg_val(tid, regidx, o) -> PyObject *
        tid: thid_t
        regidx: int
        o: PyObject *
    """
    return _ida_dbg.set_reg_val(*args)

def request_set_reg_val(*args) -> "PyObject *":
    r"""


    Post a 'set_reg_val()' request.
    
    request_set_reg_val(regname, o) -> PyObject *
        @param regname (C++: const char *)
        o: PyObject *
    """
    return _ida_dbg.request_set_reg_val(*args)

def get_reg_val(*args) -> "PyObject *":
    r"""


    Read a register value from the current thread. \sq{Type, Synchronous
    function, Notification, none (synchronous function)}
    
    get_reg_val(regname, regval) -> bool
        @param regname (C++: const char *)
        @param regval (C++: regval_t  *)
    

    get_reg_val(regname, ival) -> bool
        @param regname (C++: const char *)
        ival: uint64 *
    

    get_reg_val(regname) -> PyObject *
        @param regname (C++: const char *)
    """
    return _ida_dbg.get_reg_val(*args)

#<pycode(py_dbg)>
import ida_idaapi
import ida_idd
import ida_expr

def get_tev_reg_val(tev, reg):
    rv = ida_idd.regval_t()
    if get_insn_tev_reg_val(tev, reg, rv):
        if rv.rvtype == ida_idd.RVT_INT:
            return rv.ival

def get_tev_reg_mem_qty(tev):
    ti = tev_info_t()
    if get_tev_info(tev, ti):
        mis = memreg_infos_t()
        if get_insn_tev_reg_mem(tev, mis):
            return mis.size()

def get_tev_reg_mem(tev, idx):
    mis = memreg_infos_t()
    if get_insn_tev_reg_mem(tev, mis):
        if idx < mis.size():
            return mis[idx].bytes

def get_tev_reg_mem_ea(tev, idx):
    ti = tev_info_t()
    if get_tev_info(tev, ti):
        mis = memreg_infos_t()
        if get_insn_tev_reg_mem(tev, mis):
            if idx >= 0 and idx < mis.size():
                return mis[idx].ea

def send_dbg_command(command):
    """


        Send a direct command to the debugger backend, and
        retrieve the result as a string.
    
        Note: any double-quotes in 'command' must be backslash-escaped.
        Note: this only works with some debugger backends: Bochs, WinDbg, GDB.
    
        Returns: (True, <result string>) on success, or (False, <Error message string>) on failure
    """
    rv = ida_expr.idc_value_t()
    err = ida_expr.eval_idc_expr(rv, ida_idaapi.BADADDR, """send_dbg_command("%s");""" % command)
    if err:
        return False, "eval_idc_expr() failed: %s" % err
    vtype = ord(rv.vtype)
    if vtype == ida_expr.VT_STR:
        s = rv.c_str()
        if "IDC_FAILURE" in s:
            return False, "eval_idc_expr() reported an error: %s" % s
        return True, s
    elif vtype == ida_expr.VT_LONG:
        return True, str(rv.num)
    else:
        return False, "eval_idc_expr(): wrong return type: %d" % vtype

#</pycode(py_dbg)>


if _BC695:
    import ida_idd
    def get_process_info(n, pi):
        pis = ida_idd.procinfo_vec_t()
        cnt = get_processes(pis)
        if n >= cnt:
            return ida_idd.NO_PROCESS
        pi.name = pis[n].name
        pi.pid = pis[n].pid
        return pi.pid
    def get_process_qty():
        pis = ida_idd.procinfo_vec_t()
        return get_processes(pis)



