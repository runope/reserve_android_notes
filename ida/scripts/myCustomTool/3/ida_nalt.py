# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.1
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

"""
IDA Plugin SDK API wrapper: nalt
"""

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _ida_nalt
else:
    import _ida_nalt

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """
    Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass
    """
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """
    Meta class to enforce nondynamic attributes (no new attributes) for a class
    """
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import weakref

SWIG_PYTHON_LEGACY_BOOL = _ida_nalt.SWIG_PYTHON_LEGACY_BOOL

import ida_idaapi


import sys
_BC695 = sys.modules["__main__"].IDAPYTHON_COMPAT_695_API

if _BC695:






    def bc695redef(func):
        ida_idaapi._BC695.replace_fun(func)
        return func

class custom_data_type_ids_fids_array(object):
    r"""
    Proxy of C++ wrapped_array_t< int16,8 > class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    data = property(_ida_nalt.custom_data_type_ids_fids_array_data_get)

    def __init__(self, *args):
        r"""


        __init__(self, data) -> custom_data_type_ids_fids_array
            data: short (&)[8]
        """
        _ida_nalt.custom_data_type_ids_fids_array_swiginit(self, _ida_nalt.new_custom_data_type_ids_fids_array(*args))

    def __len__(self, *args) -> "size_t":
        r"""
        __len__(self) -> size_t
        """
        return _ida_nalt.custom_data_type_ids_fids_array___len__(self, *args)

    def __getitem__(self, *args) -> "short const &":
        r"""


        __getitem__(self, i) -> short const &
            i: size_t
        """
        return _ida_nalt.custom_data_type_ids_fids_array___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        r"""


        __setitem__(self, i, v)
            i: size_t
            v: short const &
        """
        return _ida_nalt.custom_data_type_ids_fids_array___setitem__(self, *args)

    __iter__ = ida_idaapi._bounded_getitem_iterator

    __swig_destroy__ = _ida_nalt.delete_custom_data_type_ids_fids_array

# Register custom_data_type_ids_fids_array in _ida_nalt:
_ida_nalt.custom_data_type_ids_fids_array_swigregister(custom_data_type_ids_fids_array)

class strpath_ids_array(object):
    r"""
    Proxy of C++ wrapped_array_t< tid_t,32 > class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    data = property(_ida_nalt.strpath_ids_array_data_get)

    def __init__(self, *args):
        r"""


        __init__(self, data) -> strpath_ids_array
            data: unsigned long long (&)[32]
        """
        _ida_nalt.strpath_ids_array_swiginit(self, _ida_nalt.new_strpath_ids_array(*args))

    def __len__(self, *args) -> "size_t":
        r"""
        __len__(self) -> size_t
        """
        return _ida_nalt.strpath_ids_array___len__(self, *args)

    def __getitem__(self, *args) -> "unsigned long long const &":
        r"""


        __getitem__(self, i) -> unsigned long long const &
            i: size_t
        """
        return _ida_nalt.strpath_ids_array___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        r"""


        __setitem__(self, i, v)
            i: size_t
            v: unsigned long long const &
        """
        return _ida_nalt.strpath_ids_array___setitem__(self, *args)

    __iter__ = ida_idaapi._bounded_getitem_iterator

    __swig_destroy__ = _ida_nalt.delete_strpath_ids_array

# Register strpath_ids_array in _ida_nalt:
_ida_nalt.strpath_ids_array_swigregister(strpath_ids_array)

NALT_SWITCH = _ida_nalt.NALT_SWITCH
"""
switch idiom address (used at jump targets)
"""

NALT_STRUCT = _ida_nalt.NALT_STRUCT
"""
struct id
"""

NALT_AFLAGS = _ida_nalt.NALT_AFLAGS
"""
additional flags for an item
"""

NALT_LINNUM = _ida_nalt.NALT_LINNUM
"""
source line number
"""

NALT_ABSBASE = _ida_nalt.NALT_ABSBASE
"""
absolute segment location
"""

NALT_ENUM0 = _ida_nalt.NALT_ENUM0
"""
enum id for the first operand
"""

NALT_ENUM1 = _ida_nalt.NALT_ENUM1
"""
enum id for the second operand
"""

NALT_PURGE = _ida_nalt.NALT_PURGE
"""
number of bytes purged from the stack when a function is called
indirectly
"""

NALT_STRTYPE = _ida_nalt.NALT_STRTYPE
"""
type of string item
"""

NALT_ALIGN = _ida_nalt.NALT_ALIGN
"""
(should by equal to power of 2)

alignment value if the item is 'FF_ALIGN'
"""

NALT_COLOR = _ida_nalt.NALT_COLOR
"""
instruction/data background color
"""

NSUP_CMT = _ida_nalt.NSUP_CMT
"""
regular comment
"""

NSUP_REPCMT = _ida_nalt.NSUP_REPCMT
"""
repeatable comment
"""

NSUP_FOP1 = _ida_nalt.NSUP_FOP1
"""
forced operand 1
"""

NSUP_FOP2 = _ida_nalt.NSUP_FOP2
"""
forced operand 2
"""

NSUP_JINFO = _ida_nalt.NSUP_JINFO
"""
jump table info
"""

NSUP_ARRAY = _ida_nalt.NSUP_ARRAY
"""
array parameters
"""

NSUP_OMFGRP = _ida_nalt.NSUP_OMFGRP
"""
OMF: group of segments (not used anymore)
"""

NSUP_FOP3 = _ida_nalt.NSUP_FOP3
"""
forced operand 3
"""

NSUP_SWITCH = _ida_nalt.NSUP_SWITCH
"""
switch information
"""

NSUP_REF0 = _ida_nalt.NSUP_REF0
"""
complex reference information for operand 1
"""

NSUP_REF1 = _ida_nalt.NSUP_REF1
"""
complex reference information for operand 2
"""

NSUP_REF2 = _ida_nalt.NSUP_REF2
"""
complex reference information for operand 3
"""

NSUP_OREF0 = _ida_nalt.NSUP_OREF0
"""
outer complex reference information for operand 1
"""

NSUP_OREF1 = _ida_nalt.NSUP_OREF1
"""
outer complex reference information for operand 2
"""

NSUP_OREF2 = _ida_nalt.NSUP_OREF2
"""
outer complex reference information for operand 3
"""

NSUP_STROFF0 = _ida_nalt.NSUP_STROFF0
"""
stroff: struct path for the first operand
"""

NSUP_STROFF1 = _ida_nalt.NSUP_STROFF1
"""
stroff: struct path for the second operand
"""

NSUP_SEGTRANS = _ida_nalt.NSUP_SEGTRANS
"""
segment translations
"""

NSUP_FOP4 = _ida_nalt.NSUP_FOP4
"""
forced operand 4
"""

NSUP_FOP5 = _ida_nalt.NSUP_FOP5
"""
forced operand 5
"""

NSUP_FOP6 = _ida_nalt.NSUP_FOP6
"""
forced operand 6
"""

NSUP_REF3 = _ida_nalt.NSUP_REF3
"""
complex reference information for operand 4
"""

NSUP_REF4 = _ida_nalt.NSUP_REF4
"""
complex reference information for operand 5
"""

NSUP_REF5 = _ida_nalt.NSUP_REF5
"""
complex reference information for operand 6
"""

NSUP_OREF3 = _ida_nalt.NSUP_OREF3
"""
outer complex reference information for operand 4
"""

NSUP_OREF4 = _ida_nalt.NSUP_OREF4
"""
outer complex reference information for operand 5
"""

NSUP_OREF5 = _ida_nalt.NSUP_OREF5
"""
outer complex reference information for operand 6
"""

NSUP_XREFPOS = _ida_nalt.NSUP_XREFPOS
"""
saved xref address and type in the xrefs window
"""

NSUP_CUSTDT = _ida_nalt.NSUP_CUSTDT
"""
custom data type id
"""

NSUP_GROUPS = _ida_nalt.NSUP_GROUPS
"""
SEG_GRP: pack_dd encoded list of selectors.
"""

NSUP_ARGEAS = _ida_nalt.NSUP_ARGEAS
"""
instructions that initialize call arguments
"""

NSUP_FOP7 = _ida_nalt.NSUP_FOP7
"""
forced operand 7
"""

NSUP_FOP8 = _ida_nalt.NSUP_FOP8
"""
forced operand 8
"""

NSUP_REF6 = _ida_nalt.NSUP_REF6
"""
complex reference information for operand 7
"""

NSUP_REF7 = _ida_nalt.NSUP_REF7
"""
complex reference information for operand 8
"""

NSUP_OREF6 = _ida_nalt.NSUP_OREF6
"""
outer complex reference information for operand 7
"""

NSUP_OREF7 = _ida_nalt.NSUP_OREF7
"""
outer complex reference information for operand 8
"""

NSUP_POINTS = _ida_nalt.NSUP_POINTS
"""
SP change points blob (see funcs.cpp). values
NSUP_POINTS..NSUP_POINTS+0x1000 are reserved
"""

NSUP_MANUAL = _ida_nalt.NSUP_MANUAL
"""
manual instruction. values NSUP_MANUAL..NSUP_MANUAL+0x1000 are
reserved
"""

NSUP_TYPEINFO = _ida_nalt.NSUP_TYPEINFO
"""
type information. values NSUP_TYPEINFO..NSUP_TYPEINFO+0x1000 are
reserved
"""

NSUP_REGVAR = _ida_nalt.NSUP_REGVAR
"""
register variables. values NSUP_REGVAR..NSUP_REGVAR+0x1000 are
reserved
"""

NSUP_LLABEL = _ida_nalt.NSUP_LLABEL
"""
local labels. values NSUP_LLABEL..NSUP_LLABEL+0x1000 are reserved
"""

NSUP_REGARG = _ida_nalt.NSUP_REGARG
"""
register argument type/name descriptions values
NSUP_REGARG..NSUP_REGARG+0x1000 are reserved
"""

NSUP_FTAILS = _ida_nalt.NSUP_FTAILS
"""
function tails or tail referers values NSUP_FTAILS..NSUP_FTAILS+0x1000
are reserved
"""

NSUP_GROUP = _ida_nalt.NSUP_GROUP
"""
graph group information values NSUP_GROUP..NSUP_GROUP+0x1000 are
reserved
"""

NSUP_OPTYPES = _ida_nalt.NSUP_OPTYPES
"""
operand type information. values NSUP_OPTYPES..NSUP_OPTYPES+0x100000
are reserved
"""

NSUP_ORIGFMD = _ida_nalt.NSUP_ORIGFMD
"""
function metadata before lumina information was applied values
NSUP_ORIGFMD..NSUP_ORIGFMD+0x1000 are reserved
"""

NALT_CREF_TO = _ida_nalt.NALT_CREF_TO
"""
code xref to, idx: target address
"""

NALT_CREF_FROM = _ida_nalt.NALT_CREF_FROM
"""
code xref from, idx: source address
"""

NALT_DREF_TO = _ida_nalt.NALT_DREF_TO
"""
data xref to, idx: target address
"""

NALT_DREF_FROM = _ida_nalt.NALT_DREF_FROM
"""
data xref from, idx: source address
"""

NSUP_GR_INFO = _ida_nalt.NSUP_GR_INFO
"""
group node info: color, ea, text
"""

NALT_GR_LAYX = _ida_nalt.NALT_GR_LAYX
"""
group layout ptrs, hash: md5 of 'belongs'
"""

NSUP_GR_LAYT = _ida_nalt.NSUP_GR_LAYT
"""
group layouts, idx: layout pointer
"""

PATCH_TAG = _ida_nalt.PATCH_TAG
"""
Patch netnode tag.
"""


def ea2node(*args) -> "nodeidx_t":
    r"""


    Get netnode for the specified address.
    
    ea2node(ea) -> nodeidx_t
        @param ea (C++: ea_t)
    """
    return _ida_nalt.ea2node(*args)

def node2ea(*args) -> "ea_t":
    r"""


    node2ea(ndx) -> ea_t
        @param ndx (C++: nodeidx_t)
    """
    return _ida_nalt.node2ea(*args)

def getnode(*args) -> "netnode":
    r"""


    getnode(ea) -> netnode
        @param ea (C++: ea_t)
    """
    return _ida_nalt.getnode(*args)
AFL_LINNUM = _ida_nalt.AFL_LINNUM
"""
has line number info
"""

AFL_USERSP = _ida_nalt.AFL_USERSP
"""
user-defined SP value
"""

AFL_PUBNAM = _ida_nalt.AFL_PUBNAM
"""
name is public (inter-file linkage)
"""

AFL_WEAKNAM = _ida_nalt.AFL_WEAKNAM
"""
name is weak
"""

AFL_HIDDEN = _ida_nalt.AFL_HIDDEN
"""
the item is hidden completely
"""

AFL_MANUAL = _ida_nalt.AFL_MANUAL
"""
the instruction/data is specified by the user
"""

AFL_NOBRD = _ida_nalt.AFL_NOBRD
"""
the code/data border is hidden
"""

AFL_ZSTROFF = _ida_nalt.AFL_ZSTROFF
"""
display struct field name at 0 offset when displaying an offset.
example: \\v{offset somestruct.field_0} if this flag is clear, then
\\v{offset somestruct}
"""

AFL_BNOT0 = _ida_nalt.AFL_BNOT0
"""
the 1st operand is bitwise negated
"""

AFL_BNOT1 = _ida_nalt.AFL_BNOT1
"""
the 2nd operand is bitwise negated
"""

AFL_LIB = _ida_nalt.AFL_LIB
"""
item from the standard library. low level flag, is used to set
'FUNC_LIB' of 'func_t'
"""

AFL_TI = _ida_nalt.AFL_TI
"""
has typeinfo? ( 'NSUP_TYPEINFO' )
"""

AFL_TI0 = _ida_nalt.AFL_TI0
"""
has typeinfo for operand 0? ( 'NSUP_OPTYPES' )
"""

AFL_TI1 = _ida_nalt.AFL_TI1
"""
has typeinfo for operand 1? ( 'NSUP_OPTYPES' +1)
"""

AFL_LNAME = _ida_nalt.AFL_LNAME
"""
has local name too ( 'FF_NAME' should be set)
"""

AFL_TILCMT = _ida_nalt.AFL_TILCMT
"""
has type comment? (such a comment may be changed by IDA)
"""

AFL_LZERO0 = _ida_nalt.AFL_LZERO0
"""
toggle leading zeroes for the 1st operand
"""

AFL_LZERO1 = _ida_nalt.AFL_LZERO1
"""
toggle leading zeroes for the 2nd operand
"""

AFL_COLORED = _ida_nalt.AFL_COLORED
"""
has user defined instruction color?
"""

AFL_TERSESTR = _ida_nalt.AFL_TERSESTR
"""
terse structure variable display?
"""

AFL_SIGN0 = _ida_nalt.AFL_SIGN0
"""
code: toggle sign of the 1st operand
"""

AFL_SIGN1 = _ida_nalt.AFL_SIGN1
"""
code: toggle sign of the 2nd operand
"""

AFL_NORET = _ida_nalt.AFL_NORET
"""
for imported function pointers: doesn't return. this flag can also be
used for any instruction which halts or finishes the program execution
"""

AFL_FIXEDSPD = _ida_nalt.AFL_FIXEDSPD
"""
should not be modified by modules

sp delta value is fixed by analysis.
"""

AFL_ALIGNFLOW = _ida_nalt.AFL_ALIGNFLOW
"""
the previous insn was created for alignment purposes only
"""

AFL_USERTI = _ida_nalt.AFL_USERTI
"""
(comes from the user or type library)

the type information is definitive.
"""

AFL_RETFP = _ida_nalt.AFL_RETFP
"""
function returns a floating point value
"""

AFL_USEMODSP = _ida_nalt.AFL_USEMODSP
"""
example: pop [rsp+N]

insn modifes SP and uses the modified value
"""

AFL_NOTCODE = _ida_nalt.AFL_NOTCODE
"""
autoanalysis should not create code here
"""

AFL_NOTPROC = _ida_nalt.AFL_NOTPROC
"""
autoanalysis should not create proc here
"""


def set_aflags(*args) -> "void":
    r"""


    set_aflags(ea, flags)
        @param ea (C++: ea_t)
        @param flags (C++: uint32)
    """
    return _ida_nalt.set_aflags(*args)

def set_abits(*args) -> "void":
    r"""


    set_abits(ea, bits)
        @param ea (C++: ea_t)
        @param bits (C++: uint32)
    """
    return _ida_nalt.set_abits(*args)

def clr_abits(*args) -> "void":
    r"""


    clr_abits(ea, bits)
        @param ea (C++: ea_t)
        @param bits (C++: uint32)
    """
    return _ida_nalt.clr_abits(*args)

def get_aflags(*args) -> "uint32":
    r"""


    get_aflags(ea) -> uint32
        @param ea (C++: ea_t)
    """
    return _ida_nalt.get_aflags(*args)

def del_aflags(*args) -> "void":
    r"""


    del_aflags(ea)
        @param ea (C++: ea_t)
    """
    return _ida_nalt.del_aflags(*args)

def is_hidden_item(*args) -> "bool":
    r"""


    is_hidden_item(ea) -> bool
        @param ea (C++: ea_t)
    """
    return _ida_nalt.is_hidden_item(*args)

def hide_item(*args) -> "void":
    r"""


    hide_item(ea)
        @param ea (C++: ea_t)
    """
    return _ida_nalt.hide_item(*args)

def unhide_item(*args) -> "void":
    r"""


    unhide_item(ea)
        @param ea (C++: ea_t)
    """
    return _ida_nalt.unhide_item(*args)

def is_hidden_border(*args) -> "bool":
    r"""


    is_hidden_border(ea) -> bool
        @param ea (C++: ea_t)
    """
    return _ida_nalt.is_hidden_border(*args)

def hide_border(*args) -> "void":
    r"""


    hide_border(ea)
        @param ea (C++: ea_t)
    """
    return _ida_nalt.hide_border(*args)

def unhide_border(*args) -> "void":
    r"""


    unhide_border(ea)
        @param ea (C++: ea_t)
    """
    return _ida_nalt.unhide_border(*args)

def uses_modsp(*args) -> "bool":
    r"""


    uses_modsp(ea) -> bool
        @param ea (C++: ea_t)
    """
    return _ida_nalt.uses_modsp(*args)

def set_usemodsp(*args) -> "void":
    r"""


    set_usemodsp(ea)
        @param ea (C++: ea_t)
    """
    return _ida_nalt.set_usemodsp(*args)

def clr_usemodsp(*args) -> "void":
    r"""


    clr_usemodsp(ea)
        @param ea (C++: ea_t)
    """
    return _ida_nalt.clr_usemodsp(*args)

def is_zstroff(*args) -> "bool":
    r"""


    is_zstroff(ea) -> bool
        @param ea (C++: ea_t)
    """
    return _ida_nalt.is_zstroff(*args)

def set_zstroff(*args) -> "void":
    r"""


    set_zstroff(ea)
        @param ea (C++: ea_t)
    """
    return _ida_nalt.set_zstroff(*args)

def clr_zstroff(*args) -> "void":
    r"""


    clr_zstroff(ea)
        @param ea (C++: ea_t)
    """
    return _ida_nalt.clr_zstroff(*args)

def is__bnot0(*args) -> "bool":
    r"""


    is__bnot0(ea) -> bool
        @param ea (C++: ea_t)
    """
    return _ida_nalt.is__bnot0(*args)

def set__bnot0(*args) -> "void":
    r"""


    set__bnot0(ea)
        @param ea (C++: ea_t)
    """
    return _ida_nalt.set__bnot0(*args)

def clr__bnot0(*args) -> "void":
    r"""


    clr__bnot0(ea)
        @param ea (C++: ea_t)
    """
    return _ida_nalt.clr__bnot0(*args)

def is__bnot1(*args) -> "bool":
    r"""


    is__bnot1(ea) -> bool
        @param ea (C++: ea_t)
    """
    return _ida_nalt.is__bnot1(*args)

def set__bnot1(*args) -> "void":
    r"""


    set__bnot1(ea)
        @param ea (C++: ea_t)
    """
    return _ida_nalt.set__bnot1(*args)

def clr__bnot1(*args) -> "void":
    r"""


    clr__bnot1(ea)
        @param ea (C++: ea_t)
    """
    return _ida_nalt.clr__bnot1(*args)

def is_libitem(*args) -> "bool":
    r"""


    is_libitem(ea) -> bool
        @param ea (C++: ea_t)
    """
    return _ida_nalt.is_libitem(*args)

def set_libitem(*args) -> "void":
    r"""


    set_libitem(ea)
        @param ea (C++: ea_t)
    """
    return _ida_nalt.set_libitem(*args)

def clr_libitem(*args) -> "void":
    r"""


    clr_libitem(ea)
        @param ea (C++: ea_t)
    """
    return _ida_nalt.clr_libitem(*args)

def has_ti(*args) -> "bool":
    r"""


    has_ti(ea) -> bool
        @param ea (C++: ea_t)
    """
    return _ida_nalt.has_ti(*args)

def set_has_ti(*args) -> "void":
    r"""


    set_has_ti(ea)
        @param ea (C++: ea_t)
    """
    return _ida_nalt.set_has_ti(*args)

def clr_has_ti(*args) -> "void":
    r"""


    clr_has_ti(ea)
        @param ea (C++: ea_t)
    """
    return _ida_nalt.clr_has_ti(*args)

def has_ti0(*args) -> "bool":
    r"""


    has_ti0(ea) -> bool
        @param ea (C++: ea_t)
    """
    return _ida_nalt.has_ti0(*args)

def set_has_ti0(*args) -> "void":
    r"""


    set_has_ti0(ea)
        @param ea (C++: ea_t)
    """
    return _ida_nalt.set_has_ti0(*args)

def clr_has_ti0(*args) -> "void":
    r"""


    clr_has_ti0(ea)
        @param ea (C++: ea_t)
    """
    return _ida_nalt.clr_has_ti0(*args)

def has_ti1(*args) -> "bool":
    r"""


    has_ti1(ea) -> bool
        @param ea (C++: ea_t)
    """
    return _ida_nalt.has_ti1(*args)

def set_has_ti1(*args) -> "void":
    r"""


    set_has_ti1(ea)
        @param ea (C++: ea_t)
    """
    return _ida_nalt.set_has_ti1(*args)

def clr_has_ti1(*args) -> "void":
    r"""


    clr_has_ti1(ea)
        @param ea (C++: ea_t)
    """
    return _ida_nalt.clr_has_ti1(*args)

def has_lname(*args) -> "bool":
    r"""


    has_lname(ea) -> bool
        @param ea (C++: ea_t)
    """
    return _ida_nalt.has_lname(*args)

def set_has_lname(*args) -> "void":
    r"""


    set_has_lname(ea)
        @param ea (C++: ea_t)
    """
    return _ida_nalt.set_has_lname(*args)

def clr_has_lname(*args) -> "void":
    r"""


    clr_has_lname(ea)
        @param ea (C++: ea_t)
    """
    return _ida_nalt.clr_has_lname(*args)

def is_tilcmt(*args) -> "bool":
    r"""


    is_tilcmt(ea) -> bool
        @param ea (C++: ea_t)
    """
    return _ida_nalt.is_tilcmt(*args)

def set_tilcmt(*args) -> "void":
    r"""


    set_tilcmt(ea)
        @param ea (C++: ea_t)
    """
    return _ida_nalt.set_tilcmt(*args)

def clr_tilcmt(*args) -> "void":
    r"""


    clr_tilcmt(ea)
        @param ea (C++: ea_t)
    """
    return _ida_nalt.clr_tilcmt(*args)

def is_usersp(*args) -> "bool":
    r"""


    is_usersp(ea) -> bool
        @param ea (C++: ea_t)
    """
    return _ida_nalt.is_usersp(*args)

def set_usersp(*args) -> "void":
    r"""


    set_usersp(ea)
        @param ea (C++: ea_t)
    """
    return _ida_nalt.set_usersp(*args)

def clr_usersp(*args) -> "void":
    r"""


    clr_usersp(ea)
        @param ea (C++: ea_t)
    """
    return _ida_nalt.clr_usersp(*args)

def is_lzero0(*args) -> "bool":
    r"""


    is_lzero0(ea) -> bool
        @param ea (C++: ea_t)
    """
    return _ida_nalt.is_lzero0(*args)

def set_lzero0(*args) -> "void":
    r"""


    set_lzero0(ea)
        @param ea (C++: ea_t)
    """
    return _ida_nalt.set_lzero0(*args)

def clr_lzero0(*args) -> "void":
    r"""


    clr_lzero0(ea)
        @param ea (C++: ea_t)
    """
    return _ida_nalt.clr_lzero0(*args)

def is_lzero1(*args) -> "bool":
    r"""


    is_lzero1(ea) -> bool
        @param ea (C++: ea_t)
    """
    return _ida_nalt.is_lzero1(*args)

def set_lzero1(*args) -> "void":
    r"""


    set_lzero1(ea)
        @param ea (C++: ea_t)
    """
    return _ida_nalt.set_lzero1(*args)

def clr_lzero1(*args) -> "void":
    r"""


    clr_lzero1(ea)
        @param ea (C++: ea_t)
    """
    return _ida_nalt.clr_lzero1(*args)

def is_colored_item(*args) -> "bool":
    r"""


    is_colored_item(ea) -> bool
        @param ea (C++: ea_t)
    """
    return _ida_nalt.is_colored_item(*args)

def set_colored_item(*args) -> "void":
    r"""


    set_colored_item(ea)
        @param ea (C++: ea_t)
    """
    return _ida_nalt.set_colored_item(*args)

def clr_colored_item(*args) -> "void":
    r"""


    clr_colored_item(ea)
        @param ea (C++: ea_t)
    """
    return _ida_nalt.clr_colored_item(*args)

def is_terse_struc(*args) -> "bool":
    r"""


    is_terse_struc(ea) -> bool
        @param ea (C++: ea_t)
    """
    return _ida_nalt.is_terse_struc(*args)

def set_terse_struc(*args) -> "void":
    r"""


    set_terse_struc(ea)
        @param ea (C++: ea_t)
    """
    return _ida_nalt.set_terse_struc(*args)

def clr_terse_struc(*args) -> "void":
    r"""


    clr_terse_struc(ea)
        @param ea (C++: ea_t)
    """
    return _ida_nalt.clr_terse_struc(*args)

def is__invsign0(*args) -> "bool":
    r"""


    is__invsign0(ea) -> bool
        @param ea (C++: ea_t)
    """
    return _ida_nalt.is__invsign0(*args)

def set__invsign0(*args) -> "void":
    r"""


    set__invsign0(ea)
        @param ea (C++: ea_t)
    """
    return _ida_nalt.set__invsign0(*args)

def clr__invsign0(*args) -> "void":
    r"""


    clr__invsign0(ea)
        @param ea (C++: ea_t)
    """
    return _ida_nalt.clr__invsign0(*args)

def is__invsign1(*args) -> "bool":
    r"""


    is__invsign1(ea) -> bool
        @param ea (C++: ea_t)
    """
    return _ida_nalt.is__invsign1(*args)

def set__invsign1(*args) -> "void":
    r"""


    set__invsign1(ea)
        @param ea (C++: ea_t)
    """
    return _ida_nalt.set__invsign1(*args)

def clr__invsign1(*args) -> "void":
    r"""


    clr__invsign1(ea)
        @param ea (C++: ea_t)
    """
    return _ida_nalt.clr__invsign1(*args)

def is_noret(*args) -> "bool":
    r"""


    is_noret(ea) -> bool
        @param ea (C++: ea_t)
    """
    return _ida_nalt.is_noret(*args)

def set_noret(*args) -> "void":
    r"""


    set_noret(ea)
        @param ea (C++: ea_t)
    """
    return _ida_nalt.set_noret(*args)

def clr_noret(*args) -> "void":
    r"""


    clr_noret(ea)
        @param ea (C++: ea_t)
    """
    return _ida_nalt.clr_noret(*args)

def is_fixed_spd(*args) -> "bool":
    r"""


    is_fixed_spd(ea) -> bool
        @param ea (C++: ea_t)
    """
    return _ida_nalt.is_fixed_spd(*args)

def set_fixed_spd(*args) -> "void":
    r"""


    set_fixed_spd(ea)
        @param ea (C++: ea_t)
    """
    return _ida_nalt.set_fixed_spd(*args)

def clr_fixed_spd(*args) -> "void":
    r"""


    clr_fixed_spd(ea)
        @param ea (C++: ea_t)
    """
    return _ida_nalt.clr_fixed_spd(*args)

def is_align_flow(*args) -> "bool":
    r"""


    is_align_flow(ea) -> bool
        @param ea (C++: ea_t)
    """
    return _ida_nalt.is_align_flow(*args)

def set_align_flow(*args) -> "void":
    r"""


    set_align_flow(ea)
        @param ea (C++: ea_t)
    """
    return _ida_nalt.set_align_flow(*args)

def clr_align_flow(*args) -> "void":
    r"""


    clr_align_flow(ea)
        @param ea (C++: ea_t)
    """
    return _ida_nalt.clr_align_flow(*args)

def is_userti(*args) -> "bool":
    r"""


    is_userti(ea) -> bool
        @param ea (C++: ea_t)
    """
    return _ida_nalt.is_userti(*args)

def set_userti(*args) -> "void":
    r"""


    set_userti(ea)
        @param ea (C++: ea_t)
    """
    return _ida_nalt.set_userti(*args)

def clr_userti(*args) -> "void":
    r"""


    clr_userti(ea)
        @param ea (C++: ea_t)
    """
    return _ida_nalt.clr_userti(*args)

def is_retfp(*args) -> "bool":
    r"""


    is_retfp(ea) -> bool
        @param ea (C++: ea_t)
    """
    return _ida_nalt.is_retfp(*args)

def set_retfp(*args) -> "void":
    r"""


    set_retfp(ea)
        @param ea (C++: ea_t)
    """
    return _ida_nalt.set_retfp(*args)

def clr_retfp(*args) -> "void":
    r"""


    clr_retfp(ea)
        @param ea (C++: ea_t)
    """
    return _ida_nalt.clr_retfp(*args)

def is_notproc(*args) -> "bool":
    r"""


    is_notproc(ea) -> bool
        @param ea (C++: ea_t)
    """
    return _ida_nalt.is_notproc(*args)

def set_notproc(*args) -> "void":
    r"""


    set_notproc(ea)
        @param ea (C++: ea_t)
    """
    return _ida_nalt.set_notproc(*args)

def clr_notproc(*args) -> "void":
    r"""


    clr_notproc(ea)
        @param ea (C++: ea_t)
    """
    return _ida_nalt.clr_notproc(*args)

def set_notcode(*args) -> "void":
    r"""


    Mark address so that it cannot be converted to instruction.
    
    set_notcode(ea)
        @param ea (C++: ea_t)
    """
    return _ida_nalt.set_notcode(*args)

def clr_notcode(*args) -> "void":
    r"""


    Clear not-code mark.
    
    clr_notcode(ea)
        @param ea (C++: ea_t)
    """
    return _ida_nalt.clr_notcode(*args)

def is_notcode(*args) -> "bool":
    r"""


    Is the address marked as not-code?
    
    is_notcode(ea) -> bool
        @param ea (C++: ea_t)
    """
    return _ida_nalt.is_notcode(*args)

def set_visible_item(*args) -> "void":
    r"""


    Change visibility of item at given ea.
    
    set_visible_item(ea, visible)
        @param ea (C++: ea_t)
        @param visible (C++: bool)
    """
    return _ida_nalt.set_visible_item(*args)

def is_visible_item(*args) -> "bool":
    r"""


    Test visibility of item at given ea.
    
    is_visible_item(ea) -> bool
        @param ea (C++: ea_t)
    """
    return _ida_nalt.is_visible_item(*args)

def is_finally_visible_item(*args) -> "bool":
    r"""


    Is instruction visible?
    
    is_finally_visible_item(ea) -> bool
        @param ea (C++: ea_t)
    """
    return _ida_nalt.is_finally_visible_item(*args)

def set_source_linnum(*args) -> "void":
    r"""


    set_source_linnum(ea, lnnum)
        @param ea (C++: ea_t)
        @param lnnum (C++: uval_t)
    """
    return _ida_nalt.set_source_linnum(*args)

def get_source_linnum(*args) -> "uval_t":
    r"""


    get_source_linnum(ea) -> uval_t
        @param ea (C++: ea_t)
    """
    return _ida_nalt.get_source_linnum(*args)

def del_source_linnum(*args) -> "void":
    r"""


    del_source_linnum(ea)
        @param ea (C++: ea_t)
    """
    return _ida_nalt.del_source_linnum(*args)

def get_absbase(*args) -> "ea_t":
    r"""


    get_absbase(ea) -> ea_t
        @param ea (C++: ea_t)
    """
    return _ida_nalt.get_absbase(*args)

def set_absbase(*args) -> "void":
    r"""


    set_absbase(ea, x)
        @param ea (C++: ea_t)
        @param x (C++: ea_t)
    """
    return _ida_nalt.set_absbase(*args)

def del_absbase(*args) -> "void":
    r"""


    del_absbase(ea)
        @param ea (C++: ea_t)
    """
    return _ida_nalt.del_absbase(*args)

def get_ind_purged(*args) -> "ea_t":
    r"""


    get_ind_purged(ea) -> ea_t
        @param ea (C++: ea_t)
    """
    return _ida_nalt.get_ind_purged(*args)

def del_ind_purged(*args) -> "void":
    r"""


    del_ind_purged(ea)
        @param ea (C++: ea_t)
    """
    return _ida_nalt.del_ind_purged(*args)

def get_str_type(*args) -> "uint32":
    r"""


    get_str_type(ea) -> uint32
        @param ea (C++: ea_t)
    """
    return _ida_nalt.get_str_type(*args)

def set_str_type(*args) -> "void":
    r"""


    set_str_type(ea, x)
        @param ea (C++: ea_t)
        @param x (C++: uint32)
    """
    return _ida_nalt.set_str_type(*args)

def del_str_type(*args) -> "void":
    r"""


    del_str_type(ea)
        @param ea (C++: ea_t)
    """
    return _ida_nalt.del_str_type(*args)
STRWIDTH_1B = _ida_nalt.STRWIDTH_1B

STRWIDTH_2B = _ida_nalt.STRWIDTH_2B

STRWIDTH_4B = _ida_nalt.STRWIDTH_4B

STRWIDTH_MASK = _ida_nalt.STRWIDTH_MASK

STRLYT_TERMCHR = _ida_nalt.STRLYT_TERMCHR

STRLYT_PASCAL1 = _ida_nalt.STRLYT_PASCAL1

STRLYT_PASCAL2 = _ida_nalt.STRLYT_PASCAL2

STRLYT_PASCAL4 = _ida_nalt.STRLYT_PASCAL4

STRLYT_MASK = _ida_nalt.STRLYT_MASK

STRLYT_SHIFT = _ida_nalt.STRLYT_SHIFT

STRTYPE_TERMCHR = _ida_nalt.STRTYPE_TERMCHR
"""
C-style string.

< Character-terminated string. The termination characters are kept in
the next bytes of string type.
"""

STRTYPE_C = _ida_nalt.STRTYPE_C
"""
Zero-terminated 16bit chars.
"""

STRTYPE_C_16 = _ida_nalt.STRTYPE_C_16
"""
Zero-terminated 32bit chars.
"""

STRTYPE_C_32 = _ida_nalt.STRTYPE_C_32
"""
Pascal-style, one-byte length prefix.
"""

STRTYPE_PASCAL = _ida_nalt.STRTYPE_PASCAL
"""
Pascal-style, 16bit chars, one-byte length prefix.
"""

STRTYPE_PASCAL_16 = _ida_nalt.STRTYPE_PASCAL_16
"""
Pascal-style, two-byte length prefix.
"""

STRTYPE_LEN2 = _ida_nalt.STRTYPE_LEN2
"""
Pascal-style, 16bit chars, two-byte length prefix.
"""

STRTYPE_LEN2_16 = _ida_nalt.STRTYPE_LEN2_16
"""
Pascal-style, four-byte length prefix.
"""

STRTYPE_LEN4 = _ida_nalt.STRTYPE_LEN4
"""
Pascal-style, 16bit chars, four-byte length prefix.
"""

STRTYPE_LEN4_16 = _ida_nalt.STRTYPE_LEN4_16


def get_str_type_code(*args) -> "uchar":
    r"""


    get_str_type_code(strtype) -> uchar
        @param strtype (C++: int32)
    """
    return _ida_nalt.get_str_type_code(*args)

def get_str_term1(*args) -> "char":
    r"""


    get_str_term1(strtype) -> char
        @param strtype (C++: int32)
    """
    return _ida_nalt.get_str_term1(*args)

def get_str_term2(*args) -> "char":
    r"""


    get_str_term2(strtype) -> char
        @param strtype (C++: int32)
    """
    return _ida_nalt.get_str_term2(*args)

def get_str_encoding_idx(*args) -> "uchar":
    r"""


    Get index of the string encoding for this string.
    
    get_str_encoding_idx(strtype) -> uchar
        @param strtype (C++: int32)
    """
    return _ida_nalt.get_str_encoding_idx(*args)

def is_pascal(*args) -> "bool":
    r"""


    is_pascal(strtype) -> bool
        @param strtype (C++: int32)
    """
    return _ida_nalt.is_pascal(*args)

def get_str_type_prefix_length(*args) -> "size_t":
    r"""


    get_str_type_prefix_length(strtype) -> size_t
        @param strtype (C++: int32)
    """
    return _ida_nalt.get_str_type_prefix_length(*args)
STRENC_DEFAULT = _ida_nalt.STRENC_DEFAULT
"""
use default encoding for this type (see 'get_default_encoding_idx()' )
"""

STRENC_NONE = _ida_nalt.STRENC_NONE
"""
force no-conversion encoding
"""


def get_alignment(*args) -> "uint32":
    r"""


    get_alignment(ea) -> uint32
        @param ea (C++: ea_t)
    """
    return _ida_nalt.get_alignment(*args)

def set_alignment(*args) -> "void":
    r"""


    set_alignment(ea, x)
        @param ea (C++: ea_t)
        @param x (C++: uint32)
    """
    return _ida_nalt.set_alignment(*args)

def del_alignment(*args) -> "void":
    r"""


    del_alignment(ea)
        @param ea (C++: ea_t)
    """
    return _ida_nalt.del_alignment(*args)

def set_item_color(*args) -> "void":
    r"""


    set_item_color(ea, color)
        @param ea (C++: ea_t)
        @param color (C++: bgcolor_t)
    """
    return _ida_nalt.set_item_color(*args)

def get_item_color(*args) -> "bgcolor_t":
    r"""


    get_item_color(ea) -> bgcolor_t
        @param ea (C++: ea_t)
    """
    return _ida_nalt.get_item_color(*args)

def del_item_color(*args) -> "bool":
    r"""


    del_item_color(ea) -> bool
        @param ea (C++: ea_t)
    """
    return _ida_nalt.del_item_color(*args)
class array_parameters_t(object):
    r"""
    Proxy of C++ array_parameters_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    flags = property(_ida_nalt.array_parameters_t_flags_get, _ida_nalt.array_parameters_t_flags_set)
    lineitems = property(_ida_nalt.array_parameters_t_lineitems_get, _ida_nalt.array_parameters_t_lineitems_set)
    alignment = property(_ida_nalt.array_parameters_t_alignment_get, _ida_nalt.array_parameters_t_alignment_set)

    def __init__(self, *args):
        r"""
        __init__(self) -> array_parameters_t
        """
        _ida_nalt.array_parameters_t_swiginit(self, _ida_nalt.new_array_parameters_t(*args))
    __swig_destroy__ = _ida_nalt.delete_array_parameters_t

# Register array_parameters_t in _ida_nalt:
_ida_nalt.array_parameters_t_swigregister(array_parameters_t)
AP_ALLOWDUPS = _ida_nalt.AP_ALLOWDUPS
"""
use 'dup' construct
"""

AP_SIGNED = _ida_nalt.AP_SIGNED
"""
treats numbers as signed
"""

AP_INDEX = _ida_nalt.AP_INDEX
"""
display array element indexes as comments
"""

AP_ARRAY = _ida_nalt.AP_ARRAY
"""
create as array (this flag is not stored in database)
"""

AP_IDXBASEMASK = _ida_nalt.AP_IDXBASEMASK
"""
mask for number base of the indexes
"""

AP_IDXDEC = _ida_nalt.AP_IDXDEC
"""
display indexes in decimal
"""

AP_IDXHEX = _ida_nalt.AP_IDXHEX
"""
display indexes in hex
"""

AP_IDXOCT = _ida_nalt.AP_IDXOCT
"""
display indexes in octal
"""

AP_IDXBIN = _ida_nalt.AP_IDXBIN
"""
display indexes in binary
"""



def get_array_parameters(*args) -> "ssize_t":
    r"""


    get_array_parameters(out, ea) -> ssize_t
        @param out (C++: array_parameters_t  *)
        @param ea (C++: ea_t)
    """
    return _ida_nalt.get_array_parameters(*args)

def set_array_parameters(*args) -> "void":
    r"""


    set_array_parameters(ea, _in)
        @param ea (C++: ea_t)
        in: array_parameters_t const *
    """
    return _ida_nalt.set_array_parameters(*args)

def del_array_parameters(*args) -> "void":
    r"""


    del_array_parameters(ea)
        @param ea (C++: ea_t)
    """
    return _ida_nalt.del_array_parameters(*args)
class switch_info_t(object):
    r"""
    Proxy of C++ switch_info_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    flags = property(_ida_nalt.switch_info_t_flags_get, _ida_nalt.switch_info_t_flags_set)

    def get_shift(self, *args) -> "int":
        r"""


        See 'SWI_SHIFT_MASK' . possible answers: 0..3.
        """
        return _ida_nalt.switch_info_t_get_shift(self, *args)

    def set_shift(self, *args) -> "void":
        r"""


        See 'SWI_SHIFT_MASK' .
        
        set_shift(self, shift)
            @param shift (C++: int)
        """
        return _ida_nalt.switch_info_t_set_shift(self, *args)

    def get_jtable_element_size(self, *args) -> "int":
        r"""
        get_jtable_element_size(self) -> int
        """
        return _ida_nalt.switch_info_t_get_jtable_element_size(self, *args)

    def set_jtable_element_size(self, *args) -> "void":
        r"""


        set_jtable_element_size(self, size)
            @param size (C++: int)
        """
        return _ida_nalt.switch_info_t_set_jtable_element_size(self, *args)

    def get_vtable_element_size(self, *args) -> "int":
        r"""
        get_vtable_element_size(self) -> int
        """
        return _ida_nalt.switch_info_t_get_vtable_element_size(self, *args)

    def set_vtable_element_size(self, *args) -> "void":
        r"""


        set_vtable_element_size(self, size)
            @param size (C++: int)
        """
        return _ida_nalt.switch_info_t_set_vtable_element_size(self, *args)

    def has_default(self, *args) -> "bool":
        r"""
        has_default(self) -> bool
        """
        return _ida_nalt.switch_info_t_has_default(self, *args)

    def has_elbase(self, *args) -> "bool":
        r"""
        has_elbase(self) -> bool
        """
        return _ida_nalt.switch_info_t_has_elbase(self, *args)

    def is_sparse(self, *args) -> "bool":
        r"""
        is_sparse(self) -> bool
        """
        return _ida_nalt.switch_info_t_is_sparse(self, *args)

    def is_custom(self, *args) -> "bool":
        r"""
        is_custom(self) -> bool
        """
        return _ida_nalt.switch_info_t_is_custom(self, *args)

    def is_indirect(self, *args) -> "bool":
        r"""
        is_indirect(self) -> bool
        """
        return _ida_nalt.switch_info_t_is_indirect(self, *args)

    def is_subtract(self, *args) -> "bool":
        r"""
        is_subtract(self) -> bool
        """
        return _ida_nalt.switch_info_t_is_subtract(self, *args)

    def is_nolowcase(self, *args) -> "bool":
        r"""
        is_nolowcase(self) -> bool
        """
        return _ida_nalt.switch_info_t_is_nolowcase(self, *args)

    def use_std_table(self, *args) -> "bool":
        r"""
        use_std_table(self) -> bool
        """
        return _ida_nalt.switch_info_t_use_std_table(self, *args)
    ncases = property(_ida_nalt.switch_info_t_ncases_get, _ida_nalt.switch_info_t_ncases_set)
    jumps = property(_ida_nalt.switch_info_t_jumps_get, _ida_nalt.switch_info_t_jumps_set)
    defjump = property(_ida_nalt.switch_info_t_defjump_get, _ida_nalt.switch_info_t_defjump_set)
    startea = property(_ida_nalt.switch_info_t_startea_get, _ida_nalt.switch_info_t_startea_set)
    jcases = property(_ida_nalt.switch_info_t_jcases_get, _ida_nalt.switch_info_t_jcases_set)
    ind_lowcase = property(_ida_nalt.switch_info_t_ind_lowcase_get, _ida_nalt.switch_info_t_ind_lowcase_set)

    def get_lowcase(self, *args) -> "sval_t":
        r"""
        get_lowcase(self) -> sval_t
        """
        return _ida_nalt.switch_info_t_get_lowcase(self, *args)
    elbase = property(_ida_nalt.switch_info_t_elbase_get, _ida_nalt.switch_info_t_elbase_set)
    regnum = property(_ida_nalt.switch_info_t_regnum_get, _ida_nalt.switch_info_t_regnum_set)
    regdtype = property(_ida_nalt.switch_info_t_regdtype_get, _ida_nalt.switch_info_t_regdtype_set)

    def get_jtable_size(self, *args) -> "int":
        r"""
        get_jtable_size(self) -> int
        """
        return _ida_nalt.switch_info_t_get_jtable_size(self, *args)

    def set_jtable_size(self, *args) -> "void":
        r"""


        set_jtable_size(self, size)
            @param size (C++: int)
        """
        return _ida_nalt.switch_info_t_set_jtable_size(self, *args)

    def set_elbase(self, *args) -> "void":
        r"""


        set_elbase(self, base)
            @param base (C++: ea_t)
        """
        return _ida_nalt.switch_info_t_set_elbase(self, *args)

    def set_expr(self, *args) -> "void":
        r"""


        set_expr(self, r, dt)
            @param r (C++: int)
            @param dt (C++: op_dtype_t)
        """
        return _ida_nalt.switch_info_t_set_expr(self, *args)

    def get_jrange_vrange(self, *args) -> "bool":
        r"""


        get separate parts of the switch
        
        get_jrange_vrange(self, jrange=None, vrange=None) -> bool
            @param jrange (C++: range_t  *)
            @param vrange (C++: range_t  *)
        """
        return _ida_nalt.switch_info_t_get_jrange_vrange(self, *args)
    custom = property(_ida_nalt.switch_info_t_custom_get, _ida_nalt.switch_info_t_custom_set)
    SWITCH_INFO_VERSION = _ida_nalt.switch_info_t_SWITCH_INFO_VERSION


    def get_version(self, *args) -> "int":
        r"""
        get_version(self) -> int
        """
        return _ida_nalt.switch_info_t_get_version(self, *args)
    expr_ea = property(_ida_nalt.switch_info_t_expr_ea_get, _ida_nalt.switch_info_t_expr_ea_set)
    marks = property(_ida_nalt.switch_info_t_marks_get, _ida_nalt.switch_info_t_marks_set)

    def __init__(self, *args):
        r"""
        __init__(self) -> switch_info_t
        """
        _ida_nalt.switch_info_t_swiginit(self, _ida_nalt.new_switch_info_t(*args))

    def clear(self, *args) -> "void":
        r"""
        clear(self)
        """
        return _ida_nalt.switch_info_t_clear(self, *args)

    def assign(self, *args) -> "void":
        r"""


        assign(self, other)
            other: switch_info_t const &
        """
        return _ida_nalt.switch_info_t_assign(self, *args)

    def _get_values_lowcase(self, *args) -> "ea_t":
        r"""
        _get_values_lowcase(self) -> ea_t
        """
        return _ida_nalt.switch_info_t__get_values_lowcase(self, *args)

    def _set_values_lowcase(self, *args) -> "void":
        r"""


        _set_values_lowcase(self, values)
            values: ea_t
        """
        return _ida_nalt.switch_info_t__set_values_lowcase(self, *args)

    values = property(_get_values_lowcase, _set_values_lowcase)
    lowcase = property(_get_values_lowcase, _set_values_lowcase)

    __swig_destroy__ = _ida_nalt.delete_switch_info_t

# Register switch_info_t in _ida_nalt:
_ida_nalt.switch_info_t_swigregister(switch_info_t)
SWI_SPARSE = _ida_nalt.SWI_SPARSE
"""
otherwise lowcase present

sparse switch (value table present)
"""

SWI_V32 = _ida_nalt.SWI_V32
"""
32-bit values in table
"""

SWI_J32 = _ida_nalt.SWI_J32
"""
32-bit jump offsets
"""

SWI_VSPLIT = _ida_nalt.SWI_VSPLIT
"""
value table is split (only for 32-bit values)
"""

SWI_RESERVED = _ida_nalt.SWI_RESERVED
"""
was: SWI_DEFAULT
"""

SWI_DEF_IN_TBL = _ida_nalt.SWI_DEF_IN_TBL
"""
default case is an entry in the jump table. This flag is applicable in
2 cases:The sparse indirect switch (i.e. a switch with a values table)
<jump table="" size>=""> ==+ 1. The default case entry is the last one
in the table (or the first one in the case of an inversed jump
table).The switch with insns in the jump table. The default case entry
is before the first entry of the table. See also the
find_defjump_from_table() helper function.
"""

SWI_JMP_INV = _ida_nalt.SWI_JMP_INV
"""
for first entry in values table)

jumptable is inversed. (last entry is
"""

SWI_SHIFT_MASK = _ida_nalt.SWI_SHIFT_MASK
"""
use formula (element<<shift) + elbase to find jump targets
"""

SWI_ELBASE = _ida_nalt.SWI_ELBASE
"""
segment will be used)

elbase is present (otherwise the base of the switch
"""

SWI_JSIZE = _ida_nalt.SWI_JSIZE
"""
jump offset expansion bit
"""

SWI_VSIZE = _ida_nalt.SWI_VSIZE
"""
value table element size expansion bit
"""

SWI_SEPARATE = _ida_nalt.SWI_SEPARATE
"""
create an array of individual elements (otherwise separate items)
"""

SWI_SIGNED = _ida_nalt.SWI_SIGNED
"""
jump table entries are signed
"""

SWI_CUSTOM = _ida_nalt.SWI_CUSTOM
"""
custom jump table. \\ph{create_switch_xrefs} will be called to create
code xrefs for the table. Custom jump table must be created by the
module (see also 'SWI_STDTBL' )
"""

SWI_INDIRECT = _ida_nalt.SWI_INDIRECT
"""
(for sparse switches)

value table elements are used as indexes into the jump table
"""

SWI_SUBTRACT = _ida_nalt.SWI_SUBTRACT
"""
table values are subtracted from the elbase instead of being added
"""

SWI_HXNOLOWCASE = _ida_nalt.SWI_HXNOLOWCASE
"""
lowcase value should not be used by the decompiler (internal flag)
"""

SWI_STDTBL = _ida_nalt.SWI_STDTBL
"""
custom jump table with standard table formatting. ATM IDA doesn't use
SWI_CUSTOM for switches with standard table formatting. So this flag
can be considered as obsolete.
"""

SWI_DEFRET = _ida_nalt.SWI_DEFRET
"""
return in the default case (defjump==BADADDR)
"""

SWI_SELFREL = _ida_nalt.SWI_SELFREL
"""
jump address is relative to the element not to ELBASE
"""

SWI_JMPINSN = _ida_nalt.SWI_JMPINSN
"""
jump table entries are insns. For such entries SHIFT has a different
meaning. It denotes the number of insns in the entry. For example, 0 -
the entry contains the jump to the case, 1 - the entry contains one
insn like a 'mov' and jump to the end of case, and so on.
"""

SWI_VERSION = _ida_nalt.SWI_VERSION
"""
the structure contains the VERSION member
"""



def get_switch_info(*args) -> "ssize_t":
    r"""


    get_switch_info(out, ea) -> ssize_t
        @param out (C++: switch_info_t  *)
        @param ea (C++: ea_t)
    """
    return _ida_nalt.get_switch_info(*args)

def set_switch_info(*args) -> "void":
    r"""


    set_switch_info(ea, _in)
        @param ea (C++: ea_t)
        in: switch_info_t const &
    """
    return _ida_nalt.set_switch_info(*args)

def del_switch_info(*args) -> "void":
    r"""


    del_switch_info(ea)
        @param ea (C++: ea_t)
    """
    return _ida_nalt.del_switch_info(*args)

def get_switch_parent(*args) -> "ea_t":
    r"""


    get_switch_parent(ea) -> ea_t
        @param ea (C++: ea_t)
    """
    return _ida_nalt.get_switch_parent(*args)

def set_switch_parent(*args) -> "void":
    r"""


    set_switch_parent(ea, x)
        @param ea (C++: ea_t)
        @param x (C++: ea_t)
    """
    return _ida_nalt.set_switch_parent(*args)

def del_switch_parent(*args) -> "void":
    r"""


    del_switch_parent(ea)
        @param ea (C++: ea_t)
    """
    return _ida_nalt.del_switch_parent(*args)
class custom_data_type_ids_t(object):
    r"""
    Proxy of C++ custom_data_type_ids_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    dtid = property(_ida_nalt.custom_data_type_ids_t_dtid_get, _ida_nalt.custom_data_type_ids_t_dtid_set)
    fids = property(_ida_nalt.custom_data_type_ids_t_fids_get, _ida_nalt.custom_data_type_ids_t_fids_set)

    def set(self, *args) -> "void":
        r"""


        set(self, tid)
            @param tid (C++: tid_t)
        """
        return _ida_nalt.custom_data_type_ids_t_set(self, *args)

    def __getFids(self, *args) -> "wrapped_array_t< int16,8 >":
        r"""
        __getFids(self) -> custom_data_type_ids_fids_array
        """
        return _ida_nalt.custom_data_type_ids_t___getFids(self, *args)

    fids = property(__getFids)


    def __init__(self, *args):
        r"""
        __init__(self) -> custom_data_type_ids_t
        """
        _ida_nalt.custom_data_type_ids_t_swiginit(self, _ida_nalt.new_custom_data_type_ids_t(*args))
    __swig_destroy__ = _ida_nalt.delete_custom_data_type_ids_t

# Register custom_data_type_ids_t in _ida_nalt:
_ida_nalt.custom_data_type_ids_t_swigregister(custom_data_type_ids_t)


def get_custom_data_type_ids(*args) -> "int":
    r"""


    get_custom_data_type_ids(cdis, ea) -> int
        @param cdis (C++: custom_data_type_ids_t  *)
        @param ea (C++: ea_t)
    """
    return _ida_nalt.get_custom_data_type_ids(*args)

def set_custom_data_type_ids(*args) -> "void":
    r"""


    set_custom_data_type_ids(ea, cdis)
        @param ea (C++: ea_t)
        @param cdis (C++: const  custom_data_type_ids_t  *)
    """
    return _ida_nalt.set_custom_data_type_ids(*args)

def del_custom_data_type_ids(*args) -> "void":
    r"""


    del_custom_data_type_ids(ea)
        @param ea (C++: ea_t)
    """
    return _ida_nalt.del_custom_data_type_ids(*args)

def is_reftype_target_optional(*args) -> "bool":
    r"""


    Can the target be calculated using operand value?
    
    is_reftype_target_optional(type) -> bool
        @param type (C++: reftype_t)
    """
    return _ida_nalt.is_reftype_target_optional(*args)

def get_reftype_by_size(*args) -> "reftype_t":
    r"""


    Get REF_... constant from size Supported sizes: 1,2,4,8,16 For other
    sizes returns reftype_t(-1)
    
    get_reftype_by_size(size) -> reftype_t
        @param size (C++: size_t)
    """
    return _ida_nalt.get_reftype_by_size(*args)
class refinfo_t(object):
    r"""
    Proxy of C++ refinfo_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    target = property(_ida_nalt.refinfo_t_target_get, _ida_nalt.refinfo_t_target_set)
    base = property(_ida_nalt.refinfo_t_base_get, _ida_nalt.refinfo_t_base_set)
    tdelta = property(_ida_nalt.refinfo_t_tdelta_get, _ida_nalt.refinfo_t_tdelta_set)
    flags = property(_ida_nalt.refinfo_t_flags_get, _ida_nalt.refinfo_t_flags_set)

    def type(self, *args) -> "reftype_t":
        r"""
        type(self) -> reftype_t
        """
        return _ida_nalt.refinfo_t_type(self, *args)

    def is_target_optional(self, *args) -> "bool":
        r"""


        < 'is_reftype_target_optional()'
        """
        return _ida_nalt.refinfo_t_is_target_optional(self, *args)

    def no_base_xref(self, *args) -> "bool":
        r"""
        no_base_xref(self) -> bool
        """
        return _ida_nalt.refinfo_t_no_base_xref(self, *args)

    def is_pastend(self, *args) -> "bool":
        r"""
        is_pastend(self) -> bool
        """
        return _ida_nalt.refinfo_t_is_pastend(self, *args)

    def is_rvaoff(self, *args) -> "bool":
        r"""
        is_rvaoff(self) -> bool
        """
        return _ida_nalt.refinfo_t_is_rvaoff(self, *args)

    def is_custom(self, *args) -> "bool":
        r"""
        is_custom(self) -> bool
        """
        return _ida_nalt.refinfo_t_is_custom(self, *args)

    def is_subtract(self, *args) -> "bool":
        r"""
        is_subtract(self) -> bool
        """
        return _ida_nalt.refinfo_t_is_subtract(self, *args)

    def is_signed(self, *args) -> "bool":
        r"""
        is_signed(self) -> bool
        """
        return _ida_nalt.refinfo_t_is_signed(self, *args)

    def set_type(self, *args) -> "void":
        r"""


        set_type(self, rt)
            @param rt (C++: reftype_t)
        """
        return _ida_nalt.refinfo_t_set_type(self, *args)

    def init(self, *args) -> "void":
        r"""


        init(self, reft_and_flags, _base=0, _target=BADADDR, _tdelta=0)
            @param reft_and_flags (C++: uint32)
            @param _base (C++: ea_t)
            @param _target (C++: ea_t)
            @param _tdelta (C++: adiff_t)
        """
        return _ida_nalt.refinfo_t_init(self, *args)

    def __init__(self, *args):
        r"""
        __init__(self) -> refinfo_t
        """
        _ida_nalt.refinfo_t_swiginit(self, _ida_nalt.new_refinfo_t(*args))
    __swig_destroy__ = _ida_nalt.delete_refinfo_t

# Register refinfo_t in _ida_nalt:
_ida_nalt.refinfo_t_swigregister(refinfo_t)
cvar = _ida_nalt.cvar
V695_REF_OFF8 = cvar.V695_REF_OFF8
REF_OFF16 = cvar.REF_OFF16
REF_OFF32 = cvar.REF_OFF32
REF_LOW8 = cvar.REF_LOW8
REF_LOW16 = cvar.REF_LOW16
REF_HIGH8 = cvar.REF_HIGH8
REF_HIGH16 = cvar.REF_HIGH16
V695_REF_VHIGH = cvar.V695_REF_VHIGH
V695_REF_VLOW = cvar.V695_REF_VLOW
REF_OFF64 = cvar.REF_OFF64
REF_OFF8 = cvar.REF_OFF8
REF_LAST = cvar.REF_LAST
REFINFO_TYPE = _ida_nalt.REFINFO_TYPE
"""
reference type
"""

REFINFO_RVAOFF = _ida_nalt.REFINFO_RVAOFF
"""
based reference (rva) 'refinfo_t::base' will be forced to
'get_imagebase()' such a reference is displayed with the \\ash{a_rva}
keyword
"""

REFINFO_PASTEND = _ida_nalt.REFINFO_PASTEND
"""
reference past an item it may point to an nonexistent address do not
destroy alignment dirs
"""

REFINFO_CUSTOM = _ida_nalt.REFINFO_CUSTOM
"""
a custom reference the kernel will call \\ph{notify}(ph.custom_offset,
.... that can change all arguments used for calculations. This flag is
useful for custom fixups
"""

REFINFO_NOBASE = _ida_nalt.REFINFO_NOBASE
"""
don't create the base xref implies that the base can be any value nb:
base xrefs are created only if the offset base points to the middle of
a segment
"""

REFINFO_SUBTRACT = _ida_nalt.REFINFO_SUBTRACT
"""
the reference value is subtracted from the base value instead of (as
usual) being added to it
"""

REFINFO_SIGNEDOP = _ida_nalt.REFINFO_SIGNEDOP
"""
the operand value is sign-extended (only supported for
REF_OFF8/16/32/64)
"""



def find_custom_refinfo(*args) -> "int":
    r"""


    Get id of a custom refinfo type.
    
    find_custom_refinfo(name) -> int
        @param name (C++: const char *)
    """
    return _ida_nalt.find_custom_refinfo(*args)

def get_custom_refinfo(*args) -> "custom_refinfo_handler_t const *":
    r"""


    Get definition of a registered custom refinfo type.
    
    get_custom_refinfo(crid) -> custom_refinfo_handler_t const *
        @param crid (C++: int)
    """
    return _ida_nalt.get_custom_refinfo(*args)
MAXSTRUCPATH = _ida_nalt.MAXSTRUCPATH
"""
maximal inclusion depth of unions
"""

class strpath_t(object):
    r"""
    Proxy of C++ strpath_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    len = property(_ida_nalt.strpath_t_len_get, _ida_nalt.strpath_t_len_set)
    ids = property(_ida_nalt.strpath_t_ids_get, _ida_nalt.strpath_t_ids_set)
    delta = property(_ida_nalt.strpath_t_delta_get, _ida_nalt.strpath_t_delta_set)

    def __getIds(self, *args) -> "wrapped_array_t< tid_t,32 >":
        r"""
        __getIds(self) -> strpath_ids_array
        """
        return _ida_nalt.strpath_t___getIds(self, *args)

    ids = property(__getIds)


    def __init__(self, *args):
        r"""
        __init__(self) -> strpath_t
        """
        _ida_nalt.strpath_t_swiginit(self, _ida_nalt.new_strpath_t(*args))
    __swig_destroy__ = _ida_nalt.delete_strpath_t

# Register strpath_t in _ida_nalt:
_ida_nalt.strpath_t_swigregister(strpath_t)

class enum_const_t(object):
    r"""
    Proxy of C++ enum_const_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    tid = property(_ida_nalt.enum_const_t_tid_get, _ida_nalt.enum_const_t_tid_set)
    serial = property(_ida_nalt.enum_const_t_serial_get, _ida_nalt.enum_const_t_serial_set)

    def __init__(self, *args):
        r"""
        __init__(self) -> enum_const_t
        """
        _ida_nalt.enum_const_t_swiginit(self, _ida_nalt.new_enum_const_t(*args))
    __swig_destroy__ = _ida_nalt.delete_enum_const_t

# Register enum_const_t in _ida_nalt:
_ida_nalt.enum_const_t_swigregister(enum_const_t)

class opinfo_t(object):
    r"""
    Proxy of C++ opinfo_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    ri = property(_ida_nalt.opinfo_t_ri_get, _ida_nalt.opinfo_t_ri_set)
    tid = property(_ida_nalt.opinfo_t_tid_get, _ida_nalt.opinfo_t_tid_set)
    path = property(_ida_nalt.opinfo_t_path_get, _ida_nalt.opinfo_t_path_set)
    strtype = property(_ida_nalt.opinfo_t_strtype_get, _ida_nalt.opinfo_t_strtype_set)
    ec = property(_ida_nalt.opinfo_t_ec_get, _ida_nalt.opinfo_t_ec_set)
    cd = property(_ida_nalt.opinfo_t_cd_get, _ida_nalt.opinfo_t_cd_set)

    def __init__(self, *args):
        r"""
        __init__(self) -> opinfo_t
        """
        _ida_nalt.opinfo_t_swiginit(self, _ida_nalt.new_opinfo_t(*args))
    __swig_destroy__ = _ida_nalt.delete_opinfo_t

# Register opinfo_t in _ida_nalt:
_ida_nalt.opinfo_t_swigregister(opinfo_t)

class printop_t(object):
    r"""
    Proxy of C++ printop_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    flags = property(_ida_nalt.printop_t_flags_get, _ida_nalt.printop_t_flags_set)
    ti = property(_ida_nalt.printop_t_ti_get, _ida_nalt.printop_t_ti_set)
    features = property(_ida_nalt.printop_t_features_get, _ida_nalt.printop_t_features_set)
    suspop = property(_ida_nalt.printop_t_suspop_get, _ida_nalt.printop_t_suspop_set)
    aflags = property(_ida_nalt.printop_t_aflags_get, _ida_nalt.printop_t_aflags_set)

    def __init__(self, *args):
        r"""
        __init__(self) -> printop_t
        """
        _ida_nalt.printop_t_swiginit(self, _ida_nalt.new_printop_t(*args))

    def is_ti_initialized(self, *args) -> "bool":
        r"""
        is_ti_initialized(self) -> bool
        """
        return _ida_nalt.printop_t_is_ti_initialized(self, *args)

    def set_ti_initialized(self, *args) -> "void":
        r"""


        set_ti_initialized(self, v=True)
            @param v (C++: bool)
        """
        return _ida_nalt.printop_t_set_ti_initialized(self, *args)

    def is_aflags_initialized(self, *args) -> "bool":
        r"""
        is_aflags_initialized(self) -> bool
        """
        return _ida_nalt.printop_t_is_aflags_initialized(self, *args)

    def set_aflags_initialized(self, *args) -> "void":
        r"""


        set_aflags_initialized(self, v=True)
            @param v (C++: bool)
        """
        return _ida_nalt.printop_t_set_aflags_initialized(self, *args)

    def get_ti(self, *args) -> "opinfo_t const *":
        r"""
        get_ti(self) -> opinfo_t
        """
        return _ida_nalt.printop_t_get_ti(self, *args)

    is_ti_valid = property(is_ti_initialized, set_ti_initialized)

    __swig_destroy__ = _ida_nalt.delete_printop_t

# Register printop_t in _ida_nalt:
_ida_nalt.printop_t_swigregister(printop_t)
POF_VALID_TI = _ida_nalt.POF_VALID_TI

POF_VALID_AFLAGS = _ida_nalt.POF_VALID_AFLAGS



def set_refinfo_ex(*args) -> "bool":
    r"""


    set_refinfo_ex(ea, n, ri) -> bool
        @param ea (C++: ea_t)
        @param n (C++: int)
        @param ri (C++: const  refinfo_t  *)
    """
    return _ida_nalt.set_refinfo_ex(*args)

def set_refinfo(*args) -> "bool":
    r"""


    set_refinfo(ea, n, type, target=BADADDR, base=0, tdelta=0) -> bool
        @param ea (C++: ea_t)
        @param n (C++: int)
        @param type (C++: reftype_t)
        @param target (C++: ea_t)
        @param base (C++: ea_t)
        @param tdelta (C++: adiff_t)
    """
    return _ida_nalt.set_refinfo(*args)

def get_refinfo(*args) -> "bool":
    r"""


    get_refinfo(ri, ea, n) -> bool
        @param ri (C++: refinfo_t  *)
        @param ea (C++: ea_t)
        @param n (C++: int)
    """
    return _ida_nalt.get_refinfo(*args)

def del_refinfo(*args) -> "bool":
    r"""


    del_refinfo(ea, n) -> bool
        @param ea (C++: ea_t)
        @param n (C++: int)
    """
    return _ida_nalt.del_refinfo(*args)

def get_tinfo(*args) -> "bool":
    r"""


    get_tinfo(tif, ea) -> bool
        @param tif (C++: tinfo_t  *)
        @param ea (C++: ea_t)
    """
    return _ida_nalt.get_tinfo(*args)

def set_tinfo(*args) -> "bool":
    r"""


    set_tinfo(ea, tif) -> bool
        @param ea (C++: ea_t)
        @param tif (C++: const  tinfo_t  *)
    """
    return _ida_nalt.set_tinfo(*args)

def del_tinfo(*args) -> "void":
    r"""


    del_tinfo(ea)
        @param ea (C++: ea_t)
    """
    return _ida_nalt.del_tinfo(*args)

def get_op_tinfo(*args) -> "bool":
    r"""


    get_op_tinfo(tif, ea, n) -> bool
        @param tif (C++: tinfo_t  *)
        @param ea (C++: ea_t)
        @param n (C++: int)
    """
    return _ida_nalt.get_op_tinfo(*args)

def set_op_tinfo(*args) -> "bool":
    r"""


    set_op_tinfo(ea, n, tif) -> bool
        @param ea (C++: ea_t)
        @param n (C++: int)
        @param tif (C++: const  tinfo_t  *)
    """
    return _ida_nalt.set_op_tinfo(*args)

def del_op_tinfo(*args) -> "void":
    r"""


    del_op_tinfo(ea, n)
        @param ea (C++: ea_t)
        @param n (C++: int)
    """
    return _ida_nalt.del_op_tinfo(*args)
RIDX_FILE_FORMAT_NAME = _ida_nalt.RIDX_FILE_FORMAT_NAME
"""
file format name for loader modules
"""

RIDX_SELECTORS = _ida_nalt.RIDX_SELECTORS
"""
2..63 are for selector_t blob (see init_selectors())
"""

RIDX_GROUPS = _ida_nalt.RIDX_GROUPS
"""
segment group information (see init_groups())
"""

RIDX_H_PATH = _ida_nalt.RIDX_H_PATH
"""
C header path.
"""

RIDX_C_MACROS = _ida_nalt.RIDX_C_MACROS
"""
C predefined macros.
"""

RIDX_SMALL_IDC_OLD = _ida_nalt.RIDX_SMALL_IDC_OLD
"""
Instant IDC statements (obsolete)
"""

RIDX_NOTEPAD = _ida_nalt.RIDX_NOTEPAD
"""
notepad blob, occupies 1000 indexes (1MB of text)
"""

RIDX_INCLUDE = _ida_nalt.RIDX_INCLUDE
"""
assembler include file name
"""

RIDX_SMALL_IDC = _ida_nalt.RIDX_SMALL_IDC
"""
Instant IDC statements, blob.
"""

RIDX_DUALOP_GRAPH = _ida_nalt.RIDX_DUALOP_GRAPH
"""
Graph text representation options.
"""

RIDX_DUALOP_TEXT = _ida_nalt.RIDX_DUALOP_TEXT
"""
Text text representation options.
"""

RIDX_MD5 = _ida_nalt.RIDX_MD5
"""
MD5 of the input file.
"""

RIDX_IDA_VERSION = _ida_nalt.RIDX_IDA_VERSION
"""
version of ida which created the database
"""

RIDX_STR_ENCODINGS = _ida_nalt.RIDX_STR_ENCODINGS
"""
a list of encodings for the program strings
"""

RIDX_SRCDBG_PATHS = _ida_nalt.RIDX_SRCDBG_PATHS
"""
source debug paths, occupies 20 indexes
"""

RIDX_SELECTED_EXTLANG = _ida_nalt.RIDX_SELECTED_EXTLANG
"""
last selected extlang name (from the execute script box)
"""

RIDX_DBG_BINPATHS = _ida_nalt.RIDX_DBG_BINPATHS
"""
unused (20 indexes)
"""

RIDX_SHA256 = _ida_nalt.RIDX_SHA256
"""
SHA256 of the input file.
"""

RIDX_ABINAME = _ida_nalt.RIDX_ABINAME
"""
ABI name (processor specific)
"""

RIDX_ARCHIVE_PATH = _ida_nalt.RIDX_ARCHIVE_PATH
"""
archive file path
"""

RIDX_PROBLEMS = _ida_nalt.RIDX_PROBLEMS
"""
problem lists
"""

RIDX_SRCDBG_UNDESIRED = _ida_nalt.RIDX_SRCDBG_UNDESIRED
"""
user-closed source files, occupies 20 indexes
"""


def get_root_filename(*args) -> "size_t":
    r"""


    Get file name only of the input file.
    """
    return _ida_nalt.get_root_filename(*args)

def dbg_get_input_path(*args) -> "size_t":
    r"""


    Get debugger input file name/path (see 'LFLG_DBG_NOPATH' )
    """
    return _ida_nalt.dbg_get_input_path(*args)

def get_input_file_path(*args) -> "size_t":
    r"""


    Get full path of the input file.
    """
    return _ida_nalt.get_input_file_path(*args)

def set_root_filename(*args) -> "void":
    r"""


    Set full path of the input file.
    
    set_root_filename(file)
        @param file (C++: const char *)
    """
    return _ida_nalt.set_root_filename(*args)

def retrieve_input_file_size(*args) -> "uint32":
    r"""


    Get size of input file in bytes.
    """
    return _ida_nalt.retrieve_input_file_size(*args)

def retrieve_input_file_crc32(*args) -> "uint32":
    r"""


    Get input file crc32 stored in the database. it can be used to check
    that the input file has not been changed.
    """
    return _ida_nalt.retrieve_input_file_crc32(*args)

def retrieve_input_file_md5(*args) -> "uchar [ANY]":
    r"""


    Get input file md5.
    """
    return _ida_nalt.retrieve_input_file_md5(*args)

def retrieve_input_file_sha256(*args) -> "uchar [ANY]":
    r"""


    Get input file sha256.
    """
    return _ida_nalt.retrieve_input_file_sha256(*args)

def get_asm_inc_file(*args) -> "qstring *":
    r"""


    Get name of the include file.
    """
    return _ida_nalt.get_asm_inc_file(*args)

def set_asm_inc_file(*args) -> "bool":
    r"""


    Set name of the include file.
    
    set_asm_inc_file(file) -> bool
        @param file (C++: const char *)
    """
    return _ida_nalt.set_asm_inc_file(*args)

def get_imagebase(*args) -> "ea_t":
    r"""


    Get image base address.
    """
    return _ida_nalt.get_imagebase(*args)

def set_imagebase(*args) -> "void":
    r"""


    Set image base address.
    
    set_imagebase(base)
        @param base (C++: ea_t)
    """
    return _ida_nalt.set_imagebase(*args)

def get_ids_modnode(*args) -> "netnode":
    r"""


    Get ids modnode.
    """
    return _ida_nalt.get_ids_modnode(*args)

def set_ids_modnode(*args) -> "void":
    r"""


    Set ids modnode.
    
    set_ids_modnode(id)
        @param id (C++: netnode)
    """
    return _ida_nalt.set_ids_modnode(*args)

def get_archive_path(*args) -> "qstring *":
    r"""


    Get archive file path from which input file was extracted.
    """
    return _ida_nalt.get_archive_path(*args)

def set_archive_path(*args) -> "bool":
    r"""


    Set archive file path from which input file was extracted.
    
    set_archive_path(file) -> bool
        @param file (C++: const char *)
    """
    return _ida_nalt.set_archive_path(*args)

def get_encoding_qty(*args) -> "int":
    r"""


    Get total number of encodings (counted from 0)
    """
    return _ida_nalt.get_encoding_qty(*args)

def get_encoding_name(*args) -> "char const *":
    r"""


    Get encoding name for specific index (1-based).
    
    get_encoding_name(idx) -> char const *
        @param idx (C++: int)
        @return: NULL if idx is out of bounds
    """
    return _ida_nalt.get_encoding_name(*args)

def add_encoding(*args) -> "int":
    r"""


    Add a new encoding (e.g. "UTF-8").
    
    add_encoding(encoding) -> int
        @param encoding (C++: const char *)
        @return: its index (1-based) if it's already in the list, return its
                 index
    """
    return _ida_nalt.add_encoding(*args)

def del_encoding(*args) -> "bool":
    r"""


    Delete an encoding (1-based)
    
    del_encoding(idx) -> bool
        @param idx (C++: int)
    """
    return _ida_nalt.del_encoding(*args)

def rename_encoding(*args) -> "bool":
    r"""


    Change name for an encoding (1-based)
    
    rename_encoding(idx, encoding) -> bool
        @param idx (C++: int)
        @param encoding (C++: const char *)
    """
    return _ida_nalt.rename_encoding(*args)
BPU_1B = _ida_nalt.BPU_1B

BPU_2B = _ida_nalt.BPU_2B

BPU_4B = _ida_nalt.BPU_4B


def get_encoding_bpu(*args) -> "int":
    r"""


    Get the amount of bytes per unit (e.g., 2 for UTF-16, 4 for UTF-32)
    for the encoding with the given index.
    
    get_encoding_bpu(idx) -> int
        @param idx: the encoding index (C++: int)
        @return: the number of bytes per units (1/2/4); -1 means error
    """
    return _ida_nalt.get_encoding_bpu(*args)

def get_strtype_bpu(*args) -> "int":
    r"""


    get_strtype_bpu(strtype) -> int
        @param strtype (C++: int32)
    """
    return _ida_nalt.get_strtype_bpu(*args)

def get_default_encoding_idx(*args) -> "int":
    r"""


    Get default encoding index for a specific string type.
    
    get_default_encoding_idx(bpu) -> int
        @param bpu: the amount of bytes per unit (e.g., 1 for ASCII, CP1252,
                    UTF-8..., 2 for UTF-16, 4 for UTF-32) 0 means no specific
                    encoding is set - byte values are displayed without
                    conversion. (C++: int)
    """
    return _ida_nalt.get_default_encoding_idx(*args)

def set_default_encoding_idx(*args) -> "bool":
    r"""


    set default encoding for a string type
    
    set_default_encoding_idx(bpu, idx) -> bool
        @param bpu: the amount of bytes per unit (C++: int)
        @param idx: the encoding index idx can be 0 to disable encoding
                    conversion (C++: int)
    """
    return _ida_nalt.set_default_encoding_idx(*args)

def encoding_from_strtype(*args) -> "char const *":
    r"""


    Get encoding name for this strtype.
    
    encoding_from_strtype(strtype) -> char const *
        @param strtype (C++: int32)
    """
    return _ida_nalt.encoding_from_strtype(*args)

def get_outfile_encoding_idx(*args) -> "int":
    r"""


    Get the index of the encoding used when producing files 0 means no
    that the IDB's default 1 byte-per-unit encoding is used
    """
    return _ida_nalt.get_outfile_encoding_idx(*args)

def set_outfile_encoding_idx(*args) -> "bool":
    r"""


    set encoding to be used when producing files
    
    set_outfile_encoding_idx(idx) -> bool
        @param idx: the encoding index idx can be 0 to use the IDB's default
                    1-byte-per-unit encoding (C++: int)
    """
    return _ida_nalt.set_outfile_encoding_idx(*args)

def get_import_module_qty(*args) -> "uint":
    r"""


    Get number of import modules.
    """
    return _ida_nalt.get_import_module_qty(*args)

def delete_imports(*args) -> "void":
    r"""


    Delete all imported modules information.
    """
    return _ida_nalt.delete_imports(*args)

def validate_idb_names(*args) -> "int":
    r"""


    validate_idb_names(do_repair) -> int
        do_repair: bool
    """
    return _ida_nalt.validate_idb_names(*args)

def set_gotea(*args) -> "void":
    r"""


    set_gotea(gotea)
        @param gotea (C++: ea_t)
    """
    return _ida_nalt.set_gotea(*args)

def get_gotea(*args) -> "ea_t":
    r"""
    get_gotea() -> ea_t
    """
    return _ida_nalt.get_gotea(*args)

def get_import_module_name(*args) -> "PyObject *":
    r"""


    get_import_module_name(mod_index) -> PyObject *
    Returns the name of an imported module given its index
    @return: None or the module name
    """
    return _ida_nalt.get_import_module_name(*args)

def enum_import_names(*args) -> "int":
    r"""


    enum_import_names(mod_index, py_cb) -> int
    Enumerate imports from a specific module.
    Please refer to ex_imports.py example.
    
    @param mod_index: The module index
    @param callback: A callable object that will be invoked with an ea, name (could be None) and ordinal.
    @return: 1-finished ok, -1 on error, otherwise callback return value (<=0)
    """
    return _ida_nalt.enum_import_names(*args)

def switch_info_t__from_ptrval__(*args) -> "switch_info_t *":
    r"""


    switch_info_t__from_ptrval__(ptrval) -> switch_info_t
        ptrval: size_t
    """
    return _ida_nalt.switch_info_t__from_ptrval__(*args)

#<pycode(py_nalt)>
_real_get_switch_info = get_switch_info
def get_switch_info(*args):
    if len(args) == 1:
        si, ea = switch_info_t(), args[0]
    else:
        si, ea = args
    return None if _real_get_switch_info(si, ea) <= 0 else si
def get_abi_name(*args):
    import ida_typeinf
    return ida_typeinf.get_abi_name(args)
#</pycode(py_nalt)>


if _BC695:
    ASCSTR_LAST=7
    ASCSTR_LEN2=STRTYPE_LEN2
    ASCSTR_LEN4=STRTYPE_LEN4
    ASCSTR_PASCAL=STRTYPE_PASCAL
    ASCSTR_TERMCHR=STRTYPE_TERMCHR
    ASCSTR_ULEN2=STRTYPE_LEN2_16
    ASCSTR_ULEN4=STRTYPE_LEN4_16
    ASCSTR_UNICODE=STRTYPE_C_16
    ASCSTR_UTF16=STRTYPE_C_16
    ASCSTR_UTF32=STRTYPE_C_32
    REF_VHIGH=V695_REF_VHIGH
    REF_VLOW=V695_REF_VLOW
    SWI_END_IN_TBL=SWI_DEF_IN_TBL
    SWI_BC695_EXTENDED=0x8000
    SWI2_INDIRECT=SWI_INDIRECT >> 16
    SWI2_SUBTRACT=SWI_SUBTRACT >> 16
    import ida_netnode
    RIDX_AUTO_PLUGINS=ida_netnode.BADNODE
    change_encoding_name=rename_encoding
    def del_tinfo2(ea, n=None):
        if n is not None:
            return del_op_tinfo(ea, n)
        else:
            return del_tinfo(ea)
    get_encodings_count=get_encoding_qty
    def get_op_tinfo(*args):
        import ida_typeinf
        if isinstance(args[2], ida_typeinf.tinfo_t): # 6.95: ea, n, tinfo_t
            ea, n, tif = args
        else:                                        # 7.00: tinfo_t, ea, n
            tif, ea, n = args
        return _ida_nalt.get_op_tinfo(tif, ea, n)
    get_op_tinfo2=get_op_tinfo
    def is_unicode(strtype):
        return (strtype & STRWIDTH_MASK) > 0
    set_op_tinfo2=set_op_tinfo
    set_tinfo2=set_tinfo
    def make_switch_info_t__init__(real_init):
        def wrapper(self):
            real_init(self)
            self.bc695_api = False
        return wrapper
    switch_info_t.__init__ = make_switch_info_t__init__(switch_info_t.__init__)
    switch_info_t.regdtyp = switch_info_t.regdtype
    def get_tinfo(*args):
        import ida_typeinf
        if isinstance(args[1], ida_typeinf.tinfo_t): # 6.95: ea, tinfo_t
            ea, tif = args
        else:                                        # 7.00: tinfo_t, ea
            tif, ea = args
        return _ida_nalt.get_tinfo(tif, ea)
    get_tinfo2=get_tinfo
    def get_refinfo(*args):
        if isinstance(args[2], refinfo_t): # 6.95: ea, n, refinfo_t
            ea, n, ri = args
        else:                              # 7.00: refinfo_t, ea, n
            ri, ea, n = args
        return _ida_nalt.get_refinfo(ri, ea, n)
    get_switch_info_ex=get_switch_info
    set_switch_info_ex=set_switch_info
    del_switch_info_ex=del_switch_info
    switch_info_ex_t_assign=_ida_nalt.switch_info_t_assign
    switch_info_ex_t_get_custom=_ida_nalt.switch_info_t_custom_get
    switch_info_ex_t_get_defjump=_ida_nalt.switch_info_t_defjump_get
    switch_info_ex_t_get_elbase=_ida_nalt.switch_info_t_elbase_get
    switch_info_ex_t_get_flags=_ida_nalt.switch_info_t_flags_get
    switch_info_ex_t_get_ind_lowcase=_ida_nalt.switch_info_t_ind_lowcase_get
    switch_info_ex_t_get_jcases=_ida_nalt.switch_info_t_jcases_get
    switch_info_ex_t_get_jumps=_ida_nalt.switch_info_t_jumps_get
    switch_info_ex_t_get_ncases=_ida_nalt.switch_info_t_ncases_get
    switch_info_ex_t_get_regdtyp=_ida_nalt.switch_info_t_regdtype_get
    switch_info_ex_t_get_regnum=_ida_nalt.switch_info_t_regnum_get
    switch_info_ex_t_get_startea=_ida_nalt.switch_info_t_startea_get
    switch_info_ex_t_get_values_lowcase=_ida_nalt.switch_info_t__get_values_lowcase
    switch_info_ex_t_set_custom=_ida_nalt.switch_info_t_custom_set
    switch_info_ex_t_set_defjump=_ida_nalt.switch_info_t_defjump_set
    switch_info_ex_t_set_elbase=_ida_nalt.switch_info_t_elbase_set
    switch_info_ex_t_set_flags=_ida_nalt.switch_info_t_flags_set
    switch_info_ex_t_set_ind_lowcase=_ida_nalt.switch_info_t_ind_lowcase_set
    switch_info_ex_t_set_jcases=_ida_nalt.switch_info_t_jcases_set
    switch_info_ex_t_set_jumps=_ida_nalt.switch_info_t_jumps_set
    switch_info_ex_t_set_ncases=_ida_nalt.switch_info_t_ncases_set
    switch_info_ex_t_set_regdtyp=_ida_nalt.switch_info_t_regdtype_set
    switch_info_ex_t_set_regnum=_ida_nalt.switch_info_t_regnum_set
    switch_info_ex_t_set_startea=_ida_nalt.switch_info_t_startea_set
    switch_info_ex_t_set_values_lowcase=_ida_nalt.switch_info_t__set_values_lowcase
    def __switch_info_t_get_flags__(instance):
        return _ida_nalt.switch_info_t_flags_get(instance) | SWI_BC695_EXTENDED
    def __switch_info_t_set_flags__(instance, v):
        if instance.bc695_api:
            v |= (_ida_nalt.switch_info_t_flags_get(instance) & 0xFFFF0000)
        _ida_nalt.switch_info_t_flags_set(instance, v)
    switch_info_t.flags = property(__switch_info_t_get_flags__, __switch_info_t_set_flags__)
    def __switch_info_t_get_flags2__(instance):
        instance.bc695_api = True
        return _ida_nalt.switch_info_t_flags_get(instance) >> 16
    def __switch_info_t_set_flags2__(instance, v):
        instance.bc695_api = True
        flags = _ida_nalt.switch_info_t_flags_get(instance)
        instance.flags = (flags & 0xFFFF) | (v << 16)
    switch_info_t.flags2 = property(__switch_info_t_get_flags2__, __switch_info_t_set_flags2__)
    switch_info_ex_t=switch_info_t



