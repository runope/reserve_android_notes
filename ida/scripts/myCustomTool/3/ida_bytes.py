# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.1
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

"""
IDA Plugin SDK API wrapper: bytes
"""

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _ida_bytes
else:
    import _ida_bytes

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """
    Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass
    """
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """
    Meta class to enforce nondynamic attributes (no new attributes) for a class
    """
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import weakref

SWIG_PYTHON_LEGACY_BOOL = _ida_bytes.SWIG_PYTHON_LEGACY_BOOL

import ida_idaapi


import sys
_BC695 = sys.modules["__main__"].IDAPYTHON_COMPAT_695_API

if _BC695:






    def bc695redef(func):
        ida_idaapi._BC695.replace_fun(func)
        return func

import ida_range

def enable_flags(*args) -> "error_t":
    r"""


    Allocate flags for address range. This function does not change the
    storage type of existing ranges. Exit with an error message if not
    enough disk space.
    
    enable_flags(start_ea, end_ea, stt) -> error_t
        @param start_ea: should be lower than end_ea. (C++: ea_t)
        @param end_ea: does not belong to the range. (C++: ea_t)
        @param stt: storage_type_t (C++: storage_type_t)
        @return: 0 if ok, otherwise an error code
    """
    return _ida_bytes.enable_flags(*args)

def disable_flags(*args) -> "error_t":
    r"""


    Deallocate flags for address range. Exit with an error message if not
    enough disk space (this may occur too).
    
    disable_flags(start_ea, end_ea) -> error_t
        @param start_ea: should be lower than end_ea. (C++: ea_t)
        @param end_ea: does not belong to the range. (C++: ea_t)
        @return: 0 if ok, otherwise return error code
    """
    return _ida_bytes.disable_flags(*args)

def change_storage_type(*args) -> "error_t":
    r"""


    Change flag storage type for address range.
    
    change_storage_type(start_ea, end_ea, stt) -> error_t
        @param start_ea: should be lower than end_ea. (C++: ea_t)
        @param end_ea: does not belong to the range. (C++: ea_t)
        @param stt: storage_type_t (C++: storage_type_t)
        @return: error code
    """
    return _ida_bytes.change_storage_type(*args)

def next_addr(*args) -> "ea_t":
    r"""


    Get next address in the program (i.e. next address which has flags).
    
    next_addr(ea) -> ea_t
        @param ea (C++: ea_t)
        @return: BADADDR  if no such address exist.
    """
    return _ida_bytes.next_addr(*args)

def prev_addr(*args) -> "ea_t":
    r"""


    Get previous address in the program.
    
    prev_addr(ea) -> ea_t
        @param ea (C++: ea_t)
        @return: BADADDR  if no such address exist.
    """
    return _ida_bytes.prev_addr(*args)

def next_chunk(*args) -> "ea_t":
    r"""


    Get the first address of next contiguous chunk in the program.
    
    next_chunk(ea) -> ea_t
        @param ea (C++: ea_t)
        @return: BADADDR  if next chunk doesn't exist.
    """
    return _ida_bytes.next_chunk(*args)

def prev_chunk(*args) -> "ea_t":
    r"""


    Get the last address of previous contiguous chunk in the program.
    
    prev_chunk(ea) -> ea_t
        @param ea (C++: ea_t)
        @return: BADADDR  if previous chunk doesn't exist.
    """
    return _ida_bytes.prev_chunk(*args)

def chunk_start(*args) -> "ea_t":
    r"""


    Get start of the contiguous address block containing 'ea'.
    
    chunk_start(ea) -> ea_t
        @param ea (C++: ea_t)
        @return: BADADDR  if 'ea' doesn't belong to the program.
    """
    return _ida_bytes.chunk_start(*args)

def chunk_size(*args) -> "asize_t":
    r"""


    Get size of the contiguous address block containing 'ea'.
    
    chunk_size(ea) -> asize_t
        @param ea (C++: ea_t)
        @return: 0 if 'ea' doesn't belong to the program.
    """
    return _ida_bytes.chunk_size(*args)

def free_chunk(*args) -> "ea_t":
    r"""


    Search for a hole in the addressing space of the program.
    
    free_chunk(bottom, size, step) -> ea_t
        @param bottom: address to start searching (C++: ea_t)
        @param size: size of desired block (C++: asize_t)
        @param step: bit mask for the start of hole (0xF would align hole to a
                     paragraph). if 'step' is negative, the bottom address
                     with be aligned. otherwise the kernel will try to use it
                     as is and align it only when the hole is too small. (C++:
                     int32)
        @return: start of the hole or  BADADDR
    """
    return _ida_bytes.free_chunk(*args)

def next_unknown(*args) -> "ea_t":
    r"""


    Similar to 'next_that()' , but will find the next address that is
    unexplored.
    
    next_unknown(ea, maxea) -> ea_t
        @param ea (C++: ea_t)
        @param maxea (C++: ea_t)
    """
    return _ida_bytes.next_unknown(*args)

def prev_unknown(*args) -> "ea_t":
    r"""


    Similar to 'prev_that()' , but will find the previous address that is
    unexplored.
    
    prev_unknown(ea, minea) -> ea_t
        @param ea (C++: ea_t)
        @param minea (C++: ea_t)
    """
    return _ida_bytes.prev_unknown(*args)

def prev_head(*args) -> "ea_t":
    r"""


    Get start of previous defined item.
    
    prev_head(ea, minea) -> ea_t
        @param ea: begin search at this address (C++: ea_t)
        @param minea: included in the search range (C++: ea_t)
        @return: BADADDR  if none exists.
    """
    return _ida_bytes.prev_head(*args)

def next_head(*args) -> "ea_t":
    r"""


    Get start of next defined item.
    
    next_head(ea, maxea) -> ea_t
        @param ea: begin search at this address (C++: ea_t)
        @param maxea: not included in the search range (C++: ea_t)
        @return: BADADDR  if none exists.
    """
    return _ida_bytes.next_head(*args)

def prev_not_tail(*args) -> "ea_t":
    r"""


    Get address of previous non-tail byte.
    
    prev_not_tail(ea) -> ea_t
        @param ea (C++: ea_t)
        @return: BADADDR  if none exists.
    """
    return _ida_bytes.prev_not_tail(*args)

def next_not_tail(*args) -> "ea_t":
    r"""


    Get address of next non-tail byte.
    
    next_not_tail(ea) -> ea_t
        @param ea (C++: ea_t)
        @return: BADADDR  if none exists.
    """
    return _ida_bytes.next_not_tail(*args)

def prev_visea(*args) -> "ea_t":
    r"""


    Get previous visible address.
    
    prev_visea(ea) -> ea_t
        @param ea (C++: ea_t)
        @return: BADADDR  if none exists.
    """
    return _ida_bytes.prev_visea(*args)

def next_visea(*args) -> "ea_t":
    r"""


    Get next visible address.
    
    next_visea(ea) -> ea_t
        @param ea (C++: ea_t)
        @return: BADADDR  if none exists.
    """
    return _ida_bytes.next_visea(*args)

def get_item_head(*args) -> "ea_t":
    r"""


    Get the start address of the item at 'ea'. If there is no current
    item, then 'ea' will be returned (see definition at the end of
    'bytes.hpp' source)
    
    get_item_head(ea) -> ea_t
        @param ea (C++: ea_t)
    """
    return _ida_bytes.get_item_head(*args)

def get_item_end(*args) -> "ea_t":
    r"""


    Get the end address of the item at 'ea'. The returned address doesn't
    belong to the current item. Unexplored bytes are counted as 1 byte
    entities.
    
    get_item_end(ea) -> ea_t
        @param ea (C++: ea_t)
    """
    return _ida_bytes.get_item_end(*args)

def calc_max_item_end(*args) -> "ea_t":
    r"""


    Calculate maximal reasonable end address of a new item. This function
    will limit the item with the current segment bounds.
    
    calc_max_item_end(ea, how=15) -> ea_t
        @param ea: linear address (C++: ea_t)
        @param how: when to stop the search. A combination of  Item end search
                    flags (C++: int)
        @return: end of new item. If it is not possible to create an item, it
                 will return 'ea'.
    """
    return _ida_bytes.calc_max_item_end(*args)
ITEM_END_FIXUP = _ida_bytes.ITEM_END_FIXUP
"""
stop at the first fixup
"""

ITEM_END_INITED = _ida_bytes.ITEM_END_INITED
"""
stop when initialization changes i.e.if is_loaded(ea): stop if
uninitialized byte is encounteredif !is_loaded(ea): stop if
initialized byte is encountered
"""

ITEM_END_NAME = _ida_bytes.ITEM_END_NAME
"""
stop at the first named location
"""

ITEM_END_XREF = _ida_bytes.ITEM_END_XREF
"""
stop at the first referenced location
"""


def get_item_size(*args) -> "asize_t":
    r"""


    Get size of item (instruction/data) in bytes. Unexplored bytes have
    length of 1 byte. This function never returns 0.
    
    get_item_size(ea) -> asize_t
        @param ea (C++: ea_t)
    """
    return _ida_bytes.get_item_size(*args)

def is_mapped(*args) -> "bool":
    r"""


    Is the specified address 'ea' present in the program?
    
    is_mapped(ea) -> bool
        @param ea (C++: ea_t)
    """
    return _ida_bytes.is_mapped(*args)

def get_flags_ex(*args) -> "flags_t":
    r"""


    Get flags for the specified address, extended form.
    
    get_flags_ex(ea, how) -> flags_t
        @param ea (C++: ea_t)
        @param how (C++: int)
    """
    return _ida_bytes.get_flags_ex(*args)
GFE_VALUE = _ida_bytes.GFE_VALUE
"""
get flags with 'FF_IVL' & 'MS_VAL' . It is much slower under remote
debugging because the kernel needs to read the process memory.
"""


def get_flags(*args) -> "flags_t":
    r"""


    get flags with 'FF_IVL' & 'MS_VAL' . It is much slower under remote
    debugging because the kernel needs to read the process memory.
    
    get_flags(ea) -> flags_t
        @param ea (C++: ea_t)
    """
    return _ida_bytes.get_flags(*args)

def get_full_flags(*args) -> "flags_t":
    r"""


    Get flags value for address 'ea'.
    
    get_full_flags(ea) -> flags_t
        @param ea (C++: ea_t)
        @return: 0 if address is not present in the program
    """
    return _ida_bytes.get_full_flags(*args)

def get_item_flag(*args) -> "flags_t":
    r"""


    Get flag of the item at 'ea' even if it is a tail byte of some array
    or structure. This function is used to get flags of structure members
    or array elements.
    
    get_item_flag(_from, n, ea, appzero) -> flags_t
        @param _from: linear address of the instruction which refers to 'ea'
                      (C++: ea_t)
        @param n: number of operand which refers to 'ea' (C++: int)
        @param ea: the referenced address (C++: ea_t)
        @param appzero: append a struct field name if the field offset is
                        zero? meaningful only if the name refers to a
                        structure. (C++: bool)
        @return: flags or 0 (if failed)
    """
    return _ida_bytes.get_item_flag(*args)
MS_VAL = _ida_bytes.MS_VAL
"""
Mask for byte value.
"""

FF_IVL = _ida_bytes.FF_IVL
"""
Byte has value ?
"""


def has_value(*args) -> "bool":
    r"""


    Do flags contain byte value?
    
    has_value(F) -> bool
        @param F (C++: flags_t)
    """
    return _ida_bytes.has_value(*args)

def del_value(*args) -> "void":
    r"""


    Delete byte value from flags. The corresponding byte becomes
    uninitialized.
    
    del_value(ea)
        @param ea (C++: ea_t)
    """
    return _ida_bytes.del_value(*args)

def is_loaded(*args) -> "bool":
    r"""


    Does the specified address have a byte value (is initialized?)
    
    is_loaded(ea) -> bool
        @param ea (C++: ea_t)
    """
    return _ida_bytes.is_loaded(*args)

def nbits(*args) -> "int":
    r"""


    Get number of bits in a byte at the given address.
    
    nbits(ea) -> int
        @param ea (C++: ea_t)
        @return: \ph{dnbits()} if the address doesn't belong to a segment,
                 otherwise the result depends on the segment type
    """
    return _ida_bytes.nbits(*args)

def bytesize(*args) -> "int":
    r"""


    Get number of bytes required to store a byte at the given address.
    
    bytesize(ea) -> int
        @param ea (C++: ea_t)
    """
    return _ida_bytes.bytesize(*args)

def get_byte(*args) -> "uchar":
    r"""


    Get one byte (8-bit) of the program at 'ea'. This function works only
    for 8bit byte processors.
    
    get_byte(ea) -> uchar
        @param ea (C++: ea_t)
    """
    return _ida_bytes.get_byte(*args)

def get_db_byte(*args) -> "uchar":
    r"""


    Get one byte (8-bit) of the program at 'ea' from the database. Works
    even if the debugger is active. See also 'get_dbg_byte()' to read the
    process memory directly. This function works only for 8bit byte
    processors.
    
    get_db_byte(ea) -> uchar
        @param ea (C++: ea_t)
    """
    return _ida_bytes.get_db_byte(*args)

def get_word(*args) -> "ushort":
    r"""


    Get one word (16-bit) of the program at 'ea'. This function takes into
    account order of bytes specified in \inf{is_be()} This function works
    only for 8bit byte processors.
    
    get_word(ea) -> ushort
        @param ea (C++: ea_t)
    """
    return _ida_bytes.get_word(*args)

def get_dword(*args) -> "uint32":
    r"""


    Get one dword (32-bit) of the program at 'ea'. This function takes
    into account order of bytes specified in \inf{is_be()} This function
    works only for 8bit byte processors.
    
    get_dword(ea) -> uint32
        @param ea (C++: ea_t)
    """
    return _ida_bytes.get_dword(*args)

def get_qword(*args) -> "uint64":
    r"""


    Get one qword (64-bit) of the program at 'ea'. This function takes
    into account order of bytes specified in \inf{is_be()} This function
    works only for 8bit byte processors.
    
    get_qword(ea) -> uint64
        @param ea (C++: ea_t)
    """
    return _ida_bytes.get_qword(*args)

def get_wide_byte(*args) -> "uint64":
    r"""


    Get one wide byte of the program at 'ea'. Some processors may access
    more than 8bit quantity at an address. These processors have 32-bit
    byte organization from the IDA's point of view.
    
    get_wide_byte(ea) -> uint64
        @param ea (C++: ea_t)
    """
    return _ida_bytes.get_wide_byte(*args)

def get_wide_word(*args) -> "uint64":
    r"""


    Get one wide word (2 'byte') of the program at 'ea'. Some processors
    may access more than 8bit quantity at an address. These processors
    have 32-bit byte organization from the IDA's point of view. This
    function takes into account order of bytes specified in \inf{is_be()}
    
    get_wide_word(ea) -> uint64
        @param ea (C++: ea_t)
    """
    return _ida_bytes.get_wide_word(*args)

def get_wide_dword(*args) -> "uint64":
    r"""


    Get two wide words (4 'bytes') of the program at 'ea'. Some processors
    may access more than 8bit quantity at an address. These processors
    have 32-bit byte organization from the IDA's point of view. This
    function takes into account order of bytes specified in
    \inf{is_be()}this function works incorrectly if \ph{nbits} > 16
    
    get_wide_dword(ea) -> uint64
        @param ea (C++: ea_t)
    """
    return _ida_bytes.get_wide_dword(*args)

def get_16bit(*args) -> "uint32":
    r"""


    Get 16bits of the program at 'ea'.
    
    get_16bit(ea) -> uint32
        @param ea (C++: ea_t)
        @return: 1 byte (getFullByte()) if the current processor has 16-bit
                 byte, otherwise return  get_word()
    """
    return _ida_bytes.get_16bit(*args)

def get_32bit(*args) -> "uint32":
    r"""


    Get not more than 32bits of the program at 'ea'.
    
    get_32bit(ea) -> uint32
        @param ea (C++: ea_t)
        @return: 32 bit value, depending on \ph{nbits}:   if ( nbits <= 8 )
                 return get_dword(ea);   if ( nbits <= 16) return
                 get_wide_word(ea);   return get_wide_byte(ea);
    """
    return _ida_bytes.get_32bit(*args)

def get_64bit(*args) -> "uint64":
    r"""


    Get not more than 64bits of the program at 'ea'.
    
    get_64bit(ea) -> uint64
        @param ea (C++: ea_t)
        @return: 64 bit value, depending on \ph{nbits}:   if ( nbits <= 8 )
                 return get_qword(ea);   if ( nbits <= 16) return
                 get_wide_dword(ea);   return get_wide_byte(ea);
    """
    return _ida_bytes.get_64bit(*args)

def get_data_value(*args) -> "bool":
    r"""


    Get the value at of the item at 'ea'. This function works with
    entities up to sizeof(ea_t) (bytes, word, etc)
    
    get_data_value(v, ea, size) -> bool
        @param v: pointer to the result. may be nullptr (C++: uval_t  *)
        @param ea: linear address (C++: ea_t)
        @param size: size of data to read. If 0, then the item type at 'ea'
                     will be used (C++: asize_t)
        @return: success
    """
    return _ida_bytes.get_data_value(*args)

def get_original_byte(*args) -> "uint64":
    r"""


    Get original byte value (that was before patching). This function
    works for wide byte processors too.
    
    get_original_byte(ea) -> uint64
        @param ea (C++: ea_t)
    """
    return _ida_bytes.get_original_byte(*args)

def get_original_word(*args) -> "uint64":
    r"""


    Get original word value (that was before patching). This function
    works for wide byte processors too. This function takes into account
    order of bytes specified in \inf{is_be()}
    
    get_original_word(ea) -> uint64
        @param ea (C++: ea_t)
    """
    return _ida_bytes.get_original_word(*args)

def get_original_dword(*args) -> "uint64":
    r"""


    Get original dword (that was before patching) This function works for
    wide byte processors too. This function takes into account order of
    bytes specified in \inf{is_be()}
    
    get_original_dword(ea) -> uint64
        @param ea (C++: ea_t)
    """
    return _ida_bytes.get_original_dword(*args)

def get_original_qword(*args) -> "uint64":
    r"""


    Get original qword value (that was before patching) This function
    DOESN'T work for wide byte processors too. This function takes into
    account order of bytes specified in \inf{is_be()}
    
    get_original_qword(ea) -> uint64
        @param ea (C++: ea_t)
    """
    return _ida_bytes.get_original_qword(*args)

def put_byte(*args) -> "bool":
    r"""


    Set value of one byte of the program. This function modifies the
    database. If the debugger is active then the debugged process memory
    is patched too.The original value of the byte is completely lost and
    can't be recovered by the 'get_original_byte()' function. See also
    'put_dbg_byte()' to write to the process memory directly when the
    debugger is active. This function can handle wide byte processors.
    
    put_byte(ea, x) -> bool
        @param ea: linear address (C++: ea_t)
        @param x: byte value (C++: uint64)
        @return: true if the database has been modified
    """
    return _ida_bytes.put_byte(*args)

def put_word(*args) -> "void":
    r"""


    Set value of one word of the program. This function takes into account
    order of bytes specified in \inf{is_be()} This function works for wide
    byte processors too.The original value of the word is completely lost
    and can't be recovered by the 'get_original_word()' function. ea -
    linear address x - word value
    
    put_word(ea, x)
        @param ea (C++: ea_t)
        @param x (C++: uint64)
    """
    return _ida_bytes.put_word(*args)

def put_dword(*args) -> "void":
    r"""


    Set value of one dword of the program. This function takes into
    account order of bytes specified in \inf{is_be()} This function works
    for wide byte processors too.the original value of the dword is
    completely lost and can't be recovered by the 'get_original_dword()'
    function.
    
    put_dword(ea, x)
        @param ea: linear address (C++: ea_t)
        @param x: dword value (C++: uint64)
    """
    return _ida_bytes.put_dword(*args)

def put_qword(*args) -> "void":
    r"""


    Set value of one qword (8 bytes) of the program. This function takes
    into account order of bytes specified in \inf{is_be()} This function
    DOESN'T works for wide byte processors.
    
    put_qword(ea, x)
        @param ea: linear address (C++: ea_t)
        @param x: qword value (C++: uint64)
    """
    return _ida_bytes.put_qword(*args)

def patch_byte(*args) -> "bool":
    r"""


    Patch a byte of the program. The original value of the byte is saved
    and can be obtained by 'get_original_byte()' . This function works for
    wide byte processors too.
    
    patch_byte(ea, x) -> bool
        @param ea (C++: ea_t)
        @param x (C++: uint64)
        @retval: true - the database has been modified,
        @retval: false - the debugger is running and the process' memory has
                         value 'x' at address 'ea', or the debugger is not
                         running, and the IDB has value 'x' at address 'ea
                         already.
    """
    return _ida_bytes.patch_byte(*args)

def patch_word(*args) -> "bool":
    r"""


    Patch a word of the program. The original value of the word is saved
    and can be obtained by 'get_original_word()' . This function works for
    wide byte processors too. This function takes into account order of
    bytes specified in \inf{is_be()}
    
    patch_word(ea, x) -> bool
        @param ea (C++: ea_t)
        @param x (C++: uint64)
        @retval: true - the database has been modified,
        @retval: false - the debugger is running and the process' memory has
                         value 'x' at address 'ea', or the debugger is not
                         running, and the IDB has value 'x' at address 'ea
                         already.
    """
    return _ida_bytes.patch_word(*args)

def patch_dword(*args) -> "bool":
    r"""


    Patch a dword of the program. The original value of the dword is saved
    and can be obtained by 'get_original_dword()' . This function DOESN'T
    work for wide byte processors. This function takes into account order
    of bytes specified in \inf{is_be()}
    
    patch_dword(ea, x) -> bool
        @param ea (C++: ea_t)
        @param x (C++: uint64)
        @retval: true - the database has been modified,
        @retval: false - the debugger is running and the process' memory has
                         value 'x' at address 'ea', or the debugger is not
                         running, and the IDB has value 'x' at address 'ea
                         already.
    """
    return _ida_bytes.patch_dword(*args)

def patch_qword(*args) -> "bool":
    r"""


    Patch a qword of the program. The original value of the qword is saved
    and can be obtained by 'get_original_qword()' . This function DOESN'T
    work for wide byte processors. This function takes into account order
    of bytes specified in \inf{is_be()}
    
    patch_qword(ea, x) -> bool
        @param ea (C++: ea_t)
        @param x (C++: uint64)
        @retval: true - the database has been modified,
        @retval: false - the debugger is running and the process' memory has
                         value 'x' at address 'ea', or the debugger is not
                         running, and the IDB has value 'x' at address 'ea
                         already.
    """
    return _ida_bytes.patch_qword(*args)

def revert_byte(*args) -> "bool":
    r"""


    Revert patched byte
    
    revert_byte(ea) -> bool
        @param ea (C++: ea_t)
        @retval: true - byte was patched before and reverted now
    """
    return _ida_bytes.revert_byte(*args)

def add_byte(*args) -> "void":
    r"""


    Add a value to one byte of the program. This function works for wide
    byte processors too.
    
    add_byte(ea, value)
        @param ea: linear address (C++: ea_t)
        @param value: byte value (C++: uint32)
    """
    return _ida_bytes.add_byte(*args)

def add_word(*args) -> "void":
    r"""


    Add a value to one word of the program. This function works for wide
    byte processors too. This function takes into account order of bytes
    specified in \inf{is_be()}
    
    add_word(ea, value)
        @param ea: linear address (C++: ea_t)
        @param value: byte value (C++: uint64)
    """
    return _ida_bytes.add_word(*args)

def add_dword(*args) -> "void":
    r"""


    Add a value to one dword of the program. This function works for wide
    byte processors too. This function takes into account order of bytes
    specified in \inf{is_be()}this function works incorrectly if
    \ph{nbits} > 16
    
    add_dword(ea, value)
        @param ea: linear address (C++: ea_t)
        @param value: byte value (C++: uint64)
    """
    return _ida_bytes.add_dword(*args)

def add_qword(*args) -> "void":
    r"""


    Add a value to one qword of the program. This function does not work
    for wide byte processors. This function takes into account order of
    bytes specified in \inf{is_be()}
    
    add_qword(ea, value)
        @param ea: linear address (C++: ea_t)
        @param value: byte value (C++: uint64)
    """
    return _ida_bytes.add_qword(*args)

def get_zero_ranges(*args) -> "bool":
    r"""


    Return set of ranges with zero initialized bytes. The returned set
    includes only big zero initialized ranges (at least >1KB). Some zero
    initialized byte ranges may be not included. Only zero bytes that use
    the sparse storage method (STT_MM) are reported.
    
    get_zero_ranges(zranges, range) -> bool
        @param zranges: pointer to the return value. cannot be nullptr (C++:
                        rangeset_t  *)
        @param range: the range of addresses to verify. can be nullptr - means
                      all ranges (C++: const  range_t  *)
        @return: true if the result is a non-empty set
    """
    return _ida_bytes.get_zero_ranges(*args)
GMB_READALL = _ida_bytes.GMB_READALL
"""
if this bit is not set, fail at first uninited byte

try to read all bytes
"""

GMB_WAITBOX = _ida_bytes.GMB_WAITBOX
"""
show wait box (may return -1 in this case)
"""


def put_bytes(*args) -> "void":
    r"""


    Modify the specified number of bytes of the program. This function
    does not save the original values of bytes. See also 'patch_bytes()' .
    
    put_bytes(ea, buf)
        @param ea: linear address (C++: ea_t)
        @param buf: buffer with new values of bytes (C++: const void *)
    """
    return _ida_bytes.put_bytes(*args)

def patch_bytes(*args) -> "void":
    r"""


    Patch the specified number of bytes of the program. Original values of
    bytes are saved and are available with get_original...() functions.
    See also 'put_bytes()' .
    
    patch_bytes(ea, buf)
        @param ea: linear address (C++: ea_t)
        @param buf: buffer with new values of bytes (C++: const void *)
    """
    return _ida_bytes.patch_bytes(*args)
MS_CLS = _ida_bytes.MS_CLS
"""
Mask for typing.
"""

FF_CODE = _ida_bytes.FF_CODE
"""
Code ?
"""

FF_DATA = _ida_bytes.FF_DATA
"""
Data ?
"""

FF_TAIL = _ida_bytes.FF_TAIL
"""
Tail ?
"""

FF_UNK = _ida_bytes.FF_UNK
"""
Unknown ?
"""


def is_code(*args) -> "bool":
    r"""


    Does flag denote start of an instruction?
    
    is_code(F) -> bool
        @param F (C++: flags_t)
    """
    return _ida_bytes.is_code(*args)

def f_is_code(*args) -> "bool":
    r"""


    Does flag denote start of an instruction?
    
    f_is_code(F, arg2) -> bool
        @param F (C++: flags_t)
        arg2: void *
    """
    return _ida_bytes.f_is_code(*args)

def is_data(*args) -> "bool":
    r"""


    Does flag denote start of data?
    
    is_data(F) -> bool
        @param F (C++: flags_t)
    """
    return _ida_bytes.is_data(*args)

def f_is_data(*args) -> "bool":
    r"""


    Does flag denote start of data?
    
    f_is_data(F, arg2) -> bool
        @param F (C++: flags_t)
        arg2: void *
    """
    return _ida_bytes.f_is_data(*args)

def is_tail(*args) -> "bool":
    r"""


    Does flag denote tail byte?
    
    is_tail(F) -> bool
        @param F (C++: flags_t)
    """
    return _ida_bytes.is_tail(*args)

def f_is_tail(*args) -> "bool":
    r"""


    Does flag denote tail byte?
    
    f_is_tail(F, arg2) -> bool
        @param F (C++: flags_t)
        arg2: void *
    """
    return _ida_bytes.f_is_tail(*args)

def is_not_tail(*args) -> "bool":
    r"""


    Does flag denote tail byte?
    
    is_not_tail(F) -> bool
        @param F (C++: flags_t)
    """
    return _ida_bytes.is_not_tail(*args)

def f_is_not_tail(*args) -> "bool":
    r"""


    Does flag denote tail byte?
    
    f_is_not_tail(F, arg2) -> bool
        @param F (C++: flags_t)
        arg2: void *
    """
    return _ida_bytes.f_is_not_tail(*args)

def is_unknown(*args) -> "bool":
    r"""


    Does flag denote unexplored byte?
    
    is_unknown(F) -> bool
        @param F (C++: flags_t)
    """
    return _ida_bytes.is_unknown(*args)

def is_head(*args) -> "bool":
    r"""


    Does flag denote start of instruction OR data?
    
    is_head(F) -> bool
        @param F (C++: flags_t)
    """
    return _ida_bytes.is_head(*args)

def f_is_head(*args) -> "bool":
    r"""


    Does flag denote start of instruction OR data?
    
    f_is_head(F, arg2) -> bool
        @param F (C++: flags_t)
        arg2: void *
    """
    return _ida_bytes.f_is_head(*args)

def del_items(*args) -> "bool":
    r"""


    Convert item (instruction/data) to unexplored bytes. The whole item
    (including the head and tail bytes) will be destroyed. It is allowed
    to pass any address in the item to this function
    
    del_items(ea, flags=0, nbytes=1, may_destroy=None) -> bool
        @param ea: any address within the first item to delete (C++: ea_t)
        @param flags: combination of  Unexplored byte conversion flags (C++:
                      int)
        @param nbytes: number of bytes in the range to be undefined (C++:
                       asize_t)
        @param may_destroy: optional routine invoked before deleting a head
                            item. If callback returns false then item has not
                            to be deleted and operation fails (C++:
                            may_destroy_cb_t  *)
        @return: true on sucessful operation, otherwise false
    """
    return _ida_bytes.del_items(*args)
DELIT_SIMPLE = _ida_bytes.DELIT_SIMPLE
"""
simply undefine the specified item(s)
"""

DELIT_EXPAND = _ida_bytes.DELIT_EXPAND
"""
propagate undefined items; for example if removing an instruction
removes all references to the next instruction, then plan to convert
to unexplored the next instruction too.
"""

DELIT_DELNAMES = _ida_bytes.DELIT_DELNAMES
"""
delete any names at the specified address range (except for the
starting address). this bit is valid if nbytes > 1
"""

DELIT_NOTRUNC = _ida_bytes.DELIT_NOTRUNC
"""
even if 'AF_TRFUNC' is set

don't truncate the current function
"""

DELIT_NOUNAME = _ida_bytes.DELIT_NOUNAME
"""
reject to delete if a user name is in address range (except for the
starting address). this bit is valid if nbytes > 1
"""

DELIT_NOCMT = _ida_bytes.DELIT_NOCMT
"""
reject to delete if a comment is in address range (except for the
starting address). this bit is valid if nbytes > 1
"""

DELIT_KEEPFUNC = _ida_bytes.DELIT_KEEPFUNC
"""
Just delete xrefs, ops e.t.c.

do not undefine the function start.
"""


def is_manual_insn(*args) -> "bool":
    r"""


    Is the instruction overridden?
    
    is_manual_insn(ea) -> bool
        @param ea: linear address of the instruction or data item (C++: ea_t)
    """
    return _ida_bytes.is_manual_insn(*args)

def get_manual_insn(*args) -> "qstring *":
    r"""


    Retrieve the user-specified string for the manual instruction.
    
    get_manual_insn(ea) -> str
        @param ea: linear address of the instruction or data item (C++: ea_t)
        @return: size of manual instruction or -1
    """
    return _ida_bytes.get_manual_insn(*args)

def set_manual_insn(*args) -> "void":
    r"""


    Set manual instruction string.
    
    set_manual_insn(ea, manual_insn)
        @param ea: linear address of the instruction or data item (C++: ea_t)
        @param manual_insn: "" - delete manual string. nullptr - do nothing
                            (C++: const char *)
    """
    return _ida_bytes.set_manual_insn(*args)
MS_COMM = _ida_bytes.MS_COMM
"""
Mask of common bits.
"""

FF_COMM = _ida_bytes.FF_COMM
"""
Has comment ?
"""

FF_REF = _ida_bytes.FF_REF
"""
has references
"""

FF_LINE = _ida_bytes.FF_LINE
"""
Has next or prev lines ?
"""

FF_NAME = _ida_bytes.FF_NAME
"""
Has name ?
"""

FF_LABL = _ida_bytes.FF_LABL
"""
Has dummy name?
"""

FF_FLOW = _ida_bytes.FF_FLOW
"""
Exec flow from prev instruction.
"""

FF_SIGN = _ida_bytes.FF_SIGN
"""
Inverted sign of operands.
"""

FF_BNOT = _ida_bytes.FF_BNOT
"""
Bitwise negation of operands.
"""

FF_UNUSED = _ida_bytes.FF_UNUSED
"""
unused bit (was used for variable bytes)
"""


def is_flow(*args) -> "bool":
    r"""


    Does the previous instruction exist and pass execution flow to the
    current byte?
    
    is_flow(F) -> bool
        @param F (C++: flags_t)
    """
    return _ida_bytes.is_flow(*args)

def has_extra_cmts(*args) -> "bool":
    r"""


    Does the current byte have additional anterior or posterior lines?
    
    has_extra_cmts(F) -> bool
        @param F (C++: flags_t)
    """
    return _ida_bytes.has_extra_cmts(*args)

def f_has_extra_cmts(*args) -> "bool":
    r"""


    f_has_extra_cmts(f, arg2) -> bool
        @param f (C++: flags_t)
        arg2: void *
    """
    return _ida_bytes.f_has_extra_cmts(*args)

def has_cmt(*args) -> "bool":
    r"""


    Does the current byte have an indented comment?
    
    has_cmt(F) -> bool
        @param F (C++: flags_t)
    """
    return _ida_bytes.has_cmt(*args)

def f_has_cmt(*args) -> "bool":
    r"""


    f_has_cmt(f, arg2) -> bool
        @param f (C++: flags_t)
        arg2: void *
    """
    return _ida_bytes.f_has_cmt(*args)

def has_xref(*args) -> "bool":
    r"""


    Does the current byte have cross-references to it?
    
    has_xref(F) -> bool
        @param F (C++: flags_t)
    """
    return _ida_bytes.has_xref(*args)

def f_has_xref(*args) -> "bool":
    r"""


    Does the current byte have cross-references to it?
    
    f_has_xref(f, arg2) -> bool
        @param f (C++: flags_t)
        arg2: void *
    """
    return _ida_bytes.f_has_xref(*args)

def has_name(*args) -> "bool":
    r"""


    Does the current byte have non-trivial (non-dummy) name?
    
    has_name(F) -> bool
        @param F (C++: flags_t)
    """
    return _ida_bytes.has_name(*args)

def f_has_name(*args) -> "bool":
    r"""


    Does the current byte have non-trivial (non-dummy) name?
    
    f_has_name(f, arg2) -> bool
        @param f (C++: flags_t)
        arg2: void *
    """
    return _ida_bytes.f_has_name(*args)
FF_ANYNAME = _ida_bytes.FF_ANYNAME


def has_dummy_name(*args) -> "bool":
    r"""


    Does the current byte have dummy (auto-generated, with special prefix)
    name?
    
    has_dummy_name(F) -> bool
        @param F (C++: flags_t)
    """
    return _ida_bytes.has_dummy_name(*args)

def f_has_dummy_name(*args) -> "bool":
    r"""


    Does the current byte have dummy (auto-generated, with special prefix)
    name?
    
    f_has_dummy_name(f, arg2) -> bool
        @param f (C++: flags_t)
        arg2: void *
    """
    return _ida_bytes.f_has_dummy_name(*args)

def has_auto_name(*args) -> "bool":
    r"""


    Does the current byte have auto-generated (no special prefix) name?
    
    has_auto_name(F) -> bool
        @param F (C++: flags_t)
    """
    return _ida_bytes.has_auto_name(*args)

def has_any_name(*args) -> "bool":
    r"""


    Does the current byte have any name?
    
    has_any_name(F) -> bool
        @param F (C++: flags_t)
    """
    return _ida_bytes.has_any_name(*args)

def has_user_name(*args) -> "bool":
    r"""


    Does the current byte have user-specified name?
    
    has_user_name(F) -> bool
        @param F (C++: flags_t)
    """
    return _ida_bytes.has_user_name(*args)

def f_has_user_name(*args) -> "bool":
    r"""


    Does the current byte have user-specified name?
    
    f_has_user_name(F, arg2) -> bool
        @param F (C++: flags_t)
        arg2: void *
    """
    return _ida_bytes.f_has_user_name(*args)

def is_invsign(*args) -> "bool":
    r"""


    Should sign of n-th operand inverted during output?. allowed values of
    n: 0-first operand, 1-other operands
    
    is_invsign(ea, F, n) -> bool
        @param ea (C++: ea_t)
        @param F (C++: flags_t)
        @param n (C++: int)
    """
    return _ida_bytes.is_invsign(*args)

def toggle_sign(*args) -> "bool":
    r"""


    Toggle sign of n-th operand. allowed values of n: 0-first operand,
    1-other operands
    
    toggle_sign(ea, n) -> bool
        @param ea (C++: ea_t)
        @param n (C++: int)
    """
    return _ida_bytes.toggle_sign(*args)

def is_bnot(*args) -> "bool":
    r"""


    Should we negate the operand?. \ash{a_bnot} should be defined in the
    idp module in order to work with this function
    
    is_bnot(ea, F, n) -> bool
        @param ea (C++: ea_t)
        @param F (C++: flags_t)
        @param n (C++: int)
    """
    return _ida_bytes.is_bnot(*args)

def toggle_bnot(*args) -> "bool":
    r"""


    Toggle binary negation of operand. also see 'is_bnot()'
    
    toggle_bnot(ea, n) -> bool
        @param ea (C++: ea_t)
        @param n (C++: int)
    """
    return _ida_bytes.toggle_bnot(*args)

def is_lzero(*args) -> "bool":
    r"""


    Display leading zeroes in operands. The global switch for the leading
    zeroes is in \inf{s_genflags} The leading zeroes doesn't work if the
    octal numbers start with 0 Display leading zeroes? (takes into account
    \inf{s_genflags})
    
    is_lzero(ea, n) -> bool
        @param ea (C++: ea_t)
        @param n (C++: int)
    """
    return _ida_bytes.is_lzero(*args)

def set_lzero(*args) -> "bool":
    r"""


    Set toggle lzero bit.
    
    set_lzero(ea, n) -> bool
        @param ea (C++: ea_t)
        @param n (C++: int)
    """
    return _ida_bytes.set_lzero(*args)

def clr_lzero(*args) -> "bool":
    r"""


    Clear lzero bit.
    
    clr_lzero(ea, n) -> bool
        @param ea (C++: ea_t)
        @param n (C++: int)
    """
    return _ida_bytes.clr_lzero(*args)

def toggle_lzero(*args) -> "bool":
    r"""


    toggle_lzero(ea, n) -> bool
        @param ea (C++: ea_t)
        @param n (C++: int)
    """
    return _ida_bytes.toggle_lzero(*args)

def leading_zero_important(*args) -> "bool":
    r"""


    Check if leading zeroes are important.
    
    leading_zero_important(ea, n) -> bool
        @param ea (C++: ea_t)
        @param n (C++: int)
    """
    return _ida_bytes.leading_zero_important(*args)
MS_0TYPE = _ida_bytes.MS_0TYPE
"""
Mask for 1st arg typing.
"""

FF_0VOID = _ida_bytes.FF_0VOID
"""
Void (unknown)?
"""

FF_0NUMH = _ida_bytes.FF_0NUMH
"""
Hexadecimal number?
"""

FF_0NUMD = _ida_bytes.FF_0NUMD
"""
Decimal number?
"""

FF_0CHAR = _ida_bytes.FF_0CHAR
"""
Char ('x')?
"""

FF_0SEG = _ida_bytes.FF_0SEG
"""
Segment?
"""

FF_0OFF = _ida_bytes.FF_0OFF
"""
Offset?
"""

FF_0NUMB = _ida_bytes.FF_0NUMB
"""
Binary number?
"""

FF_0NUMO = _ida_bytes.FF_0NUMO
"""
Octal number?
"""

FF_0ENUM = _ida_bytes.FF_0ENUM
"""
Enumeration?
"""

FF_0FOP = _ida_bytes.FF_0FOP
"""
Forced operand?
"""

FF_0STRO = _ida_bytes.FF_0STRO
"""
Struct offset?
"""

FF_0STK = _ida_bytes.FF_0STK
"""
Stack variable?
"""

FF_0FLT = _ida_bytes.FF_0FLT
"""
Floating point number?
"""

FF_0CUST = _ida_bytes.FF_0CUST
"""
Custom representation?
"""

MS_1TYPE = _ida_bytes.MS_1TYPE
"""
Mask for the type of other operands.
"""

FF_1VOID = _ida_bytes.FF_1VOID
"""
Void (unknown)?
"""

FF_1NUMH = _ida_bytes.FF_1NUMH
"""
Hexadecimal number?
"""

FF_1NUMD = _ida_bytes.FF_1NUMD
"""
Decimal number?
"""

FF_1CHAR = _ida_bytes.FF_1CHAR
"""
Char ('x')?
"""

FF_1SEG = _ida_bytes.FF_1SEG
"""
Segment?
"""

FF_1OFF = _ida_bytes.FF_1OFF
"""
Offset?
"""

FF_1NUMB = _ida_bytes.FF_1NUMB
"""
Binary number?
"""

FF_1NUMO = _ida_bytes.FF_1NUMO
"""
Octal number?
"""

FF_1ENUM = _ida_bytes.FF_1ENUM
"""
Enumeration?
"""

FF_1FOP = _ida_bytes.FF_1FOP
"""
Forced operand?
"""

FF_1STRO = _ida_bytes.FF_1STRO
"""
Struct offset?
"""

FF_1STK = _ida_bytes.FF_1STK
"""
Stack variable?
"""

FF_1FLT = _ida_bytes.FF_1FLT
"""
Floating point number?
"""

FF_1CUST = _ida_bytes.FF_1CUST
"""
Custom representation?
"""


def is_defarg0(*args) -> "bool":
    r"""


    Is the first operand defined? Initially operand has no defined
    representation.
    
    is_defarg0(F) -> bool
        @param F (C++: flags_t)
    """
    return _ida_bytes.is_defarg0(*args)

def is_defarg1(*args) -> "bool":
    r"""


    Is the second operand defined? Initially operand has no defined
    representation.
    
    is_defarg1(F) -> bool
        @param F (C++: flags_t)
    """
    return _ida_bytes.is_defarg1(*args)

def is_off0(*args) -> "bool":
    r"""


    Is the first operand offset? (example: push offset xxx)
    
    is_off0(F) -> bool
        @param F (C++: flags_t)
    """
    return _ida_bytes.is_off0(*args)

def is_off1(*args) -> "bool":
    r"""


    Is the second operand offset? (example: mov ax, offset xxx)
    
    is_off1(F) -> bool
        @param F (C++: flags_t)
    """
    return _ida_bytes.is_off1(*args)

def is_char0(*args) -> "bool":
    r"""


    Is the first operand character constant? (example: push 'a')
    
    is_char0(F) -> bool
        @param F (C++: flags_t)
    """
    return _ida_bytes.is_char0(*args)

def is_char1(*args) -> "bool":
    r"""


    Is the second operand character constant? (example: mov al, 'a')
    
    is_char1(F) -> bool
        @param F (C++: flags_t)
    """
    return _ida_bytes.is_char1(*args)

def is_seg0(*args) -> "bool":
    r"""


    Is the first operand segment selector? (example: push seg seg001)
    
    is_seg0(F) -> bool
        @param F (C++: flags_t)
    """
    return _ida_bytes.is_seg0(*args)

def is_seg1(*args) -> "bool":
    r"""


    Is the second operand segment selector? (example: mov dx, seg dseg)
    
    is_seg1(F) -> bool
        @param F (C++: flags_t)
    """
    return _ida_bytes.is_seg1(*args)

def is_enum0(*args) -> "bool":
    r"""


    Is the first operand a symbolic constant (enum member)?
    
    is_enum0(F) -> bool
        @param F (C++: flags_t)
    """
    return _ida_bytes.is_enum0(*args)

def is_enum1(*args) -> "bool":
    r"""


    Is the second operand a symbolic constant (enum member)?
    
    is_enum1(F) -> bool
        @param F (C++: flags_t)
    """
    return _ida_bytes.is_enum1(*args)

def is_stroff0(*args) -> "bool":
    r"""


    Is the first operand an offset within a struct?
    
    is_stroff0(F) -> bool
        @param F (C++: flags_t)
    """
    return _ida_bytes.is_stroff0(*args)

def is_stroff1(*args) -> "bool":
    r"""


    Is the second operand an offset within a struct?
    
    is_stroff1(F) -> bool
        @param F (C++: flags_t)
    """
    return _ida_bytes.is_stroff1(*args)

def is_stkvar0(*args) -> "bool":
    r"""


    Is the first operand a stack variable?
    
    is_stkvar0(F) -> bool
        @param F (C++: flags_t)
    """
    return _ida_bytes.is_stkvar0(*args)

def is_stkvar1(*args) -> "bool":
    r"""


    Is the second operand a stack variable?
    
    is_stkvar1(F) -> bool
        @param F (C++: flags_t)
    """
    return _ida_bytes.is_stkvar1(*args)

def is_float0(*args) -> "bool":
    r"""


    Is the first operand a floating point number?
    
    is_float0(F) -> bool
        @param F (C++: flags_t)
    """
    return _ida_bytes.is_float0(*args)

def is_float1(*args) -> "bool":
    r"""


    Is the second operand a floating point number?
    
    is_float1(F) -> bool
        @param F (C++: flags_t)
    """
    return _ida_bytes.is_float1(*args)

def is_custfmt0(*args) -> "bool":
    r"""


    Does the first operand use a custom data representation?
    
    is_custfmt0(F) -> bool
        @param F (C++: flags_t)
    """
    return _ida_bytes.is_custfmt0(*args)

def is_custfmt1(*args) -> "bool":
    r"""


    Does the second operand use a custom data representation?
    
    is_custfmt1(F) -> bool
        @param F (C++: flags_t)
    """
    return _ida_bytes.is_custfmt1(*args)

def is_numop0(*args) -> "bool":
    r"""


    Is the first operand a number (i.e. binary, octal, decimal or hex?)
    
    is_numop0(F) -> bool
        @param F (C++: flags_t)
    """
    return _ida_bytes.is_numop0(*args)

def is_numop1(*args) -> "bool":
    r"""


    Is the second operand a number (i.e. binary, octal, decimal or hex?)
    
    is_numop1(F) -> bool
        @param F (C++: flags_t)
    """
    return _ida_bytes.is_numop1(*args)

def get_optype_flags0(*args) -> "flags_t":
    r"""


    Get flags for first operand.
    
    get_optype_flags0(F) -> flags_t
        @param F (C++: flags_t)
    """
    return _ida_bytes.get_optype_flags0(*args)

def get_optype_flags1(*args) -> "flags_t":
    r"""


    Get flags for second operand.
    
    get_optype_flags1(F) -> flags_t
        @param F (C++: flags_t)
    """
    return _ida_bytes.get_optype_flags1(*args)
OPND_OUTER = _ida_bytes.OPND_OUTER
"""
used only in set, get, del_offset() functions

outer offset base (combined with operand number).
"""

OPND_MASK = _ida_bytes.OPND_MASK
"""
mask for operand number
"""

OPND_ALL = _ida_bytes.OPND_ALL
"""
all operands
"""


def is_defarg(*args) -> "bool":
    r"""


    is defined?
    
    is_defarg(F, n) -> bool
        @param F (C++: flags_t)
        @param n (C++: int)
    """
    return _ida_bytes.is_defarg(*args)

def is_off(*args) -> "bool":
    r"""


    is offset?
    
    is_off(F, n) -> bool
        @param F (C++: flags_t)
        @param n (C++: int)
    """
    return _ida_bytes.is_off(*args)

def is_char(*args) -> "bool":
    r"""


    is character constant?
    
    is_char(F, n) -> bool
        @param F (C++: flags_t)
        @param n (C++: int)
    """
    return _ida_bytes.is_char(*args)

def is_seg(*args) -> "bool":
    r"""


    is segment?
    
    is_seg(F, n) -> bool
        @param F (C++: flags_t)
        @param n (C++: int)
    """
    return _ida_bytes.is_seg(*args)

def is_enum(*args) -> "bool":
    r"""


    is enum?
    
    is_enum(F, n) -> bool
        @param F (C++: flags_t)
        @param n (C++: int)
    """
    return _ida_bytes.is_enum(*args)

def is_manual(*args) -> "bool":
    r"""


    is forced operand? (use 'is_forced_operand()' )
    
    is_manual(F, n) -> bool
        @param F (C++: flags_t)
        @param n (C++: int)
    """
    return _ida_bytes.is_manual(*args)

def is_stroff(*args) -> "bool":
    r"""


    is struct offset?
    
    is_stroff(F, n) -> bool
        @param F (C++: flags_t)
        @param n (C++: int)
    """
    return _ida_bytes.is_stroff(*args)

def is_stkvar(*args) -> "bool":
    r"""


    is stack variable?
    
    is_stkvar(F, n) -> bool
        @param F (C++: flags_t)
        @param n (C++: int)
    """
    return _ida_bytes.is_stkvar(*args)

def is_fltnum(*args) -> "bool":
    r"""


    is floating point number?
    
    is_fltnum(F, n) -> bool
        @param F (C++: flags_t)
        @param n (C++: int)
    """
    return _ida_bytes.is_fltnum(*args)

def is_custfmt(*args) -> "bool":
    r"""


    is custom data format?
    
    is_custfmt(F, n) -> bool
        @param F (C++: flags_t)
        @param n (C++: int)
    """
    return _ida_bytes.is_custfmt(*args)

def is_numop(*args) -> "bool":
    r"""


    is number (bin, oct, dec, hex)?
    
    is_numop(F, n) -> bool
        @param F (C++: flags_t)
        @param n (C++: int)
    """
    return _ida_bytes.is_numop(*args)

def is_suspop(*args) -> "bool":
    r"""


    is suspicious operand?
    
    is_suspop(ea, F, n) -> bool
        @param ea (C++: ea_t)
        @param F (C++: flags_t)
        @param n (C++: int)
    """
    return _ida_bytes.is_suspop(*args)

def op_adds_xrefs(*args) -> "bool":
    r"""


    Should processor module create xrefs from the operand?. Currently
    'offset' and 'structure offset' operands create xrefs
    
    op_adds_xrefs(F, n) -> bool
        @param F (C++: flags_t)
        @param n (C++: int)
    """
    return _ida_bytes.op_adds_xrefs(*args)

def set_op_type(*args) -> "bool":
    r"""


    (internal function) change representation of operand(s).
    
    set_op_type(ea, type, n) -> bool
        @param ea: linear address (C++: ea_t)
        @param type: new flag value (should be obtained from  char_flag() ,
                     num_flag()  and similar functions) (C++: flags_t)
        @param n: number of operand (0, 1, -1) (C++: int)
        @retval: 1 - ok
        @retval: 0 - failed (applied to a tail byte)
    """
    return _ida_bytes.set_op_type(*args)

def op_seg(*args) -> "bool":
    r"""


    Set operand representation to be 'segment'. If applied to unexplored
    bytes, converts them to 16/32bit word data
    
    op_seg(ea, n) -> bool
        @param ea: linear address (C++: ea_t)
        @param n: number of operand (0, 1, -1) (C++: int)
        @return: success
    """
    return _ida_bytes.op_seg(*args)

def op_enum(*args) -> "bool":
    r"""


    Set operand representation to be 'enum_t'. If applied to unexplored
    bytes, converts them to 16/32bit word data
    
    op_enum(ea, n, id, serial) -> bool
        @param ea: linear address (C++: ea_t)
        @param n: number of operand (0, 1, -1) (C++: int)
        @param id: id of enum (C++: enum_t)
        @param serial: the serial number of the constant in the enumeration,
                       usually 0. the serial numbers are used if the
                       enumeration contains several constants with the same
                       value (C++: uchar)
        @return: success
    """
    return _ida_bytes.op_enum(*args)

def get_enum_id(*args) -> "uchar *":
    r"""


    Get enum id of 'enum' operand.
    
    get_enum_id(ea, n) -> enum_t
        @param ea: linear address (C++: ea_t)
        @param n: number of operand (0, 1, -1) (C++: int)
        @return: id of enum or  BADNODE
    """
    return _ida_bytes.get_enum_id(*args)

def op_stroff(*args) -> "bool":
    r"""


    Set operand representation to be 'struct offset'. If applied to
    unexplored bytes, converts them to 16/32bit word data
    
    op_stroff(insn, n, path, path_len, delta) -> bool
        @param insn: the instruction  - an ida_ua.insn_t, or an address (C++:
                     const insn_t &)
        @param n: number of operand (0, 1, -1) (C++: int)
        @param path: structure path (strpath). see  nalt.hpp  for more info.
                     (C++: const  tid_t  *)
        @param path_len: length of the structure path (C++: int)
        @param delta: struct offset delta. usually 0. denotes the difference
                      between the structure base and the pointer into the
                      structure. (C++: adiff_t)
        @return: success
    
    Example:
    Python> 
    Python> ins = ida_ua.insn_t()
    Python> if ida_ua.decode_insn(ins, some_address):
    Python>     path_len = 1
    Python>     path = ida_pro.tid_array(path_len)
    Python>     path[0] = ida_struct.get_struc_id("my_stucture_t")
    Python>     ida_bytes.op_stroff(ins, 0, path.cast(), path_len, 0)
    Python> 
    """
    return _ida_bytes.op_stroff(*args)

def get_stroff_path(*args) -> "int":
    r"""


    Get struct path of operand.
    
    get_stroff_path(path, delta, ea, n) -> int
        @param path: buffer for structure path (strpath). see  nalt.hpp  for
                     more info. (C++: tid_t  *)
        @param delta: struct offset delta (C++: adiff_t *)
        @param ea: linear address (C++: ea_t)
        @param n: number of operand (0, 1, -1) (C++: int)
        @return: length of strpath
    """
    return _ida_bytes.get_stroff_path(*args)

def op_stkvar(*args) -> "bool":
    r"""


    Set operand representation to be 'stack variable'. Should be applied
    to an instruction within a function. Should be applied after creating
    a stack var using 'insn_t::create_stkvar()' .
    
    op_stkvar(ea, n) -> bool
        @param ea: linear address (C++: ea_t)
        @param n: number of operand (0, 1, -1) (C++: int)
        @return: success
    """
    return _ida_bytes.op_stkvar(*args)

def set_forced_operand(*args) -> "bool":
    r"""


    Set forced operand.
    
    set_forced_operand(ea, n, op) -> bool
        @param ea: linear address (C++: ea_t)
        @param n: number of operand (0, 1, 2) (C++: int)
        @param op: text of operand   nullptr: do nothing (return 0)   "" :
                   delete forced operand (C++: const char *)
        @return: success
    """
    return _ida_bytes.set_forced_operand(*args)

def get_forced_operand(*args) -> "qstring *":
    r"""


    Get forced operand.
    
    get_forced_operand(ea, n) -> str
        @param ea: linear address (C++: ea_t)
        @param n: number of operand (0, 1, 2) (C++: int)
        @return: size of forced operand or -1
    """
    return _ida_bytes.get_forced_operand(*args)

def is_forced_operand(*args) -> "bool":
    r"""


    Is operand manually defined?.
    
    is_forced_operand(ea, n) -> bool
        @param ea: linear address (C++: ea_t)
        @param n: number of operand (0, 1, 2) (C++: int)
    """
    return _ida_bytes.is_forced_operand(*args)

def char_flag(*args) -> "flags_t":
    r"""


    see 'Bits: instruction operand types'
    """
    return _ida_bytes.char_flag(*args)

def off_flag(*args) -> "flags_t":
    r"""


    see 'Bits: instruction operand types'
    """
    return _ida_bytes.off_flag(*args)

def enum_flag(*args) -> "flags_t":
    r"""


    see 'Bits: instruction operand types'
    """
    return _ida_bytes.enum_flag(*args)

def stroff_flag(*args) -> "flags_t":
    r"""


    see 'Bits: instruction operand types'
    """
    return _ida_bytes.stroff_flag(*args)

def stkvar_flag(*args) -> "flags_t":
    r"""


    see 'Bits: instruction operand types'
    """
    return _ida_bytes.stkvar_flag(*args)

def flt_flag(*args) -> "flags_t":
    r"""


    see 'Bits: instruction operand types'
    """
    return _ida_bytes.flt_flag(*args)

def custfmt_flag(*args) -> "flags_t":
    r"""


    see 'Bits: instruction operand types'
    """
    return _ida_bytes.custfmt_flag(*args)

def seg_flag(*args) -> "flags_t":
    r"""


    see 'Bits: instruction operand types'
    """
    return _ida_bytes.seg_flag(*args)

def num_flag(*args) -> "flags_t":
    r"""


    Get number of default base (bin, oct, dec, hex)
    """
    return _ida_bytes.num_flag(*args)

def hex_flag(*args) -> "flags_t":
    r"""


    Get number flag of the base, regardless of current processor - better
    to use 'num_flag()'
    """
    return _ida_bytes.hex_flag(*args)

def dec_flag(*args) -> "flags_t":
    r"""


    Get number flag of the base, regardless of current processor - better
    to use 'num_flag()'
    """
    return _ida_bytes.dec_flag(*args)

def oct_flag(*args) -> "flags_t":
    r"""


    Get number flag of the base, regardless of current processor - better
    to use 'num_flag()'
    """
    return _ida_bytes.oct_flag(*args)

def bin_flag(*args) -> "flags_t":
    r"""


    Get number flag of the base, regardless of current processor - better
    to use 'num_flag()'
    """
    return _ida_bytes.bin_flag(*args)

def op_chr(*args) -> "bool":
    r"""


    set op type to 'char_flag()'
    
    op_chr(ea, n) -> bool
        @param ea (C++: ea_t)
        @param n (C++: int)
    """
    return _ida_bytes.op_chr(*args)

def op_num(*args) -> "bool":
    r"""


    set op type to 'num_flag()'
    
    op_num(ea, n) -> bool
        @param ea (C++: ea_t)
        @param n (C++: int)
    """
    return _ida_bytes.op_num(*args)

def op_hex(*args) -> "bool":
    r"""


    set op type to 'hex_flag()'
    
    op_hex(ea, n) -> bool
        @param ea (C++: ea_t)
        @param n (C++: int)
    """
    return _ida_bytes.op_hex(*args)

def op_dec(*args) -> "bool":
    r"""


    set op type to 'dec_flag()'
    
    op_dec(ea, n) -> bool
        @param ea (C++: ea_t)
        @param n (C++: int)
    """
    return _ida_bytes.op_dec(*args)

def op_oct(*args) -> "bool":
    r"""


    set op type to 'oct_flag()'
    
    op_oct(ea, n) -> bool
        @param ea (C++: ea_t)
        @param n (C++: int)
    """
    return _ida_bytes.op_oct(*args)

def op_bin(*args) -> "bool":
    r"""


    set op type to 'bin_flag()'
    
    op_bin(ea, n) -> bool
        @param ea (C++: ea_t)
        @param n (C++: int)
    """
    return _ida_bytes.op_bin(*args)

def op_flt(*args) -> "bool":
    r"""


    set op type to 'flt_flag()'
    
    op_flt(ea, n) -> bool
        @param ea (C++: ea_t)
        @param n (C++: int)
    """
    return _ida_bytes.op_flt(*args)

def op_custfmt(*args) -> "bool":
    r"""


    Set custom data format for operand (fid-custom data format id)
    
    op_custfmt(ea, n, fid) -> bool
        @param ea (C++: ea_t)
        @param n (C++: int)
        @param fid (C++: int)
    """
    return _ida_bytes.op_custfmt(*args)

def clr_op_type(*args) -> "bool":
    r"""


    Remove operand representation information. (set operand representation
    to be 'undefined')
    
    clr_op_type(ea, n) -> bool
        @param ea: linear address (C++: ea_t)
        @param n: number of operand (0, 1, -1) (C++: int)
        @return: success
    """
    return _ida_bytes.clr_op_type(*args)

def get_default_radix(*args) -> "int":
    r"""


    Get default base of number for the current processor.
    """
    return _ida_bytes.get_default_radix(*args)

def get_radix(*args) -> "int":
    r"""


    Get radix of the operand, in: flags. If the operand is not a number,
    returns 'get_default_radix()'
    
    get_radix(F, n) -> int
        @param F: flags (C++: flags_t)
        @param n: number of operand (0, 1, -1) (C++: int)
        @return: 2, 8, 10, 16
    """
    return _ida_bytes.get_radix(*args)
DT_TYPE = _ida_bytes.DT_TYPE
"""
Mask for DATA typing.
"""

FF_BYTE = _ida_bytes.FF_BYTE
"""
byte
"""

FF_WORD = _ida_bytes.FF_WORD
"""
word
"""

FF_DWORD = _ida_bytes.FF_DWORD
"""
double word
"""

FF_QWORD = _ida_bytes.FF_QWORD
"""
quadro word
"""

FF_TBYTE = _ida_bytes.FF_TBYTE
"""
tbyte
"""

FF_STRLIT = _ida_bytes.FF_STRLIT
"""
string literal
"""

FF_STRUCT = _ida_bytes.FF_STRUCT
"""
struct variable
"""

FF_OWORD = _ida_bytes.FF_OWORD
"""
octaword/xmm word (16 bytes/128 bits)
"""

FF_FLOAT = _ida_bytes.FF_FLOAT
"""
float
"""

FF_DOUBLE = _ida_bytes.FF_DOUBLE
"""
double
"""

FF_PACKREAL = _ida_bytes.FF_PACKREAL
"""
packed decimal real
"""

FF_ALIGN = _ida_bytes.FF_ALIGN
"""
alignment directive
"""

FF_CUSTOM = _ida_bytes.FF_CUSTOM
"""
custom data type
"""

FF_YWORD = _ida_bytes.FF_YWORD
"""
ymm word (32 bytes/256 bits)
"""

FF_ZWORD = _ida_bytes.FF_ZWORD
"""
zmm word (64 bytes/512 bits)
"""


def code_flag(*args) -> "flags_t":
    r"""


    'FF_CODE'
    """
    return _ida_bytes.code_flag(*args)

def byte_flag(*args) -> "flags_t":
    r"""


    Get a flags_t representing a byte.
    """
    return _ida_bytes.byte_flag(*args)

def word_flag(*args) -> "flags_t":
    r"""


    Get a flags_t representing a word.
    """
    return _ida_bytes.word_flag(*args)

def dword_flag(*args) -> "flags_t":
    r"""


    Get a flags_t representing a double word.
    """
    return _ida_bytes.dword_flag(*args)

def qword_flag(*args) -> "flags_t":
    r"""


    Get a flags_t representing a quad word.
    """
    return _ida_bytes.qword_flag(*args)

def oword_flag(*args) -> "flags_t":
    r"""


    Get a flags_t representing a octaword.
    """
    return _ida_bytes.oword_flag(*args)

def yword_flag(*args) -> "flags_t":
    r"""


    Get a flags_t representing a ymm word.
    """
    return _ida_bytes.yword_flag(*args)

def zword_flag(*args) -> "flags_t":
    r"""


    Get a flags_t representing a zmm word.
    """
    return _ida_bytes.zword_flag(*args)

def tbyte_flag(*args) -> "flags_t":
    r"""


    Get a flags_t representing a tbyte.
    """
    return _ida_bytes.tbyte_flag(*args)

def strlit_flag(*args) -> "flags_t":
    r"""


    Get a flags_t representing a string literal.
    """
    return _ida_bytes.strlit_flag(*args)

def stru_flag(*args) -> "flags_t":
    r"""


    Get a flags_t representing a struct.
    """
    return _ida_bytes.stru_flag(*args)

def cust_flag(*args) -> "flags_t":
    r"""


    Get a flags_t representing custom type data.
    """
    return _ida_bytes.cust_flag(*args)

def align_flag(*args) -> "flags_t":
    r"""


    Get a flags_t representing an alignment directive.
    """
    return _ida_bytes.align_flag(*args)

def float_flag(*args) -> "flags_t":
    r"""


    Get a flags_t representing a float.
    """
    return _ida_bytes.float_flag(*args)

def double_flag(*args) -> "flags_t":
    r"""


    Get a flags_t representing a double.
    """
    return _ida_bytes.double_flag(*args)

def packreal_flag(*args) -> "flags_t":
    r"""


    Get a flags_t representing a packed decimal real.
    """
    return _ida_bytes.packreal_flag(*args)

def is_byte(*args) -> "bool":
    r"""


    'FF_BYTE'
    
    is_byte(F) -> bool
        @param F (C++: flags_t)
    """
    return _ida_bytes.is_byte(*args)

def is_word(*args) -> "bool":
    r"""


    'FF_WORD'
    
    is_word(F) -> bool
        @param F (C++: flags_t)
    """
    return _ida_bytes.is_word(*args)

def is_dword(*args) -> "bool":
    r"""


    'FF_DWORD'
    
    is_dword(F) -> bool
        @param F (C++: flags_t)
    """
    return _ida_bytes.is_dword(*args)

def is_qword(*args) -> "bool":
    r"""


    'FF_QWORD'
    
    is_qword(F) -> bool
        @param F (C++: flags_t)
    """
    return _ida_bytes.is_qword(*args)

def is_oword(*args) -> "bool":
    r"""


    'FF_OWORD'
    
    is_oword(F) -> bool
        @param F (C++: flags_t)
    """
    return _ida_bytes.is_oword(*args)

def is_yword(*args) -> "bool":
    r"""


    'FF_YWORD'
    
    is_yword(F) -> bool
        @param F (C++: flags_t)
    """
    return _ida_bytes.is_yword(*args)

def is_zword(*args) -> "bool":
    r"""


    'FF_ZWORD'
    
    is_zword(F) -> bool
        @param F (C++: flags_t)
    """
    return _ida_bytes.is_zword(*args)

def is_tbyte(*args) -> "bool":
    r"""


    'FF_TBYTE'
    
    is_tbyte(F) -> bool
        @param F (C++: flags_t)
    """
    return _ida_bytes.is_tbyte(*args)

def is_float(*args) -> "bool":
    r"""


    'FF_FLOAT'
    
    is_float(F) -> bool
        @param F (C++: flags_t)
    """
    return _ida_bytes.is_float(*args)

def is_double(*args) -> "bool":
    r"""


    'FF_DOUBLE'
    
    is_double(F) -> bool
        @param F (C++: flags_t)
    """
    return _ida_bytes.is_double(*args)

def is_pack_real(*args) -> "bool":
    r"""


    'FF_PACKREAL'
    
    is_pack_real(F) -> bool
        @param F (C++: flags_t)
    """
    return _ida_bytes.is_pack_real(*args)

def is_strlit(*args) -> "bool":
    r"""


    'FF_STRLIT'
    
    is_strlit(F) -> bool
        @param F (C++: flags_t)
    """
    return _ida_bytes.is_strlit(*args)

def is_struct(*args) -> "bool":
    r"""


    'FF_STRUCT'
    
    is_struct(F) -> bool
        @param F (C++: flags_t)
    """
    return _ida_bytes.is_struct(*args)

def is_align(*args) -> "bool":
    r"""


    'FF_ALIGN'
    
    is_align(F) -> bool
        @param F (C++: flags_t)
    """
    return _ida_bytes.is_align(*args)

def is_custom(*args) -> "bool":
    r"""


    'FF_CUSTOM'
    
    is_custom(F) -> bool
        @param F (C++: flags_t)
    """
    return _ida_bytes.is_custom(*args)

def f_is_byte(*args) -> "bool":
    r"""


    See 'is_byte()'
    
    f_is_byte(F, arg2) -> bool
        @param F (C++: flags_t)
        arg2: void *
    """
    return _ida_bytes.f_is_byte(*args)

def f_is_word(*args) -> "bool":
    r"""


    See 'is_word()'
    
    f_is_word(F, arg2) -> bool
        @param F (C++: flags_t)
        arg2: void *
    """
    return _ida_bytes.f_is_word(*args)

def f_is_dword(*args) -> "bool":
    r"""


    See 'is_dword()'
    
    f_is_dword(F, arg2) -> bool
        @param F (C++: flags_t)
        arg2: void *
    """
    return _ida_bytes.f_is_dword(*args)

def f_is_qword(*args) -> "bool":
    r"""


    See 'is_qword()'
    
    f_is_qword(F, arg2) -> bool
        @param F (C++: flags_t)
        arg2: void *
    """
    return _ida_bytes.f_is_qword(*args)

def f_is_oword(*args) -> "bool":
    r"""


    See 'is_oword()'
    
    f_is_oword(F, arg2) -> bool
        @param F (C++: flags_t)
        arg2: void *
    """
    return _ida_bytes.f_is_oword(*args)

def f_is_yword(*args) -> "bool":
    r"""


    See 'is_yword()'
    
    f_is_yword(F, arg2) -> bool
        @param F (C++: flags_t)
        arg2: void *
    """
    return _ida_bytes.f_is_yword(*args)

def f_is_tbyte(*args) -> "bool":
    r"""


    See 'is_tbyte()'
    
    f_is_tbyte(F, arg2) -> bool
        @param F (C++: flags_t)
        arg2: void *
    """
    return _ida_bytes.f_is_tbyte(*args)

def f_is_float(*args) -> "bool":
    r"""


    See 'is_float()'
    
    f_is_float(F, arg2) -> bool
        @param F (C++: flags_t)
        arg2: void *
    """
    return _ida_bytes.f_is_float(*args)

def f_is_double(*args) -> "bool":
    r"""


    See 'is_double()'
    
    f_is_double(F, arg2) -> bool
        @param F (C++: flags_t)
        arg2: void *
    """
    return _ida_bytes.f_is_double(*args)

def f_is_pack_real(*args) -> "bool":
    r"""


    See 'is_pack_real()'
    
    f_is_pack_real(F, arg2) -> bool
        @param F (C++: flags_t)
        arg2: void *
    """
    return _ida_bytes.f_is_pack_real(*args)

def f_is_strlit(*args) -> "bool":
    r"""


    See 'is_strlit()'
    
    f_is_strlit(F, arg2) -> bool
        @param F (C++: flags_t)
        arg2: void *
    """
    return _ida_bytes.f_is_strlit(*args)

def f_is_struct(*args) -> "bool":
    r"""


    See 'is_struct()'
    
    f_is_struct(F, arg2) -> bool
        @param F (C++: flags_t)
        arg2: void *
    """
    return _ida_bytes.f_is_struct(*args)

def f_is_align(*args) -> "bool":
    r"""


    See 'is_align()'
    
    f_is_align(F, arg2) -> bool
        @param F (C++: flags_t)
        arg2: void *
    """
    return _ida_bytes.f_is_align(*args)

def f_is_custom(*args) -> "bool":
    r"""


    See 'is_custom()'
    
    f_is_custom(F, arg2) -> bool
        @param F (C++: flags_t)
        arg2: void *
    """
    return _ida_bytes.f_is_custom(*args)

def is_same_data_type(*args) -> "bool":
    r"""


    Do the given flags specify the same data type?
    
    is_same_data_type(F1, F2) -> bool
        @param F1 (C++: flags_t)
        @param F2 (C++: flags_t)
    """
    return _ida_bytes.is_same_data_type(*args)

def get_flags_by_size(*args) -> "flags_t":
    r"""


    Get flags from size (in bytes). Supported sizes: 1, 2, 4, 8, 16, 32.
    For other sizes returns 0
    
    get_flags_by_size(size) -> flags_t
        @param size (C++: size_t)
    """
    return _ida_bytes.get_flags_by_size(*args)

def create_data(*args) -> "bool":
    r"""


    Convert to data (byte, word, dword, etc). This function may be used to
    create arrays.
    
    create_data(ea, dataflag, size, tid) -> bool
        @param ea: linear address (C++: ea_t)
        @param dataflag: type of data. Value of function  byte_flag() ,
                         word_flag() , etc. (C++: flags_t)
        @param size: size of array in bytes. should be divisible by the size
                     of one item of the specified type. for variable sized
                     items it can be specified as 0, and the kernel will try
                     to calculate the size. (C++: asize_t)
        @param tid: type id. If the specified type is a structure, then tid is
                    structure id. Otherwise should be  BADNODE . (C++: tid_t)
        @return: success
    """
    return _ida_bytes.create_data(*args)

def calc_dflags(*args) -> "flags_t":
    r"""


    calc_dflags(f, force) -> flags_t
        @param f (C++: flags_t)
        @param force (C++: bool)
    """
    return _ida_bytes.calc_dflags(*args)

def create_byte(*args) -> "bool":
    r"""


    Convert to byte.
    
    create_byte(ea, length, force=False) -> bool
        @param ea (C++: ea_t)
        @param length (C++: asize_t)
        @param force (C++: bool)
    """
    return _ida_bytes.create_byte(*args)

def create_word(*args) -> "bool":
    r"""


    Convert to word.
    
    create_word(ea, length, force=False) -> bool
        @param ea (C++: ea_t)
        @param length (C++: asize_t)
        @param force (C++: bool)
    """
    return _ida_bytes.create_word(*args)

def create_dword(*args) -> "bool":
    r"""


    Convert to dword.
    
    create_dword(ea, length, force=False) -> bool
        @param ea (C++: ea_t)
        @param length (C++: asize_t)
        @param force (C++: bool)
    """
    return _ida_bytes.create_dword(*args)

def create_qword(*args) -> "bool":
    r"""


    Convert to quadword.
    
    create_qword(ea, length, force=False) -> bool
        @param ea (C++: ea_t)
        @param length (C++: asize_t)
        @param force (C++: bool)
    """
    return _ida_bytes.create_qword(*args)

def create_oword(*args) -> "bool":
    r"""


    Convert to octaword/xmm word.
    
    create_oword(ea, length, force=False) -> bool
        @param ea (C++: ea_t)
        @param length (C++: asize_t)
        @param force (C++: bool)
    """
    return _ida_bytes.create_oword(*args)

def create_yword(*args) -> "bool":
    r"""


    Convert to ymm word.
    
    create_yword(ea, length, force=False) -> bool
        @param ea (C++: ea_t)
        @param length (C++: asize_t)
        @param force (C++: bool)
    """
    return _ida_bytes.create_yword(*args)

def create_zword(*args) -> "bool":
    r"""


    Convert to zmm word.
    
    create_zword(ea, length, force=False) -> bool
        @param ea (C++: ea_t)
        @param length (C++: asize_t)
        @param force (C++: bool)
    """
    return _ida_bytes.create_zword(*args)

def create_tbyte(*args) -> "bool":
    r"""


    Convert to tbyte.
    
    create_tbyte(ea, length, force=False) -> bool
        @param ea (C++: ea_t)
        @param length (C++: asize_t)
        @param force (C++: bool)
    """
    return _ida_bytes.create_tbyte(*args)

def create_float(*args) -> "bool":
    r"""


    Convert to float.
    
    create_float(ea, length, force=False) -> bool
        @param ea (C++: ea_t)
        @param length (C++: asize_t)
        @param force (C++: bool)
    """
    return _ida_bytes.create_float(*args)

def create_double(*args) -> "bool":
    r"""


    Convert to double.
    
    create_double(ea, length, force=False) -> bool
        @param ea (C++: ea_t)
        @param length (C++: asize_t)
        @param force (C++: bool)
    """
    return _ida_bytes.create_double(*args)

def create_packed_real(*args) -> "bool":
    r"""


    Convert to packed decimal real.
    
    create_packed_real(ea, length, force=False) -> bool
        @param ea (C++: ea_t)
        @param length (C++: asize_t)
        @param force (C++: bool)
    """
    return _ida_bytes.create_packed_real(*args)

def create_struct(*args) -> "bool":
    r"""


    Convert to struct.
    
    create_struct(ea, length, tid, force=False) -> bool
        @param ea (C++: ea_t)
        @param length (C++: asize_t)
        @param tid (C++: tid_t)
        @param force (C++: bool)
    """
    return _ida_bytes.create_struct(*args)

def create_custdata(*args) -> "bool":
    r"""


    Convert to custom data type.
    
    create_custdata(ea, length, dtid, fid, force=False) -> bool
        @param ea (C++: ea_t)
        @param length (C++: asize_t)
        @param dtid (C++: int)
        @param fid (C++: int)
        @param force (C++: bool)
    """
    return _ida_bytes.create_custdata(*args)

def create_align(*args) -> "bool":
    r"""


    Alignment: 0 or 2..32. If it is 0, is will be calculated.
    
    create_align(ea, length, alignment) -> bool
        @param ea (C++: ea_t)
        @param length (C++: asize_t)
        @param alignment (C++: int)
    """
    return _ida_bytes.create_align(*args)

def calc_min_align(*args) -> "int":
    r"""


    Returns: 1..32.
    
    calc_min_align(length) -> int
        @param length (C++: asize_t)
    """
    return _ida_bytes.calc_min_align(*args)

def calc_max_align(*args) -> "int":
    r"""


    Returns: 0..32.
    
    calc_max_align(endea) -> int
        @param endea (C++: ea_t)
    """
    return _ida_bytes.calc_max_align(*args)

def calc_def_align(*args) -> "int":
    r"""


    Calculate default alignment.
    
    calc_def_align(ea, mina, maxa) -> int
        @param ea (C++: ea_t)
        @param mina (C++: int)
        @param maxa (C++: int)
    """
    return _ida_bytes.calc_def_align(*args)

def create_16bit_data(*args) -> "bool":
    r"""


    Convert to 16-bit quantity (take byte size into account)
    
    create_16bit_data(ea, length) -> bool
        @param ea (C++: ea_t)
        @param length (C++: asize_t)
    """
    return _ida_bytes.create_16bit_data(*args)

def create_32bit_data(*args) -> "bool":
    r"""


    Convert to 32-bit quantity (take byte size into account)
    
    create_32bit_data(ea, length) -> bool
        @param ea (C++: ea_t)
        @param length (C++: asize_t)
    """
    return _ida_bytes.create_32bit_data(*args)
ALOPT_IGNHEADS = _ida_bytes.ALOPT_IGNHEADS
"""
don't stop if another data item is encountered. only the byte values
will be used to determine the string length. if not set, a defined
data item or instruction will truncate the string
"""

ALOPT_IGNPRINT = _ida_bytes.ALOPT_IGNPRINT
"""
if set, don't stop at non-printable codepoints, but only at the
terminating character (or not unicode-mapped character (e.g., 0x8f in
CP1252))
"""

ALOPT_IGNCLT = _ida_bytes.ALOPT_IGNCLT
"""
if set, don't stop at codepoints that are not part of the current
'culture'; accept all those that are graphical (this is typically used
used by user-initiated actions creating string literals.)
"""

ALOPT_MAX4K = _ida_bytes.ALOPT_MAX4K
"""
accumulated length

if string length is more than 4K, return the
"""


def get_max_strlit_length(*args) -> "size_t":
    r"""


    Determine maximum length of string literal.If the string literal has a
    length prefix (e.g., STRTYPE_LEN2 has a two-byte length prefix), the
    length of that prefix (i.e., 2) will be part of the returned value.
    
    get_max_strlit_length(ea, strtype, options=0) -> size_t
        @param ea: starting address (C++: ea_t)
        @param strtype: string type. one of  String type codes (C++: int32)
        @param options: combination of  string literal length options (C++:
                        int)
        @return: length of the string in octets (octet==8bit)
    """
    return _ida_bytes.get_max_strlit_length(*args)
STRCONV_ESCAPE = _ida_bytes.STRCONV_ESCAPE
"""
convert non-printable characters to C escapes (, \\xNN, \\uNNNN)
"""

STRCONV_REPLCHAR = _ida_bytes.STRCONV_REPLCHAR
"""
convert non-printable characters to the Unicode replacement character
(U+FFFD)
"""

STRCONV_INCLLEN = _ida_bytes.STRCONV_INCLLEN
"""
for Pascal-style strings, include the prefixing length byte(s) as
C-escaped sequence
"""


def create_strlit(*args) -> "bool":
    r"""


    Convert to string literal and give a meaningful name. 'start' may be
    higher than 'end', the kernel will swap them in this case
    
    create_strlit(start, len, strtype) -> bool
        @param start: starting address (C++: ea_t)
        @param len: length of the string in bytes. if 0, then
                    get_max_strlit_length()  will be used to determine the
                    length (C++: size_t)
        @param strtype: string type. one of  String type codes (C++: int32)
        @return: success
    """
    return _ida_bytes.create_strlit(*args)
PSTF_TNORM = _ida_bytes.PSTF_TNORM
"""
use normal name
"""

PSTF_TBRIEF = _ida_bytes.PSTF_TBRIEF
"""
use brief name (e.g., in the 'Strings window')
"""

PSTF_TINLIN = _ida_bytes.PSTF_TINLIN
"""
use 'inline' name (e.g., in the structures comments)
"""

PSTF_TMASK = _ida_bytes.PSTF_TMASK
"""
type mask
"""

PSTF_HOTKEY = _ida_bytes.PSTF_HOTKEY
"""
have hotkey markers part of the name
"""

PSTF_ENC = _ida_bytes.PSTF_ENC
"""
if encoding is specified, append it
"""


def get_opinfo(*args) -> "opinfo_t *":
    r"""


    Get additional information about an operand representation.
    
    get_opinfo(buf, ea, n, flags) -> opinfo_t
        @param buf: buffer to receive the result. may not be nullptr (C++:
                    opinfo_t  *)
        @param ea: linear address of item (C++: ea_t)
        @param n: number of operand, 0 or 1 (C++: int)
        @param flags: flags of the item (C++: flags_t)
        @return: nullptr if no additional representation information
    """
    return _ida_bytes.get_opinfo(*args)

def set_opinfo(*args) -> "bool":
    r"""


    Set additional information about an operand representation. This
    function is a low level one. Only the kernel should use it.
    
    set_opinfo(ea, n, flag, ti, suppress_events=False) -> bool
        @param ea: linear address of the item (C++: ea_t)
        @param n: number of operand, 0 or 1 (C++: int)
        @param flag: flags of the item (C++: flags_t)
        @param ti: additional representation information (C++: const  opinfo_t
                   *)
        @param suppress_events: do not generate changing_op_type and
                                op_type_changed events (C++: bool)
        @return: success
    """
    return _ida_bytes.set_opinfo(*args)

def get_data_elsize(*args) -> "asize_t":
    r"""


    Get size of data type specified in flags 'F'.
    
    get_data_elsize(ea, F, ti=None) -> asize_t
        @param ea: linear address of the item (C++: ea_t)
        @param F: flags (C++: flags_t)
        @param ti: additional information about the data type. For example, if
                   the current item is a structure instance, then ti->tid is
                   structure id. Otherwise is ignored (may be nullptr). If
                   specified as nullptr, will be automatically retrieved from
                   the database (C++: const  opinfo_t  *)
        @return: byte : 1   word : 2   etc...
    """
    return _ida_bytes.get_data_elsize(*args)

def get_full_data_elsize(*args) -> "asize_t":
    r"""


    Get full size of data type specified in flags 'F'. takes into account
    processors with wide bytes e.g. returns 2 for a byte element with
    16-bit bytes
    
    get_full_data_elsize(ea, F, ti=None) -> asize_t
        @param ea (C++: ea_t)
        @param F (C++: flags_t)
        @param ti (C++: const  opinfo_t  *)
    """
    return _ida_bytes.get_full_data_elsize(*args)

def is_varsize_item(*args) -> "int":
    r"""


    Is the item at 'ea' variable size?.
    
    is_varsize_item(ea, F, ti=None, itemsize=None) -> int
        @param ea: linear address of the item (C++: ea_t)
        @param F: flags (C++: flags_t)
        @param ti: additional information about the data type. For example, if
                   the current item is a structure instance, then ti->tid is
                   structure id. Otherwise is ignored (may be nullptr). If
                   specified as nullptr, will be automatically retrieved from
                   the database (C++: const  opinfo_t  *)
        @param itemsize: if not nullptr and the item is varsize, itemsize will
                         contain the calculated item size (for struct types,
                         the minimal size is returned) (C++: asize_t *)
        @retval: 1 - varsize item
        @retval: 0 - fixed item
        @retval: -1 - error (bad data definition)
    """
    return _ida_bytes.is_varsize_item(*args)

def can_define_item(*args) -> "bool":
    r"""


    Can define item (instruction/data) of the specified 'length', starting
    at 'ea'?if there is an item starting at 'ea', this function ignores
    itthis function converts to unexplored all encountered data items with
    fixup information. Should be fixed in the future.a new item would
    cross segment boundariesa new item would overlap with existing items
    (except items specified by 'flags')
    
    can_define_item(ea, length, flags) -> bool
        @param ea (C++: ea_t)
        @param length (C++: asize_t)
        @param flags: if not 0, then the kernel will ignore the data types
                      specified by the flags and destroy them. For example:
                      1000 dw 5                  1002 db 5 ; undef
                      1003 db 5 ; undef                  1004 dw 5
                      1006 dd 5                    can_define_item(1000, 6, 0)
                      - false because of dw at 1004    can_define_item(1000,
                      6, word_flag()) - true, word at 1004 is destroyed (C++:
                      flags_t)
        @return: 1-yes, 0-no
    """
    return _ida_bytes.can_define_item(*args)
MS_CODE = _ida_bytes.MS_CODE
"""
Mask for code bits.
"""

FF_FUNC = _ida_bytes.FF_FUNC
"""
function start?
"""

FF_IMMD = _ida_bytes.FF_IMMD
"""
Has Immediate value ?
"""

FF_JUMP = _ida_bytes.FF_JUMP
"""
Has jump table or switch_info?
"""


def has_immd(*args) -> "bool":
    r"""


    Has immediate value?
    
    has_immd(F) -> bool
        @param F (C++: flags_t)
    """
    return _ida_bytes.has_immd(*args)

def is_func(*args) -> "bool":
    r"""


    Is function start?
    
    is_func(F) -> bool
        @param F (C++: flags_t)
    """
    return _ida_bytes.is_func(*args)

def set_immd(*args) -> "bool":
    r"""


    Set 'has immediate operand' flag. Returns true if the 'FF_IMMD' bit
    was not set and now is set
    
    set_immd(ea) -> bool
        @param ea (C++: ea_t)
    """
    return _ida_bytes.set_immd(*args)
class data_type_t(object):
    r"""
    Proxy of C++ data_type_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    props = property(_ida_bytes.data_type_t_props_get, _ida_bytes.data_type_t_props_set)
    name = property(_ida_bytes.data_type_t_name_get, _ida_bytes.data_type_t_name_set)
    menu_name = property(_ida_bytes.data_type_t_menu_name_get, _ida_bytes.data_type_t_menu_name_set)
    hotkey = property(_ida_bytes.data_type_t_hotkey_get, _ida_bytes.data_type_t_hotkey_set)
    asm_keyword = property(_ida_bytes.data_type_t_asm_keyword_get, _ida_bytes.data_type_t_asm_keyword_set)
    value_size = property(_ida_bytes.data_type_t_value_size_get, _ida_bytes.data_type_t_value_size_set)

    def is_present_in_menus(self, *args) -> "bool":
        r"""


        Should this type be shown in UI menus
        """
        return _ida_bytes.data_type_t_is_present_in_menus(self, *args)

    def __init__(self, *args):
        r"""


        __init__(self, _self, name, value_size=0, menu_name=None, hotkey=None, asm_keyword=None, props=0) -> data_type_t
            self: PyObject *
            name: char const *
            value_size: asize_t
            menu_name: char const *
            hotkey: char const *
            asm_keyword: char const *
            props: int
        """
        _ida_bytes.data_type_t_swiginit(self, _ida_bytes.new_data_type_t(*args))
    __swig_destroy__ = _ida_bytes.delete_data_type_t

    def __get_id(self, *args) -> "int":
        r"""
        __get_id(self) -> int
        """
        return _ida_bytes.data_type_t___get_id(self, *args)

    id = property(__get_id)
    __real__init__ = __init__
    def __init__(self, *args):
        self.__real__init__(self, *args) # pass 'self' as part of args

    if _BC695:
        def __init__(self, name, value_size = 0, menu_name = None, hotkey = None, asm_keyword = None, props = 0):
            args = (name, value_size, menu_name, hotkey, asm_keyword, props)
            self.__real__init__(self, *args) # pass 'self' as part of args



# Register data_type_t in _ida_bytes:
_ida_bytes.data_type_t_swigregister(data_type_t)
DTP_NODUP = _ida_bytes.DTP_NODUP
"""
do not use dup construct
"""


class data_format_t(object):
    r"""
    Proxy of C++ data_format_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    props = property(_ida_bytes.data_format_t_props_get, _ida_bytes.data_format_t_props_set)
    name = property(_ida_bytes.data_format_t_name_get, _ida_bytes.data_format_t_name_set)
    menu_name = property(_ida_bytes.data_format_t_menu_name_get, _ida_bytes.data_format_t_menu_name_set)
    hotkey = property(_ida_bytes.data_format_t_hotkey_get, _ida_bytes.data_format_t_hotkey_set)
    value_size = property(_ida_bytes.data_format_t_value_size_get, _ida_bytes.data_format_t_value_size_set)
    text_width = property(_ida_bytes.data_format_t_text_width_get, _ida_bytes.data_format_t_text_width_set)

    def is_present_in_menus(self, *args) -> "bool":
        r"""


        Should this format be shown in UI menus
        """
        return _ida_bytes.data_format_t_is_present_in_menus(self, *args)

    def __init__(self, *args):
        r"""


        __init__(self, _self, name, value_size=0, menu_name=None, props=0, hotkey=None, text_width=0) -> data_format_t
            self: PyObject *
            name: char const *
            value_size: asize_t
            menu_name: char const *
            props: int
            hotkey: char const *
            text_width: int32
        """
        _ida_bytes.data_format_t_swiginit(self, _ida_bytes.new_data_format_t(*args))
    __swig_destroy__ = _ida_bytes.delete_data_format_t

    def __get_id(self, *args) -> "int":
        r"""
        __get_id(self) -> int
        """
        return _ida_bytes.data_format_t___get_id(self, *args)

    id = property(__get_id)
    __real__init__ = __init__
    def __init__(self, *args):
        self.__real__init__(self, *args) # pass 'self' as part of args

    if _BC695:
        def __init__(self, name, value_size = 0, menu_name = None, props = 0, hotkey = None, text_width = 0):
            args = (name, value_size, menu_name, props, hotkey, text_width)
            self.__real__init__(self, *args) # pass 'self' as part of args



# Register data_format_t in _ida_bytes:
_ida_bytes.data_format_t_swigregister(data_format_t)


def get_custom_data_type(*args) -> "data_type_t const *":
    r"""


    Get definition of a registered custom data type.
    
    get_custom_data_type(dtid) -> data_type_t
        @param dtid: data type id (C++: int)
        @return: data type definition or nullptr
    """
    return _ida_bytes.get_custom_data_type(*args)

def get_custom_data_format(*args) -> "data_format_t const *":
    r"""


    Get definition of a registered custom data format.
    
    get_custom_data_format(dfid) -> data_format_t
        @param dfid: data format id (C++: int)
        @return: data format definition or nullptr
    """
    return _ida_bytes.get_custom_data_format(*args)

def attach_custom_data_format(*args) -> "bool":
    r"""


    Attach the data format to the data type.
    
    attach_custom_data_format(dtid, dfid) -> bool
        @param dtid: data type id that can use the data format. 0 means all
                     standard data types. Such data formats can be applied to
                     any data item or instruction operands. For instruction
                     operands, the  data_format_t::value_size  check is not
                     performed by the kernel. (C++: int)
        @param dfid: data format id (C++: int)
        @retval: true - ok
        @retval: false - no such  dtid , or no such  dfid , or the data format
                         has already been attached to the data type
    """
    return _ida_bytes.attach_custom_data_format(*args)

def detach_custom_data_format(*args) -> "bool":
    r"""


    Detach the data format from the data type. Unregistering a custom data
    type detaches all attached data formats, no need to detach them
    explicitly. You still need unregister them. Unregistering a custom
    data format detaches it from all attached data types.
    
    detach_custom_data_format(dtid, dfid) -> bool
        @param dtid: data type id to detach data format from (C++: int)
        @param dfid: data format id to detach (C++: int)
        @retval: true - ok
        @retval: false - no such  dtid , or no such  dfid , or the data format
                         was not attached to the data type
    """
    return _ida_bytes.detach_custom_data_format(*args)

def is_attached_custom_data_format(*args) -> "bool":
    r"""


    is_attached_custom_data_format(dtid, dfid) -> bool
        @param dtid (C++: int)
        @param dfid (C++: int)
    """
    return _ida_bytes.is_attached_custom_data_format(*args)

def get_custom_data_types(*args) -> "int":
    r"""


    Get list of registered custom data type ids.
    
    get_custom_data_types(out, min_size=0, max_size=BADADDR) -> int
        @param out: buffer for the output. may be nullptr (C++: intvec_t  *)
        @param min_size: minimum value size (C++: asize_t)
        @param max_size: maximum value size (C++: asize_t)
        @return: number of custom data types with the specified size limits
    """
    return _ida_bytes.get_custom_data_types(*args)

def get_custom_data_formats(*args) -> "int":
    r"""


    Get list of attached custom data formats for the specified data type.
    
    get_custom_data_formats(out, dtid) -> int
        @param out: buffer for the output. may be nullptr (C++: intvec_t  *)
        @param dtid: data type id (C++: int)
        @return: number of returned custom data formats. if error, returns -1
    """
    return _ida_bytes.get_custom_data_formats(*args)

def find_custom_data_type(*args) -> "int":
    r"""


    Get id of a custom data type.
    
    find_custom_data_type(name) -> int
        @param name: name of the custom data type (C++: const char *)
        @return: id or -1
    """
    return _ida_bytes.find_custom_data_type(*args)

def find_custom_data_format(*args) -> "int":
    r"""


    Get id of a custom data format.
    
    find_custom_data_format(name) -> int
        @param name: name of the custom data format (C++: const char *)
        @return: id or -1
    """
    return _ida_bytes.find_custom_data_format(*args)

def set_cmt(*args) -> "bool":
    r"""


    Set an indented comment.
    
    set_cmt(ea, comm, rptble) -> bool
        @param ea: linear address (C++: ea_t)
        @param comm: comment string   nullptr: do nothing (return 0)   "" :
                     delete comment (C++: const char *)
        @param rptble: is repeatable? (C++: bool)
        @return: success
    """
    return _ida_bytes.set_cmt(*args)

def get_cmt(*args) -> "qstring *":
    r"""


    Get an indented comment.
    
    get_cmt(ea, rptble) -> str
        @param ea: linear address. may point to tail byte, the function will
                   find start of the item (C++: ea_t)
        @param rptble: get repeatable comment? (C++: bool)
        @return: size of comment or -1
    """
    return _ida_bytes.get_cmt(*args)

def append_cmt(*args) -> "bool":
    r"""


    Append to an indented comment. Creates a new comment if none exists.
    Appends a newline character and the specified string otherwise.
    
    append_cmt(ea, str, rptble) -> bool
        @param ea: linear address (C++: ea_t)
        @param str: comment string to append (C++: const char *)
        @param rptble: append to repeatable comment? (C++: bool)
        @return: success
    """
    return _ida_bytes.append_cmt(*args)

def get_predef_insn_cmt(*args) -> "qstring *":
    r"""


    Get predefined comment.
    
    get_predef_insn_cmt(ins) -> str
        @param ins: current instruction information  - an ida_ua.insn_t, or an
                    address (C++: const insn_t &)
        @return: size of comment or -1
    """
    return _ida_bytes.get_predef_insn_cmt(*args)

def find_byte(*args) -> "ea_t":
    r"""


    Find forward a byte with the specified value (only 8-bit value from
    the database). example: ea=4 size=3 will inspect addresses 4, 5, and 6
    
    find_byte(sEA, size, value, bin_search_flags) -> ea_t
        @param sEA: linear address (C++: ea_t)
        @param size: number of bytes to inspect (C++: asize_t)
        @param value: value to find (C++: uchar)
        @param bin_search_flags: combination of  Search flags (C++: int)
        @return: address of byte or  BADADDR
    """
    return _ida_bytes.find_byte(*args)

def find_byter(*args) -> "ea_t":
    r"""


    Find reverse a byte with the specified value (only 8-bit value from
    the database). example: ea=4 size=3 will inspect addresses 6, 5, and 4
    
    find_byter(sEA, size, value, bin_search_flags) -> ea_t
        @param sEA: the lower address of the search range (C++: ea_t)
        @param size: number of bytes to inspect (C++: asize_t)
        @param value: value to find (C++: uchar)
        @param bin_search_flags: combination of  Search flags (C++: int)
        @return: address of byte or  BADADDR
    """
    return _ida_bytes.find_byter(*args)
PBSENC_DEF1BPU = _ida_bytes.PBSENC_DEF1BPU

PBSENC_ALL = _ida_bytes.PBSENC_ALL

BIN_SEARCH_CASE = _ida_bytes.BIN_SEARCH_CASE
"""
case sensitive
"""

BIN_SEARCH_NOCASE = _ida_bytes.BIN_SEARCH_NOCASE
"""
case insensitive
"""

BIN_SEARCH_NOBREAK = _ida_bytes.BIN_SEARCH_NOBREAK
"""
don't check for Ctrl-Break
"""

BIN_SEARCH_INITED = _ida_bytes.BIN_SEARCH_INITED
"""
find_byte, find_byter: any initilized value
"""

BIN_SEARCH_NOSHOW = _ida_bytes.BIN_SEARCH_NOSHOW
"""
don't show search progress or update screen
"""

BIN_SEARCH_FORWARD = _ida_bytes.BIN_SEARCH_FORWARD
"""
search forward for bytes
"""

BIN_SEARCH_BACKWARD = _ida_bytes.BIN_SEARCH_BACKWARD
"""
search backward for bytes
"""


def next_inited(*args) -> "ea_t":
    r"""


    Find the next initialized address.
    
    next_inited(ea, maxea) -> ea_t
        @param ea (C++: ea_t)
        @param maxea (C++: ea_t)
    """
    return _ida_bytes.next_inited(*args)

def prev_inited(*args) -> "ea_t":
    r"""


    Find the previous initialized address.
    
    prev_inited(ea, minea) -> ea_t
        @param ea (C++: ea_t)
        @param minea (C++: ea_t)
    """
    return _ida_bytes.prev_inited(*args)

def equal_bytes(*args) -> "bool":
    r"""


    Compare 'len' bytes of the program starting from 'ea' with 'image'.
    
    equal_bytes(ea, image, mask, len, sense_case) -> bool
        @param ea: linear address (C++: ea_t)
        @param image: bytes to compare with (C++: const  uchar  *)
        @param mask: array of 1/0 bytes, it's length is 'len'. 1 means to
                     perform the comparison of the corresponding byte. 0 means
                     not to perform. if mask == nullptr, then all bytes of
                     'image' will be compared. if mask ==  SKIP_FF_MASK  then
                     0xFF bytes will be skipped (C++: const  uchar  *)
        @param len: length of block to compare in bytes. (C++: size_t)
        @param sense_case: case-sensitive comparison? (C++: bool)
        @retval: 1 - equal
        @retval: 0 - not equal
    """
    return _ida_bytes.equal_bytes(*args)
class hidden_range_t(ida_range.range_t):
    r"""
    Proxy of C++ hidden_range_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    description = property(_ida_bytes.hidden_range_t_description_get, _ida_bytes.hidden_range_t_description_set)
    header = property(_ida_bytes.hidden_range_t_header_get, _ida_bytes.hidden_range_t_header_set)
    footer = property(_ida_bytes.hidden_range_t_footer_get, _ida_bytes.hidden_range_t_footer_set)
    visible = property(_ida_bytes.hidden_range_t_visible_get, _ida_bytes.hidden_range_t_visible_set)
    color = property(_ida_bytes.hidden_range_t_color_get, _ida_bytes.hidden_range_t_color_set)

    def __init__(self, *args):
        r"""
        __init__(self) -> hidden_range_t
        """
        _ida_bytes.hidden_range_t_swiginit(self, _ida_bytes.new_hidden_range_t(*args))
    __swig_destroy__ = _ida_bytes.delete_hidden_range_t

# Register hidden_range_t in _ida_bytes:
_ida_bytes.hidden_range_t_swigregister(hidden_range_t)


def update_hidden_range(*args) -> "bool":
    r"""


    Update hidden range information in the database. You cannot use this
    function to change the range boundaries
    
    update_hidden_range(ha) -> bool
        @param ha: range to update (C++: const  hidden_range_t  *)
        @return: success
    """
    return _ida_bytes.update_hidden_range(*args)

def add_hidden_range(*args) -> "bool":
    r"""


    Mark a range of addresses as hidden. The range will be created in the
    invisible state with the default color
    
    add_hidden_range(ea1, ea2, description, header, footer, color) -> bool
        @param ea1: linear address of start of the address range (C++: ea_t)
        @param ea2: linear address of end of the address range (C++: ea_t)
        @param description: range parameters (C++: const char *)
        @param header: range parameters (C++: const char *)
        @param footer: range parameters (C++: const char *)
        @param color (C++: bgcolor_t)
        @return: success
    """
    return _ida_bytes.add_hidden_range(*args)

def get_hidden_range(*args) -> "hidden_range_t *":
    r"""


    Get pointer to hidden range structure, in: linear address.
    
    get_hidden_range(ea) -> hidden_range_t
        @param ea: any address in the hidden range (C++: ea_t)
    """
    return _ida_bytes.get_hidden_range(*args)

def getn_hidden_range(*args) -> "hidden_range_t *":
    r"""


    Get pointer to hidden range structure, in: number of hidden range.
    
    getn_hidden_range(n) -> hidden_range_t
        @param n: number of hidden range, is in range 0..
                  get_hidden_range_qty() -1 (C++: int)
    """
    return _ida_bytes.getn_hidden_range(*args)

def get_hidden_range_qty(*args) -> "int":
    r"""


    Get number of hidden ranges.
    """
    return _ida_bytes.get_hidden_range_qty(*args)

def get_hidden_range_num(*args) -> "int":
    r"""


    Get number of a hidden range.
    
    get_hidden_range_num(ea) -> int
        @param ea: any address in the hidden range (C++: ea_t)
        @return: number of hidden range (0.. get_hidden_range_qty() -1)
    """
    return _ida_bytes.get_hidden_range_num(*args)

def get_prev_hidden_range(*args) -> "hidden_range_t *":
    r"""


    Get pointer to previous hidden range.
    
    get_prev_hidden_range(ea) -> hidden_range_t
        @param ea: any address in the program (C++: ea_t)
        @return: ptr to hidden range or nullptr if previous hidden range
                 doesn't exist
    """
    return _ida_bytes.get_prev_hidden_range(*args)

def get_next_hidden_range(*args) -> "hidden_range_t *":
    r"""


    Get pointer to next hidden range.
    
    get_next_hidden_range(ea) -> hidden_range_t
        @param ea: any address in the program (C++: ea_t)
        @return: ptr to hidden range or nullptr if next hidden range doesn't
                 exist
    """
    return _ida_bytes.get_next_hidden_range(*args)

def get_first_hidden_range(*args) -> "hidden_range_t *":
    r"""


    Get pointer to the first hidden range.
    """
    return _ida_bytes.get_first_hidden_range(*args)

def get_last_hidden_range(*args) -> "hidden_range_t *":
    r"""


    Get pointer to the last hidden range.
    """
    return _ida_bytes.get_last_hidden_range(*args)

def del_hidden_range(*args) -> "bool":
    r"""


    Delete hidden range.
    
    del_hidden_range(ea) -> bool
        @param ea: any address in the hidden range (C++: ea_t)
        @return: success
    """
    return _ida_bytes.del_hidden_range(*args)

def add_mapping(*args) -> "bool":
    r"""


    IDA supports memory mapping. References to the addresses from the
    mapped range use data and meta-data from the mapping range.You should
    set flag PR2_MAPPING in ph.flag2 to use memory mapping Add memory
    mapping range.
    
    add_mapping(_from, to, size) -> bool
        @param _from: start of the mapped range (nonexistent address) (C++:
                      ea_t)
        @param to: start of the mapping range (existent address) (C++: ea_t)
        @param size: size of the range (C++: asize_t)
        @return: success
    """
    return _ida_bytes.add_mapping(*args)

def del_mapping(*args) -> "void":
    r"""


    Delete memory mapping range.
    
    del_mapping(ea)
        @param ea: any address in the mapped range (C++: ea_t)
    """
    return _ida_bytes.del_mapping(*args)

def use_mapping(*args) -> "ea_t":
    r"""


    Translate address according to current mappings.
    
    use_mapping(ea) -> ea_t
        @param ea: address to translate (C++: ea_t)
        @return: translated address
    """
    return _ida_bytes.use_mapping(*args)

def get_mappings_qty(*args) -> "size_t":
    r"""


    Get number of mappings.
    """
    return _ida_bytes.get_mappings_qty(*args)

def get_mapping(*args) -> "ea_t *, ea_t *, asize_t *":
    r"""


    Get memory mapping range by its number.
    
    get_mapping(n) -> bool
        @param n: number of mapping range (0.. get_mappings_qty() -1) (C++:
                  size_t)
        @return: false if the specified range doesn't exist, otherwise returns
                 from ,  to ,  size
    """
    return _ida_bytes.get_mapping(*args)

def visit_patched_bytes(*args) -> "int":
    r"""


    visit_patched_bytes(ea1, ea2, py_callable) -> int
    Enumerates patched bytes in the given range and invokes a callable
    @param ea1: start address
    @param ea2: end address
    @param callable: a Python callable with the following prototype:
                     callable(ea, fpos, org_val, patch_val).
                     If the callable returns non-zero then that value will be
                     returned to the caller and the enumeration will be
                     interrupted.
    @return: Zero if the enumeration was successful or the return
             value of the callback if enumeration was interrupted.
    """
    return _ida_bytes.visit_patched_bytes(*args)

def next_that(*args) -> "ea_t":
    r"""


    next_that(ea, maxea, callable) -> ea_t
    Find next address with a flag satisfying the function 'testf'.
    Start searching from address 'ea'+1 and inspect bytes up to 'maxea'.
    maxea is not included in the search range.
    
    @param callable: a Python callable with the following prototype:
                     callable(flags). Return True to stop enumeration.
    @return: the found address or BADADDR.
    """
    return _ida_bytes.next_that(*args)

def prev_that(*args) -> "ea_t":
    r"""


    Find previous address with a flag satisfying the function 'testf'.do
    not pass 'is_unknown()' to this function to find unexplored bytes It
    will fail under the debugger. To find unexplored bytes, use
    'prev_unknown()' .
    
    prev_that(ea, minea, callable) -> ea_t
        @param ea: start searching from this address - 1. (C++: ea_t)
        @param minea: included in the search range. (C++: ea_t)
        callable: PyObject *
        @return: the found address or  BADADDR .
    """
    return _ida_bytes.prev_that(*args)

def get_bytes(*args) -> "PyObject *":
    r"""


    get_bytes(ea, size, gmb_flags=0x01) -> PyObject *
    Get the specified number of bytes of the program.
    @param ea: program address
    @param size: number of bytes to return
    @return: the bytes (as a str), or None in case of failure
    """
    return _ida_bytes.get_bytes(*args)

def get_bytes_and_mask(*args) -> "PyObject *":
    r"""


    get_bytes_and_mask(ea, size, gmb_flags=0x01) -> PyObject *
    Get the specified number of bytes of the program, and a bitmask
    specifying what bytes are defined and what bytes are not.
    @param ea: program address
    @param size: number of bytes to return
    @return: a tuple (bytes, mask), or None in case of failure.
             Both 'bytes' and 'mask' are 'str' instances.
    """
    return _ida_bytes.get_bytes_and_mask(*args)

def get_strlit_contents(*args) -> "PyObject *":
    r"""


    get_strlit_contents(ea, py_len, type, flags=0) -> PyObject *
    Get bytes contents at location, possibly converted.
    It works even if the string has not been created in the database yet.
    
    Note that this will <b>always</b> return a simple string of bytes
    (i.e., a 'str' instance), and not a string of unicode characters.
    
    If you want auto-conversion to unicode strings (that is: real strings),
    you should probably be using the idautils.Strings class.
    
    @param ea: linear address of the string
    @param len: length of the string in bytes (including terminating 0)
    @param type: type of the string. Represents both the character encoding,
                 <u>and</u> the 'type' of string at the given location.
    @param flags: combination of STRCONV_..., to perform output conversion.
    @return: a bytes-filled str object.
    """
    return _ida_bytes.get_strlit_contents(*args)

def bin_search(*args) -> "ea_t":
    r"""


    bin_search(start_ea, end_ea, image, imask, step, flags) -> ea_t
    Search for a set of bytes in the program
    
    @param start_ea: linear address, start of range to search
    @param end_ea: linear address, end of range to search (exclusive)
    @param image: the set of bytes to search for
    @param imask: a bitfield representing the mask in 'image' (can be None)
    @param step: either BIN_SEARCH_FORWARD, or BIN_SEARCH_BACKWARD
    @param flags: combination of BIN_SEARCH_* flags
    @return: the address of a match, or ida_idaapi.BADADDR if not found
    """
    return _ida_bytes.bin_search(*args)

def print_strlit_type(*args) -> "PyObject *":
    r"""


    Get string type information: the string type name (possibly decorated
    with hotkey markers), and the tooltip.
    
    print_strlit_type(strtype, flags=0) -> PyObject *
        @param strtype: the string type (C++: int32)
        @param flags: or'ed PSTF_* constants (C++: int)
        @return: length of generated text
    """
    return _ida_bytes.print_strlit_type(*args)

def get_octet(*args) -> "PyObject *":
    r"""


    Get 8 bits of the program at 'ea'. The main usage of this function is
    to iterate range of bytes. Here is an example:
    
    uint64 v;
    int nbit = 0;
    for ( ... ) {
      uchar byte = get_octet(&ea, &v, &nbit);
      ...
    }
    
    'ea' is incremented each time when a new byte is read. In the above
    example, it will be incremented in the first loop iteration.
    
    get_octet(ea, v, nbit) -> PyObject *
        @param ea (C++: ea_t *)
        @param v (C++: uint64  *)
        @param nbit (C++: int *)
    """
    return _ida_bytes.get_octet(*args)

def get_8bit(*args) -> "PyObject *":
    r"""


    get_8bit(ea, v, nbit) -> PyObject *
        @param ea (C++: ea_t *)
        @param v (C++: uint32  *)
        @param nbit (C++: int *)
    """
    return _ida_bytes.get_8bit(*args)

#<pycode(py_bytes)>
#</pycode(py_bytes)>


def register_custom_data_type(*args) -> "int":
    r"""


    register_custom_data_type(py_dt) -> int
    Registers a custom data type.
    @param dt: an instance of the data_type_t class
    @return:
        < 0 if failed to register
        > 0 data type id
    """
    return _ida_bytes.register_custom_data_type(*args)

def unregister_custom_data_type(*args) -> "bool":
    r"""


    unregister_custom_data_type(dtid) -> bool
    Unregisters a custom data type.
    @param dtid: the data type id
    @return: Boolean
    """
    return _ida_bytes.unregister_custom_data_type(*args)

def register_custom_data_format(*args) -> "int":
    r"""


    register_custom_data_format(py_df) -> int
    Registers a custom data format with a given data type.
    @param df: an instance of data_format_t
    @return:
        < 0 if failed to register
        > 0 data format id
    """
    return _ida_bytes.register_custom_data_format(*args)

def unregister_custom_data_format(*args) -> "bool":
    r"""


    unregister_custom_data_format(dfid) -> bool
    Unregisters a custom data format
    @param dfid: data format id
    @return: Boolean
    """
    return _ida_bytes.unregister_custom_data_format(*args)

#<pycode(py_bytes_custdata)>
DTP_NODUP = 0x0001
"""
do not use dup construct
"""
# -----------------------------------------------------------------------
def __walk_types_and_formats(formats, type_action, format_action, installing):
    broken = False
    for f in formats:
        if len(f) == 1:
            if not format_action(f[0], 0):
                broken = True
                break
        else:
            dt  = f[0]
            dfs = f[1:]
# install data type before installing formats
            if installing and not type_action(dt):
                broken = True
                break
# process formats using the correct dt.id
            for df in dfs:
                if not format_action(df, dt.id):
                    broken = True
                    break
# uninstall data type after uninstalling formats
            if not installing and not type_action(dt):
                broken = True
                break
    return not broken

# -----------------------------------------------------------------------
def register_data_types_and_formats(formats):
    """


        Registers multiple data types and formats at once.
        To register one type/format at a time use register_custom_data_type/register_custom_data_format
    
        It employs a special table of types and formats described below:
    
        The 'formats' is a list of tuples. If a tuple has one element then it is the format to be registered with dtid=0
        If the tuple has more than one element, then tuple[0] is the data type and tuple[1:] are the data formats. For example:
        many_formats = [
          (pascal_data_type(), pascal_data_format()),
          (simplevm_data_type(), simplevm_data_format()),
          (makedword_data_format(),),
          (simplevm_data_format(),)
        ]
        The first two tuples describe data types and their associated formats.
        The last two tuples describe two data formats to be used with built-in data types.
        The data format may be attached to several data types. The id of the
        data format is stored in the first data_format_t object. For example:
        assert many_formats[1][1] != -1
        assert many_formats[2][0] != -1
        assert many_formats[3][0] == -1
    """
    def __reg_format(df, dtid):
        dfid = register_custom_data_format(df);
        if dfid == -1:
            dfid = find_custom_data_format(df.name);
            if dfid == -1:
              return False
        attach_custom_data_format(dtid, dfid)
        if dtid == 0:
            print("Registered format '%s' with built-in types, ID=%d" % (df.name, dfid))
        else:
            print("   Registered format '%s', ID=%d (dtid=%d)" % (df.name, dfid, dtid))
        return True

    def __reg_type(dt):
        register_custom_data_type(dt)
        print("Registered type '%s', ID=%d" % (dt.name, dt.id))
        return dt.id != -1
    ok = __walk_types_and_formats(formats, __reg_type, __reg_format, True)
    return 1 if ok else -1

# -----------------------------------------------------------------------
def unregister_data_types_and_formats(formats):
    """
    As opposed to register_data_types_and_formats(), this function
    unregisters multiple data types and formats at once.
    """
    def __unreg_format(df, dtid):
        print("%snregistering format '%s'" % ("U" if dtid == 0 else "   u", df.name))
        unregister_custom_data_format(df.id)
        return True

    def __unreg_type(dt):
        print("Unregistering type '%s', ID=%d" % (dt.name, dt.id))
        unregister_custom_data_type(dt.id)
        return True
    ok = __walk_types_and_formats(formats, __unreg_type, __unreg_format, False)
    return 1 if ok else -1

#--------------------------------------------------------------------------
#
#
#<pydoc>
#class data_type_t(object):
#    """
#    The following optional callback methods can be implemented
#    in a data_type_t subclass
#    """
#
#    def may_create_at(self, ea, nbytes):
#        """May create data?
#        No such callback means: always succeed (i.e., no restriction where
#        such a data type can be created.)
#        @param ea: candidate address for the data item
#        @param nbytes: candidate size for the data item
#        @return: True/False
#        """
#        return True
#
#    def calc_item_size(self, ea, maxsize):
#        """This callback is used to determine size of the (possible)
#        item at `ea`.
#        No such callback means that datatype is of fixed size `value_size`.
#        (thus, this callback is required only for varsize datatypes.)
#        @param ea: address of the item
#        @param maxsize: maximum size of the item
#        @return: 0 - no such item can be created/displayed
#        """
#        return 0
#
#
#class data_format_t(object):
#    """
#    The following callback methods can be implemented
#    in a data_format_t subclass
#    """
#
#    def printf(self, value, current_ea, operand_num, dtid):
#        """Convert `value` to colored string using custom format.
#        @param value: value to print (of type 'str', sequence of bytes)
#        @param current_ea: current address (BADADDR if unknown)
#        @param operand_num: current operand number
#        @param dtid: custom data type id
#        @return: string representing data
#        """
#        return None
#
#    def scan(self, input, current_ea, operand_num):
#        """Convert uncolored string (user input) to the value.
#        This callback is called from the debugger when an user enters a
#        new value for a register with a custom data representation (e.g.,
#        an MMX register.)
#        @param input: input string
#        @param current_ea: current address (BADADDR if unknown)
#        @param operand_num: current operand number (-1 if unknown)
#        @return: tuple(bool, string)
#                 (True, output value) or
#                 (False, error message)
#        """
#        return (False, "Not implemented")
#
#    def analyze(self, current_ea, operand_num):
#        """Analyze custom data format occurrence.
#        This callback is called in 2 cases:
#        - after emulating an instruction (after a call of
#          'ev_emu_insn') if its operand is marked as "custom data
#          representation"
#        - when emulating data (this is done using a call of
#          'ev_out_data' with analyze_only == true). This is the right
#          place to create cross references from the current item.
#        @param current_ea: current address (BADADDR if unknown)
#        @param operand_num: current operand number
#        """
#        pass
#
#
#</pydoc>
#</pycode(py_bytes_custdata)>


if _BC695:
    ACFOPT_ASCII=0
    ACFOPT_CONVMASK=0
    ACFOPT_ESCAPE=STRCONV_ESCAPE
    ACFOPT_UTF16=0
    ACFOPT_UTF8=0
    DOUNK_DELNAMES=DELIT_DELNAMES
    DOUNK_EXPAND=DELIT_EXPAND
    DOUNK_NOTRUNC=DELIT_NOTRUNC
    DOUNK_SIMPLE=DELIT_SIMPLE
    FF_ASCI=FF_STRLIT
    FF_DWRD=FF_DWORD
    FF_OWRD=FF_OWORD
    FF_QWRD=FF_QWORD
    FF_STRU=FF_STRUCT
    FF_TBYT=FF_TBYTE
    FF_VAR=0
    FF_YWRD=FF_YWORD
    FF_ZWRD=FF_ZWORD
    GFE_NOVALUE=0
    add_hidden_area=add_hidden_range
    asciflag=strlit_flag
    delValue=del_value
    del_hidden_area=del_hidden_range
    do16bit=create_16bit_data
    do32bit=create_32bit_data
    doAlign=create_align
    doByte=create_byte
    doCustomData=create_custdata
    doDouble=create_double
    doDwrd=create_dword
    doExtra=ida_idaapi._BC695.false_p
    doFloat=create_float
    doImmd=set_immd
    doOwrd=create_oword
    doPackReal=create_packed_real
    doQwrd=create_qword
    doStruct=create_struct
    doTbyt=create_tbyte
    doWord=create_word
    doYwrd=create_yword
    doZwrd=create_zword
    do_data_ex=create_data
    do_unknown=del_items
    def do_unknown_range(ea, size, flags):
        return del_items(ea, flags, size) # swap 2 last args
    dwrdflag=dword_flag
    f_hasRef=f_has_xref
    f_isASCII=f_is_strlit
    f_isAlign=f_is_align
    f_isByte=f_is_byte
    f_isCode=f_is_code
    f_isCustom=f_is_custom
    f_isData=f_is_data
    f_isDouble=f_is_double
    f_isDwrd=f_is_dword
    f_isFloat=f_is_float
    f_isHead=f_is_head
    f_isNotTail=f_is_not_tail
    f_isOwrd=f_is_oword
    f_isPackReal=f_is_pack_real
    f_isQwrd=f_is_qword
    f_isStruct=f_is_struct
    f_isTail=f_is_tail
    f_isTbyt=f_is_tbyte
    f_isWord=f_is_word
    f_isYwrd=f_is_yword
    getDefaultRadix=get_default_radix
    getFlags=get_full_flags
    get_long=get_dword
    get_full_byte=get_wide_byte
    get_full_word=get_wide_word
    get_full_long=get_wide_dword
    get_original_long=get_original_dword
    put_long=put_dword
    patch_long=patch_dword
    add_long=add_dword
    getRadix=get_radix
    get_ascii_contents=get_strlit_contents
    get_ascii_contents2=get_strlit_contents
    get_flags_novalue=get_flags
    get_hidden_area=get_hidden_range
    get_hidden_area_num=get_hidden_range_num
    get_hidden_area_qty=get_hidden_range_qty
    def get_many_bytes(ea, size):
        return get_bytes(ea, size)
    def get_many_bytes_ex(ea, size):
        return get_bytes_and_mask(ea, size)
    get_max_ascii_length=get_max_strlit_length
    get_next_hidden_area=get_next_hidden_range
    get_prev_hidden_area=get_prev_hidden_range
    get_zero_areas=get_zero_ranges
    getn_hidden_area=getn_hidden_range
    hasExtra=has_extra_cmts
    hasRef=has_xref
    hasValue=has_value
    hidden_area_t=hidden_range_t
    isASCII=is_strlit
    isAlign=is_align
    isByte=is_byte
    isChar=is_char
    isChar0=is_char0
    isChar1=is_char1
    isCode=is_code
    isCustFmt=is_custfmt
    isCustFmt0=is_custfmt0
    isCustFmt1=is_custfmt1
    isCustom=is_custom
    isData=is_data
    isDefArg=is_defarg
    isDefArg0=is_defarg0
    isDefArg1=is_defarg1
    isDouble=is_double
    isDwrd=is_dword
    isEnabled=is_mapped
    isEnum=is_enum
    isEnum0=is_enum0
    isEnum1=is_enum1
    isFloat=is_float
    isFloat0=is_float0
    isFloat1=is_float1
    isFlow=is_flow
    isFltnum=is_fltnum
    isFop=is_forced_operand
    isFunc=is_func
    isHead=is_head
    isImmd=has_immd
    isLoaded=is_loaded
    isNotTail=is_not_tail
    isNum=is_numop
    isNum0=is_numop0
    isNum1=is_numop1
    isOff=is_off
    isOff0=is_off0
    isOff1=is_off1
    isOwrd=is_oword
    isPackReal=is_pack_real
    isQwrd=is_qword
    isSeg=is_seg
    isSeg0=is_seg0
    isSeg1=is_seg1
    isStkvar=is_stkvar
    isStkvar0=is_stkvar0
    isStkvar1=is_stkvar1
    isStroff=is_stroff
    isStroff0=is_stroff0
    isStroff1=is_stroff1
    isStruct=is_struct
    isTail=is_tail
    isTbyt=is_tbyte
    isUnknown=is_unknown
    isVoid=is_suspop
    isWord=is_word
    isYwrd=is_yword
    isZwrd=is_zword
    make_ascii_string=create_strlit
    noExtra=ida_idaapi._BC695.false_p
    noType=clr_op_type
    owrdflag=oword_flag
    patch_many_bytes=patch_bytes
    print_ascii_string_type=print_strlit_type
    put_many_bytes=put_bytes
    qwrdflag=qword_flag
    tbytflag=tbyte_flag
    update_hidden_area=update_hidden_range
    ywrdflag=yword_flag
    zwrdflag=zword_flag
    def get_opinfo(*args):
        import ida_nalt
        if isinstance(args[3], ida_nalt.opinfo_t): # 6.95: ea, n, flags, buf
            ea, n, flags, buf = args
        else:                                      # 7.00: buf, ea, n, flags
            buf, ea, n, flags = args
        return _ida_bytes.get_opinfo(buf, ea, n, flags)
    def doASCI(ea, length):
        import ida_netnode
        return create_data(ea, FF_STRLIT, length, ida_netnode.BADNODE)
    FF_3BYTE=FF_BYTE
    chunksize=chunk_size
    chunkstart=chunk_start
    do3byte=ida_idaapi._BC695.false_p
    f_is3byte=ida_idaapi._BC695.false_p
    freechunk=free_chunk
    get_3byte=ida_idaapi._BC695.false_p
    is3byte=ida_idaapi._BC695.false_p
    nextaddr=next_addr
    nextchunk=next_chunk
    nextthat=next_that
    prevaddr=prev_addr
    prevchunk=prev_chunk
    prevthat=prev_that
    tribyteflag=byte_flag
    alignflag=align_flag
    binflag=bin_flag
    byteflag=byte_flag
    charflag=char_flag
    codeflag=code_flag
    custflag=cust_flag
    custfmtflag=custfmt_flag
    decflag=dec_flag
    doubleflag=double_flag
    enumflag=enum_flag
    floatflag=float_flag
    fltflag=flt_flag
    hexflag=hex_flag
    numflag=num_flag
    octflag=oct_flag
    offflag=off_flag
    packrealflag=packreal_flag
    segflag=seg_flag
    stkvarflag=stkvar_flag
    stroffflag=stroff_flag
    struflag=stru_flag
    wordflag=word_flag
    invalidate_visea_cache=ida_idaapi._BC695.false_p
    @bc695redef
    def op_stroff(*args):
        insn, n, path, path_len, delta = args
        import ida_ua
        if not isinstance(insn, ida_ua.insn_t):
            tmp = ida_ua.insn_t()
            ida_ua.decode_insn(tmp, insn)
            insn = tmp
        return _ida_bytes.op_stroff(insn, n, path, path_len, delta)



