# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.1
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

"""
IDA Plugin SDK API wrapper: kernwin
"""

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _ida_kernwin
else:
    import _ida_kernwin

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """
    Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass
    """
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """
    Meta class to enforce nondynamic attributes (no new attributes) for a class
    """
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import weakref

SWIG_PYTHON_LEGACY_BOOL = _ida_kernwin.SWIG_PYTHON_LEGACY_BOOL

import ida_idaapi


import sys
_BC695 = sys.modules["__main__"].IDAPYTHON_COMPAT_695_API

if _BC695:






    def bc695redef(func):
        ida_idaapi._BC695.replace_fun(func)
        return func


def _kludge_force_declare_dirspec_t(*args) -> "void":
    r"""


    _kludge_force_declare_dirspec_t(arg1)
        arg1: dirspec_t const *
    """
    return _ida_kernwin._kludge_force_declare_dirspec_t(*args)

def _kludge_force_declare_dirtree_t(*args) -> "void":
    r"""


    _kludge_force_declare_dirtree_t(arg1)
        arg1: dirtree_t const *
    """
    return _ida_kernwin._kludge_force_declare_dirtree_t(*args)

def refresh_choosers(*args) -> "void":
    r"""
    refresh_choosers()
    """
    return _ida_kernwin.refresh_choosers(*args)

def textctrl_info_t_create(*args) -> "PyObject *":
    r"""
    textctrl_info_t_create() -> PyObject *
    """
    return _ida_kernwin.textctrl_info_t_create(*args)

def textctrl_info_t_destroy(*args) -> "bool":
    r"""


    textctrl_info_t_destroy(py_obj) -> bool
        py_obj: PyObject *
    """
    return _ida_kernwin.textctrl_info_t_destroy(*args)

def textctrl_info_t_get_clink(*args) -> "textctrl_info_t *":
    r"""


    textctrl_info_t_get_clink(_self) -> textctrl_info_t *
        self: PyObject *
    """
    return _ida_kernwin.textctrl_info_t_get_clink(*args)

def textctrl_info_t_get_clink_ptr(*args) -> "PyObject *":
    r"""


    textctrl_info_t_get_clink_ptr(_self) -> PyObject *
        self: PyObject *
    """
    return _ida_kernwin.textctrl_info_t_get_clink_ptr(*args)

def register_timer(*args) -> "PyObject *":
    r"""


    register_timer(interval, py_callback) -> PyObject *
    Register a timer
    
    @param interval: Interval in milliseconds
    @param callback: A Python callable that takes no parameters and returns an integer.
                     The callback may return:
                     -1   : to unregister the timer
                     >= 0 : the new or same timer interval
    @return: None or a timer object
    """
    return _ida_kernwin.register_timer(*args)

def unregister_timer(*args) -> "bool":
    r"""


    unregister_timer(py_timerctx) -> bool
    Unregister a timer
    
    @param timer_obj: a timer object previously returned by a register_timer()
    @return: Boolean
    @note: After the timer has been deleted, the timer_obj will become invalid.
    """
    return _ida_kernwin.unregister_timer(*args)

def choose_idasgn(*args) -> "PyObject *":
    r"""


    choose_idasgn() -> PyObject *
    Opens the signature chooser
    
    @return: None or the selected signature name
    """
    return _ida_kernwin.choose_idasgn(*args)

def get_highlight(*args) -> "PyObject *":
    r"""


    get_highlight(v) -> PyObject *
    Returns the currently highlighted identifier and flags
    
    @return: a tuple (text, flags), or None if nothing
             is highlighted or in case of error.
    """
    return _ida_kernwin.get_highlight(*args)

def py_load_custom_icon_fn(*args) -> "int":
    r"""


    py_load_custom_icon_fn(filename) -> int
        filename: char const *
    """
    return _ida_kernwin.py_load_custom_icon_fn(*args)

def py_load_custom_icon_data(*args) -> "int":
    r"""


    py_load_custom_icon_data(data, format) -> int
        data: PyObject *
        format: char const *
    """
    return _ida_kernwin.py_load_custom_icon_data(*args)

def msg(*args) -> "PyObject *":
    r"""


    msg(o) -> PyObject *
    Display an UTF-8 string in the message window
    
    The result of the stringification of the arguments
    will be treated as an UTF-8 string.
    
    @param message: message to print (formatting is done in Python)
    
    This function can be used to debug IDAPython scripts
    """
    return _ida_kernwin.msg(*args)

def ask_text(*args) -> "PyObject *":
    r"""


    ask_text(max_size, defval, prompt) -> PyObject *
    Asks for a long text
    
    @param max_size: Maximum text length, 0 for unlimited
    @param defval: The default value
    @param prompt: The prompt value
    @return: None or the entered string
    """
    return _ida_kernwin.ask_text(*args)

def ask_str(*args) -> "PyObject *":
    r"""


    ask_str(defval, hist, prompt) -> PyObject *
    Asks for a long text
    
    @param hist:   history id
    @param defval: The default value
    @param prompt: The prompt value
    @return: None or the entered string
    """
    return _ida_kernwin.ask_str(*args)

def str2ea(*args) -> "ea_t":
    r"""


    str2ea(str, screenEA=BADADDR) -> ea_t
    Converts a string express to EA. The expression evaluator may be called as well.
    
    @return: BADADDR or address value
    """
    return _ida_kernwin.str2ea(*args)

def process_ui_action(*args) -> "bool":
    r"""


    process_ui_action(name, flags=0) -> bool
    Invokes an IDA UI action by name
    
    @param name:  action name
    @return: Boolean
    """
    return _ida_kernwin.process_ui_action(*args)

def del_hotkey(*args) -> "bool":
    r"""


    del_hotkey(pyctx) -> bool
    Deletes a previously registered function hotkey
    
    @param ctx: Hotkey context previously returned by add_hotkey()
    
    @return: Boolean.
    """
    return _ida_kernwin.del_hotkey(*args)

def add_hotkey(*args) -> "PyObject *":
    r"""


    add_hotkey(hotkey, pyfunc) -> PyObject *
    Associates a function call with a hotkey.
    Callable pyfunc will be called each time the hotkey is pressed
    
    @param hotkey: The hotkey
    @param pyfunc: Callable
    
    @return: Context object on success or None on failure.
    """
    return _ida_kernwin.add_hotkey(*args)

def take_database_snapshot(*args) -> "PyObject *":
    r"""


    Take a database snapshot ( 'ui_take_database_snapshot' ).
    
    take_database_snapshot(ss) -> PyObject *
        @param ss: in/out parameter.   in: description, flags   out: filename,
                   id (C++: snapshot_t  *)
        @return: success
    """
    return _ida_kernwin.take_database_snapshot(*args)

def py_ss_restore_callback(*args) -> "void":
    r"""


    py_ss_restore_callback(err_msg, userdata)
        err_msg: char const *
        userdata: void *
    """
    return _ida_kernwin.py_ss_restore_callback(*args)

def restore_database_snapshot(*args) -> "PyObject *":
    r"""


    Restore a database snapshot. Note: This call is asynchronous. When it
    is completed, the callback will be triggered.
    
    restore_database_snapshot(ss, pyfunc_or_none, pytuple_or_none) -> PyObject *
        @param ss: snapshot instance (see  build_snapshot_tree() ) (C++: const
                   snapshot_t  *)
        pyfunc_or_none: PyObject *
        pytuple_or_none: PyObject *
        @return: false if restoration could not be started (snapshot file was
                 not found).    If the returned value is True then check if
                 the operation succeeded from the callback.
    """
    return _ida_kernwin.restore_database_snapshot(*args)

def execute_sync(*args) -> "int":
    r"""


    execute_sync(py_callable, reqf) -> int
    Executes a function in the context of the main thread.
    If the current thread not the main thread, then the call is queued and
    executed afterwards.
    
    @param callable: A python callable object, must return an integer value
    @param reqf: one of MFF_ flags
    @return: -1 or the return value of the callable
    """
    return _ida_kernwin.execute_sync(*args)

def execute_ui_requests(*args) -> "bool":
    r"""


    execute_ui_requests(py_list) -> bool
    Inserts a list of callables into the UI message processing queue.
    When the UI is ready it will call one callable.
    A callable can request to be called more than once if it returns True.
    
    @param callable_list: A list of python callable objects.
    @note: A callable should return True if it wants to be called more than once.
    @return: Boolean. False if the list contains a non callabale item
    """
    return _ida_kernwin.execute_ui_requests(*args)
class jobj_wrapper_t(object):
    r"""
    Proxy of C++ jobj_wrapper_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def get_dict(self, *args) -> "PyObject *":
        r"""
        get_dict(self) -> PyObject *
        """
        return _ida_kernwin.jobj_wrapper_t_get_dict(self, *args)

# Register jobj_wrapper_t in _ida_kernwin:
_ida_kernwin.jobj_wrapper_t_swigregister(jobj_wrapper_t)

class UI_Hooks(object):
    r"""
    Proxy of C++ UI_Hooks class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        __init__(self, _flags=0) -> UI_Hooks
            _flags: uint32
        """
        if self.__class__ == UI_Hooks:
            _self = None
        else:
            _self = self
        _ida_kernwin.UI_Hooks_swiginit(self, _ida_kernwin.new_UI_Hooks(_self, *args))

    def hook(self, *args) -> "bool":
        r"""
        hook(self) -> bool
        """
        return _ida_kernwin.UI_Hooks_hook(self, *args)

    def unhook(self, *args) -> "bool":
        r"""
        unhook(self) -> bool
        """
        return _ida_kernwin.UI_Hooks_unhook(self, *args)

    def range(self, *args) -> "void":
        r"""


        The disassembly range has been changed (\inf{min_ea} ...
        \inf{max_ea}). UI should redraw the scrollbars. See also:
        'ui_lock_range_refresh'
        """
        return _ida_kernwin.UI_Hooks_range(self, *args)

    def idcstart(self, *args) -> "void":
        r"""


        Start of IDC engine work.
        """
        return _ida_kernwin.UI_Hooks_idcstart(self, *args)

    def idcstop(self, *args) -> "void":
        r"""


        Stop of IDC engine work.
        """
        return _ida_kernwin.UI_Hooks_idcstop(self, *args)

    def suspend(self, *args) -> "void":
        r"""


        Suspend graphical interface. Only the text version. Interface
        should respond to it.
        """
        return _ida_kernwin.UI_Hooks_suspend(self, *args)

    def resume(self, *args) -> "void":
        r"""


        Resume the suspended graphical interface. Only the text version.
        Interface should respond to it
        """
        return _ida_kernwin.UI_Hooks_resume(self, *args)

    def saving(self, *args) -> "void":
        r"""


        The kernel is flushing its buffers to the disk. The user interface
        should save its state. Parameters: none Returns: none
        """
        return _ida_kernwin.UI_Hooks_saving(self, *args)

    def saved(self, *args) -> "void":
        r"""


        The kernel has saved the database. This callback just informs the
        interface.
        """
        return _ida_kernwin.UI_Hooks_saved(self, *args)

    def database_closed(self, *args) -> "void":
        r"""


        The database has been closed. See also processor_t::closebase, it
        occurs earlier. See also ui_initing_database. This is not the same as
        IDA exiting. If you need to perform cleanup at the exiting time, use
        'qatexit()' .
        """
        return _ida_kernwin.UI_Hooks_database_closed(self, *args)

    def debugger_menu_change(self, *args) -> "void":
        r"""


        debugger menu modification detected
        
        debugger_menu_change(self, enable)
            @param enable: true: debugger menu has been added, or a different
                           debugger has been selected false: debugger menu will be
                           removed (user switched to "No debugger")  (C++: bool)
        """
        return _ida_kernwin.UI_Hooks_debugger_menu_change(self, *args)

    def widget_visible(self, *args) -> "void":
        r"""


        TWidget is displayed on the screen. Use this event to populate the
        window with controls
        
        widget_visible(self, widget)
            @param widget (C++: TWidget *)
        """
        return _ida_kernwin.UI_Hooks_widget_visible(self, *args)

    def widget_closing(self, *args) -> "void":
        r"""


        TWidget is about to close. This event precedes ui_widget_invisible.
        Use this to perform some possible actions relevant to the lifecycle of
        this widget
        
        widget_closing(self, widget)
            @param widget (C++: TWidget *)
        """
        return _ida_kernwin.UI_Hooks_widget_closing(self, *args)

    def widget_invisible(self, *args) -> "void":
        r"""


        TWidget is being closed. Use this event to destroy the window controls
        
        widget_invisible(self, widget)
            @param widget (C++: TWidget *)
        """
        return _ida_kernwin.UI_Hooks_widget_invisible(self, *args)

    def get_ea_hint(self, *args) -> "PyObject *":
        r"""


        ui wants to display a simple hint for an address. Use this event
        to generate a custom hint See also more generic 'ui_get_item_hint'
        
        get_ea_hint(self, ea) -> PyObject *
            @param ea (C++: ea_t)
        """
        return _ida_kernwin.UI_Hooks_get_ea_hint(self, *args)

    def get_item_hint(self, *args) -> "PyObject *":
        r"""


        ui wants to display multiline hint for an item. See also more
        generic 'ui_get_custom_viewer_hint'
        
        get_item_hint(self, ea, max_lines) -> PyObject *
            @param ea: or item id like a structure or enum member  (C++: ea_t)
            @param max_lines: maximal number of lines  (C++: int)
        """
        return _ida_kernwin.UI_Hooks_get_item_hint(self, *args)

    def get_custom_viewer_hint(self, *args) -> "PyObject *":
        r"""


        ui wants to display a hint for a viewer (idaview or custom). If
        the REG_HINTS_MARKER sequence is found in the returned hints string,
        it will be replaced with the contents of the "regular" hints. If the
        SRCDBG_HINTS_MARKER sequence is found in the returned hints string, it
        will be replaced with the contents of the source-level debugger-
        generated hints. The following keywords might appear at the beginning
        of the returned hints: HIGHLIGHT textwhere text will be highlighted
        CAPTION captioncaption for the hint widget
        
        get_custom_viewer_hint(self, viewer, place) -> PyObject *
            @param viewer: viewer  (C++: TWidget*)
            @param place: current position in the viewer  (C++: place_t *)
        """
        return _ida_kernwin.UI_Hooks_get_custom_viewer_hint(self, *args)

    def database_inited(self, *args) -> "void":
        r"""


        database initialization has completed. the kernel is about to run
        idc scripts
        
        database_inited(self, is_new_database, idc_script)
            @param is_new_database (C++: int)
            @param idc_script: - may be NULL  (C++: const char *)
        """
        return _ida_kernwin.UI_Hooks_database_inited(self, *args)

    def ready_to_run(self, *args) -> "void":
        r"""


        all UI elements have been initialized. Automatic plugins may hook
        to this event to perform their tasks.
        """
        return _ida_kernwin.UI_Hooks_ready_to_run(self, *args)

    def preprocess_action(self, *args) -> "int":
        r"""


        ida ui is about to handle a user action.
        
        preprocess_action(self, name) -> int
            @param name: ui action name. these names can be looked up in
                         ida[tg]ui.cfg  (C++: const char *)
            @retval: 0 - ok
            @retval: nonzero - a plugin has handled the command
        """
        return _ida_kernwin.UI_Hooks_preprocess_action(self, *args)

    def postprocess_action(self, *args) -> "void":
        r"""


        an ida ui action has been handled
        """
        return _ida_kernwin.UI_Hooks_postprocess_action(self, *args)

    def get_chooser_item_attrs(self, *args) -> "void":
        r"""


        get item-specific attributes for a chooser. This callback is
        generated only after enable_chooser_attrs()
        
        get_chooser_item_attrs(self, chooser, n, attrs)
            @param chooser (C++: const chooser_base_t *)
            @param n (C++: size_t)
            @param attrs (C++: chooser_item_attrs_t *)
        """
        return _ida_kernwin.UI_Hooks_get_chooser_item_attrs(self, *args)

    def updating_actions(self, *args) -> "void":
        r"""


        IDA is about to update all actions. If your plugin needs to
        perform expensive operations more than once (e.g., once per action it
        registers), you should do them only once, right away.
        
        updating_actions(self, ctx)
            @param ctx (C++: action_update_ctx_t *)
        """
        return _ida_kernwin.UI_Hooks_updating_actions(self, *args)

    def updated_actions(self, *args) -> "void":
        r"""


        IDA is done updating actions.
        """
        return _ida_kernwin.UI_Hooks_updated_actions(self, *args)

    def populating_widget_popup(self, *args) -> "void":
        r"""


        IDA is populating the context menu for a widget. This is your
        chance to 'attach_action_to_popup()' .Have a look at
        ui_finish_populating_widget_popup, if you want to augment the context
        menu with your own actions after the menu has had a chance to be
        properly populated by the owning component or plugin (which typically
        does it on ui_populating_widget_popup.)
        
        populating_widget_popup(self, widget, popup_handle, ctx=None)
            @param widget (C++: TWidget *)
            @param popup_handle (C++: TPopupMenu *)
            @param ctx (C++: const action_activation_ctx_t *)
        """
        return _ida_kernwin.UI_Hooks_populating_widget_popup(self, *args)

    def finish_populating_widget_popup(self, *args) -> "void":
        r"""


        IDA is about to be done populating the context menu for a widget.
        This is your chance to 'attach_action_to_popup()' .
        
        finish_populating_widget_popup(self, widget, popup_handle, ctx=None)
            @param widget (C++: TWidget *)
            @param popup_handle (C++: TPopupMenu *)
            @param ctx (C++: const action_activation_ctx_t *)
        """
        return _ida_kernwin.UI_Hooks_finish_populating_widget_popup(self, *args)

    def plugin_loaded(self, *args) -> "void":
        r"""


        The plugin was loaded in memory.
        
        plugin_loaded(self, plugin_info)
            @param plugin_info (C++: const plugin_info_t *)
        """
        return _ida_kernwin.UI_Hooks_plugin_loaded(self, *args)

    def plugin_unloading(self, *args) -> "void":
        r"""


        The plugin is about to be unloaded
        
        plugin_unloading(self, plugin_info)
            @param plugin_info (C++: const plugin_info_t *)
        """
        return _ida_kernwin.UI_Hooks_plugin_unloading(self, *args)

    def current_widget_changed(self, *args) -> "void":
        r"""


        The currently-active TWidget changed.
        
        current_widget_changed(self, widget, prev_widget)
            @param widget (C++: TWidget *)
            @param prev_widget (C++: TWidget *)
        """
        return _ida_kernwin.UI_Hooks_current_widget_changed(self, *args)

    def screen_ea_changed(self, *args) -> "void":
        r"""


        The "current address" changed
        
        screen_ea_changed(self, ea, prev_ea)
            @param ea (C++: ea_t)
            @param prev_ea (C++: ea_t)
        """
        return _ida_kernwin.UI_Hooks_screen_ea_changed(self, *args)

    def create_desktop_widget(self, *args) -> "PyObject *":
        r"""


        create a widget, to be placed in the widget tree (at desktop-
        creation time.)
        
        create_desktop_widget(self, title, cfg) -> PyObject *
            @param title (C++: const char *)
            @param cfg (C++: const jobj_t *)
        """
        return _ida_kernwin.UI_Hooks_create_desktop_widget(self, *args)

    def get_lines_rendering_info(self, *args) -> "void":
        r"""


        get lines rendering information
        
        get_lines_rendering_info(self, out, widget, info)
            @param out (C++: lines_rendering_output_t *)
            @param widget (C++: const TWidget *)
            @param info (C++: const lines_rendering_input_t *)
        """
        return _ida_kernwin.UI_Hooks_get_lines_rendering_info(self, *args)

    def get_widget_config(self, *args) -> "PyObject *":
        r"""


        retrieve the widget configuration (it will be passed back at
        ui_create_desktop_widget-, and ui_set_widget_config-time)
        
        get_widget_config(self, widget, cfg) -> PyObject *
            @param widget (C++: const TWidget *)
            @param cfg (C++: jobj_t *)
        """
        return _ida_kernwin.UI_Hooks_get_widget_config(self, *args)

    def set_widget_config(self, *args) -> "void":
        r"""


        set the widget configuration
        
        set_widget_config(self, widget, cfg)
            @param widget (C++: const TWidget *)
            @param cfg (C++: const jobj_t *)
        """
        return _ida_kernwin.UI_Hooks_set_widget_config(self, *args)

    def initing_database(self, *args) -> "void":
        r"""


        database initialization has started.
        """
        return _ida_kernwin.UI_Hooks_initing_database(self, *args)

    def destroying_procmod(self, *args) -> "void":
        r"""


        The processor module is about to be destroyed
        
        destroying_procmod(self, procmod)
            @param procmod (C++: const procmod_t *)
        """
        return _ida_kernwin.UI_Hooks_destroying_procmod(self, *args)

    def destroying_plugmod(self, *args) -> "void":
        r"""


        The plugin object is about to be destroyed
        
        destroying_plugmod(self, plugmod)
            @param plugmod (C++: const plugmod_t *)
        """
        return _ida_kernwin.UI_Hooks_destroying_plugmod(self, *args)
    __swig_destroy__ = _ida_kernwin.delete_UI_Hooks
    def __disown__(self):
        self.this.disown()
        _ida_kernwin.disown_UI_Hooks(self)
        return weakref.proxy(self)

# Register UI_Hooks in _ida_kernwin:
_ida_kernwin.UI_Hooks_swigregister(UI_Hooks)


def register_action(*args) -> "bool":
    r"""


    Create a new action ( 'ui_register_action' ). After an action has been
    created, it is possible to attach it to menu items (
    'attach_action_to_menu()' ), or to popup menus (
    'attach_action_to_popup()' ).Because the actions will need to call the
    handler's activate() and update() methods at any time, you shouldn't
    build your action handler on the stack.Please see the SDK's "ht_view"
    plugin for an example how to register actions.
    
    register_action(desc) -> bool
        @param desc: action to register (C++: const  action_desc_t  &)
        @return: success
    """
    return _ida_kernwin.register_action(*args)

def get_registered_actions(*args) -> "PyObject *":
    r"""


    Get a list of all currently-registered actions
    """
    return _ida_kernwin.get_registered_actions(*args)

def attach_dynamic_action_to_popup(*args) -> "bool":
    r"""


    Create & insert an action into the widget's popup menu (
    'ui_attach_dynamic_action_to_popup' ). 'action_desc_t::handler' for
    'desc' must be instantiated using 'new', as it will be 'delete'd when
    the action is unregistered.
    
    attach_dynamic_action_to_popup(widget, popup_handle, desc, popuppath=None, flags=0) -> bool
        @param widget: target widget (C++: TWidget *)
        @param popup_handle: target popup (C++: TPopupMenu *)
        @param desc: created with  DYNACTION_DESC_LITERAL (C++: const
                     action_desc_t  &)
        @param popuppath: can be NULL (C++: const char *)
        @param flags: a combination of SETMENU_ constants (see  Set menu flags
                      ) (C++: int)
        @return: success
    """
    return _ida_kernwin.attach_dynamic_action_to_popup(*args)
class disasm_line_t(object):
    r"""
    Proxy of C++ disasm_line_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _ida_kernwin.delete_disasm_line_t

    def __init__(self, *args):
        r"""


        __init__(self) -> disasm_line_t
            other: disasm_line_t const &
        """
        _ida_kernwin.disasm_line_t_swiginit(self, _ida_kernwin.new_disasm_line_t(*args))
    at = property(_ida_kernwin.disasm_line_t_at_get, _ida_kernwin.disasm_line_t_at_set)
    line = property(_ida_kernwin.disasm_line_t_line_get, _ida_kernwin.disasm_line_t_line_set)
    prefix_color = property(_ida_kernwin.disasm_line_t_prefix_color_get, _ida_kernwin.disasm_line_t_prefix_color_set)
    bg_color = property(_ida_kernwin.disasm_line_t_bg_color_get, _ida_kernwin.disasm_line_t_bg_color_set)
    is_default = property(_ida_kernwin.disasm_line_t_is_default_get, _ida_kernwin.disasm_line_t_is_default_set)

# Register disasm_line_t in _ida_kernwin:
_ida_kernwin.disasm_line_t_swigregister(disasm_line_t)


def gen_disasm_text(*args) -> "void":
    r"""


    Generate disassembly text for a range.
    
    gen_disasm_text(text, ea1, ea2, truncate_lines)
        @param text: result (C++: text_t  &)
        @param ea1: start address (C++: ea_t)
        @param ea2: end address (C++: ea_t)
        @param truncate_lines: (on  idainfo::margin ) (C++: bool)
    """
    return _ida_kernwin.gen_disasm_text(*args)

def set_nav_colorizer(*args) -> "PyObject *":
    r"""


    set_nav_colorizer(new_py_colorizer) -> PyObject *
    Set a new colorizer for the navigation band.
    
    The 'callback' is a function of 2 arguments:
       - ea (the EA to colorize for)
       - nbytes (the number of bytes at that EA)
    and must return a 'long' value.
    
    The previous colorizer is returned, allowing
    the new 'callback' to use 'call_nav_colorizer'
    with it.
    
    Note that the previous colorizer is returned
    only the first time set_nav_colorizer() is called:
    due to the way the colorizers API is defined in C,
    it is impossible to chain more than 2 colorizers
    in IDAPython: the original, IDA-provided colorizer,
    and a user-provided one.
    
    Example: colorizer inverting the color provided by the IDA colorizer:
        def my_colorizer(ea, nbytes):
            global ida_colorizer
            orig = idaapi.call_nav_colorizer(ida_colorizer, ea, nbytes)
            return long(~orig)
    
        ida_colorizer = idaapi.set_nav_colorizer(my_colorizer)
    """
    return _ida_kernwin.set_nav_colorizer(*args)

def call_nav_colorizer(*args) -> "uint32":
    r"""


    call_nav_colorizer(dict, ea, nbytes) -> uint32
    To be used with the IDA-provided colorizer, that is
    returned as result of the first call to set_nav_colorizer().
    """
    return _ida_kernwin.call_nav_colorizer(*args)

def msg_get_lines(*args) -> "PyObject *":
    r"""


    Retrieve the last 'count' lines from the output window, in reverse
    order (from most recent, to least recent)
    
    msg_get_lines(count=-1) -> PyObject *
        @param count: The number of lines to retrieve. -1 means: all (C++:
                      int)
    """
    return _ida_kernwin.msg_get_lines(*args)

def TWidget__from_ptrval__(*args) -> "TWidget *":
    r"""


    TWidget__from_ptrval__(ptrval) -> TWidget *
        ptrval: size_t
    """
    return _ida_kernwin.TWidget__from_ptrval__(*args)

def add_spaces(*args) -> "PyObject *":
    r"""


    Add space characters to the colored string so that its length will be
    at least 'len' characters. Don't trim the string if it is longer than
    'len'.
    
    add_spaces(s, len) -> PyObject *
        s: char const *
        @param len: the desired length of the string (C++: ssize_t)
        @return: pointer to the end of input string
    """
    return _ida_kernwin.add_spaces(*args)

def show_wait_box(*args) -> "void":
    r"""


    Display a dialog box with "Please wait...". If the text message starts
    with "HIDECANCEL\n", the cancel buttonwon't be displayed in the dialog
    box and you don't need to checkfor cancellations with
    'user_cancelled()' . Plugins must call 'hide_wait_box()' to close the
    dialog box, otherwise the user interface will be disabled.Note that,
    if the wait dialog is already visible, 'show_wait_box()' will1) push
    the currently-displayed text on a stack2) display the new textThen,
    when 'hide_wait_box()' is called, if that stack isn't empty its
    toplabel will be popped and restored in the wait dialog.This implies
    that a plugin should call 'hide_wait_box()' exactly as manytimes as it
    called 'show_wait_box()' , or the wait dialog might remainvisible and
    block the UI.Also, in case the plugin knows the wait dialog is
    currently displayed,alternatively it can call 'replace_wait_box()' ,
    to replace the text of thedialog without pushing the currently-
    displayed text on the stack.
    
    show_wait_box(message)
        message: char const *
    """
    return _ida_kernwin.show_wait_box(*args)

def hide_wait_box(*args) -> "void":
    r"""


    Hide the "Please wait dialog box".
    """
    return _ida_kernwin.hide_wait_box(*args)
class line_rendering_output_entries_refs_t(object):
    r"""
    Proxy of C++ qvector< line_rendering_output_entry_t * > class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        __init__(self) -> line_rendering_output_entries_refs_t
            x: qvector< line_rendering_output_entry_t * > const &
        """
        _ida_kernwin.line_rendering_output_entries_refs_t_swiginit(self, _ida_kernwin.new_line_rendering_output_entries_refs_t(*args))
    __swig_destroy__ = _ida_kernwin.delete_line_rendering_output_entries_refs_t

    def push_back(self, *args) -> "line_rendering_output_entry_t *&":
        r"""


        push_back(self, x)
            x: line_rendering_output_entry_t *const &
        """
        return _ida_kernwin.line_rendering_output_entries_refs_t_push_back(self, *args)

    def pop_back(self, *args) -> "void":
        r"""
        pop_back(self)
        """
        return _ida_kernwin.line_rendering_output_entries_refs_t_pop_back(self, *args)

    def size(self, *args) -> "size_t":
        r"""
        size(self) -> size_t
        """
        return _ida_kernwin.line_rendering_output_entries_refs_t_size(self, *args)

    def empty(self, *args) -> "bool":
        r"""
        empty(self) -> bool
        """
        return _ida_kernwin.line_rendering_output_entries_refs_t_empty(self, *args)

    def at(self, *args) -> "line_rendering_output_entry_t *const &":
        r"""


        at(self, _idx) -> line_rendering_output_entry_t
            _idx: size_t
        """
        return _ida_kernwin.line_rendering_output_entries_refs_t_at(self, *args)

    def qclear(self, *args) -> "void":
        r"""
        qclear(self)
        """
        return _ida_kernwin.line_rendering_output_entries_refs_t_qclear(self, *args)

    def clear(self, *args) -> "void":
        r"""
        clear(self)
        """
        return _ida_kernwin.line_rendering_output_entries_refs_t_clear(self, *args)

    def resize(self, *args) -> "void":
        r"""


        resize(self, _newsize, x)
            _newsize: size_t
            x: line_rendering_output_entry_t *const &
        

        resize(self, _newsize)
            _newsize: size_t
        """
        return _ida_kernwin.line_rendering_output_entries_refs_t_resize(self, *args)

    def capacity(self, *args) -> "size_t":
        r"""
        capacity(self) -> size_t
        """
        return _ida_kernwin.line_rendering_output_entries_refs_t_capacity(self, *args)

    def reserve(self, *args) -> "void":
        r"""


        reserve(self, cnt)
            cnt: size_t
        """
        return _ida_kernwin.line_rendering_output_entries_refs_t_reserve(self, *args)

    def truncate(self, *args) -> "void":
        r"""
        truncate(self)
        """
        return _ida_kernwin.line_rendering_output_entries_refs_t_truncate(self, *args)

    def swap(self, *args) -> "void":
        r"""


        swap(self, r)
            r: qvector< line_rendering_output_entry_t * > &
        """
        return _ida_kernwin.line_rendering_output_entries_refs_t_swap(self, *args)

    def extract(self, *args) -> "line_rendering_output_entry_t **":
        r"""
        extract(self) -> line_rendering_output_entry_t **
        """
        return _ida_kernwin.line_rendering_output_entries_refs_t_extract(self, *args)

    def inject(self, *args) -> "void":
        r"""


        inject(self, s, len)
            s: line_rendering_output_entry_t **
            len: size_t
        """
        return _ida_kernwin.line_rendering_output_entries_refs_t_inject(self, *args)

    def __eq__(self, *args) -> "bool":
        r"""


        __eq__(self, r) -> bool
            r: qvector< line_rendering_output_entry_t * > const &
        """
        return _ida_kernwin.line_rendering_output_entries_refs_t___eq__(self, *args)

    def __ne__(self, *args) -> "bool":
        r"""


        __ne__(self, r) -> bool
            r: qvector< line_rendering_output_entry_t * > const &
        """
        return _ida_kernwin.line_rendering_output_entries_refs_t___ne__(self, *args)

    def begin(self, *args) -> "qvector< line_rendering_output_entry_t * >::const_iterator":
        r"""
        begin(self) -> qvector< line_rendering_output_entry_t * >::iterator
        begin(self) -> qvector< line_rendering_output_entry_t * >::const_iterator
        """
        return _ida_kernwin.line_rendering_output_entries_refs_t_begin(self, *args)

    def end(self, *args) -> "qvector< line_rendering_output_entry_t * >::const_iterator":
        r"""
        end(self) -> qvector< line_rendering_output_entry_t * >::iterator
        end(self) -> qvector< line_rendering_output_entry_t * >::const_iterator
        """
        return _ida_kernwin.line_rendering_output_entries_refs_t_end(self, *args)

    def insert(self, *args) -> "qvector< line_rendering_output_entry_t * >::iterator":
        r"""


        insert(self, it, x) -> qvector< line_rendering_output_entry_t * >::iterator
            it: qvector< line_rendering_output_entry_t * >::iterator
            x: line_rendering_output_entry_t *const &
        """
        return _ida_kernwin.line_rendering_output_entries_refs_t_insert(self, *args)

    def erase(self, *args) -> "qvector< line_rendering_output_entry_t * >::iterator":
        r"""


        erase(self, it) -> qvector< line_rendering_output_entry_t * >::iterator
            it: qvector< line_rendering_output_entry_t * >::iterator
        

        erase(self, first, last) -> qvector< line_rendering_output_entry_t * >::iterator
            first: qvector< line_rendering_output_entry_t * >::iterator
            last: qvector< line_rendering_output_entry_t * >::iterator
        """
        return _ida_kernwin.line_rendering_output_entries_refs_t_erase(self, *args)

    def find(self, *args) -> "qvector< line_rendering_output_entry_t * >::const_iterator":
        r"""


        find(self, x) -> qvector< line_rendering_output_entry_t * >::iterator
            x: line_rendering_output_entry_t *const &
        

        find(self, x) -> qvector< line_rendering_output_entry_t * >::const_iterator
            x: line_rendering_output_entry_t *const &
        """
        return _ida_kernwin.line_rendering_output_entries_refs_t_find(self, *args)

    def has(self, *args) -> "bool":
        r"""


        has(self, x) -> bool
            x: line_rendering_output_entry_t *const &
        """
        return _ida_kernwin.line_rendering_output_entries_refs_t_has(self, *args)

    def add_unique(self, *args) -> "bool":
        r"""


        add_unique(self, x) -> bool
            x: line_rendering_output_entry_t *const &
        """
        return _ida_kernwin.line_rendering_output_entries_refs_t_add_unique(self, *args)

    def _del(self, *args) -> "bool":
        r"""


        _del(self, x) -> bool
            x: line_rendering_output_entry_t *const &
        """
        return _ida_kernwin.line_rendering_output_entries_refs_t__del(self, *args)

    def __len__(self, *args) -> "size_t":
        r"""
        __len__(self) -> size_t
        """
        return _ida_kernwin.line_rendering_output_entries_refs_t___len__(self, *args)

    def __getitem__(self, *args) -> "line_rendering_output_entry_t *const &":
        r"""


        __getitem__(self, i) -> line_rendering_output_entry_t
            i: size_t
        """
        return _ida_kernwin.line_rendering_output_entries_refs_t___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        r"""


        __setitem__(self, i, v)
            i: size_t
            v: line_rendering_output_entry_t *const &
        """
        return _ida_kernwin.line_rendering_output_entries_refs_t___setitem__(self, *args)

    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator


    def _internal_push_back(self, *args) -> "void":
        r"""


        _internal_push_back(self, e)
            e: line_rendering_output_entry_t *
        """
        return _ida_kernwin.line_rendering_output_entries_refs_t__internal_push_back(self, *args)

    def push_back(self, e):
        if e and e.thisown:
            self._internal_push_back(e)
            e.thisown = False


# Register line_rendering_output_entries_refs_t in _ida_kernwin:
_ida_kernwin.line_rendering_output_entries_refs_t_swigregister(line_rendering_output_entries_refs_t)

class section_lines_refs_t(object):
    r"""
    Proxy of C++ qvector< twinline_t const * > class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        __init__(self) -> section_lines_refs_t
            x: qvector< twinline_t const * > const &
        """
        _ida_kernwin.section_lines_refs_t_swiginit(self, _ida_kernwin.new_section_lines_refs_t(*args))
    __swig_destroy__ = _ida_kernwin.delete_section_lines_refs_t

    def push_back(self, *args) -> "twinline_t const *&":
        r"""


        push_back(self, x)
            x: twinline_t const *const &
        """
        return _ida_kernwin.section_lines_refs_t_push_back(self, *args)

    def pop_back(self, *args) -> "void":
        r"""
        pop_back(self)
        """
        return _ida_kernwin.section_lines_refs_t_pop_back(self, *args)

    def size(self, *args) -> "size_t":
        r"""
        size(self) -> size_t
        """
        return _ida_kernwin.section_lines_refs_t_size(self, *args)

    def empty(self, *args) -> "bool":
        r"""
        empty(self) -> bool
        """
        return _ida_kernwin.section_lines_refs_t_empty(self, *args)

    def at(self, *args) -> "twinline_t const *const &":
        r"""


        at(self, _idx) -> twinline_t
            _idx: size_t
        """
        return _ida_kernwin.section_lines_refs_t_at(self, *args)

    def qclear(self, *args) -> "void":
        r"""
        qclear(self)
        """
        return _ida_kernwin.section_lines_refs_t_qclear(self, *args)

    def clear(self, *args) -> "void":
        r"""
        clear(self)
        """
        return _ida_kernwin.section_lines_refs_t_clear(self, *args)

    def resize(self, *args) -> "void":
        r"""


        resize(self, _newsize, x)
            _newsize: size_t
            x: twinline_t const *const &
        

        resize(self, _newsize)
            _newsize: size_t
        """
        return _ida_kernwin.section_lines_refs_t_resize(self, *args)

    def capacity(self, *args) -> "size_t":
        r"""
        capacity(self) -> size_t
        """
        return _ida_kernwin.section_lines_refs_t_capacity(self, *args)

    def reserve(self, *args) -> "void":
        r"""


        reserve(self, cnt)
            cnt: size_t
        """
        return _ida_kernwin.section_lines_refs_t_reserve(self, *args)

    def truncate(self, *args) -> "void":
        r"""
        truncate(self)
        """
        return _ida_kernwin.section_lines_refs_t_truncate(self, *args)

    def swap(self, *args) -> "void":
        r"""


        swap(self, r)
            r: qvector< twinline_t const * > &
        """
        return _ida_kernwin.section_lines_refs_t_swap(self, *args)

    def extract(self, *args) -> "twinline_t const **":
        r"""
        extract(self) -> twinline_t const **
        """
        return _ida_kernwin.section_lines_refs_t_extract(self, *args)

    def inject(self, *args) -> "void":
        r"""


        inject(self, s, len)
            s: twinline_t const **
            len: size_t
        """
        return _ida_kernwin.section_lines_refs_t_inject(self, *args)

    def __eq__(self, *args) -> "bool":
        r"""


        __eq__(self, r) -> bool
            r: qvector< twinline_t const * > const &
        """
        return _ida_kernwin.section_lines_refs_t___eq__(self, *args)

    def __ne__(self, *args) -> "bool":
        r"""


        __ne__(self, r) -> bool
            r: qvector< twinline_t const * > const &
        """
        return _ida_kernwin.section_lines_refs_t___ne__(self, *args)

    def begin(self, *args) -> "qvector< twinline_t const * >::const_iterator":
        r"""
        begin(self) -> qvector< twinline_t const * >::iterator
        begin(self) -> qvector< twinline_t const * >::const_iterator
        """
        return _ida_kernwin.section_lines_refs_t_begin(self, *args)

    def end(self, *args) -> "qvector< twinline_t const * >::const_iterator":
        r"""
        end(self) -> qvector< twinline_t const * >::iterator
        end(self) -> qvector< twinline_t const * >::const_iterator
        """
        return _ida_kernwin.section_lines_refs_t_end(self, *args)

    def insert(self, *args) -> "qvector< twinline_t const * >::iterator":
        r"""


        insert(self, it, x) -> qvector< twinline_t const * >::iterator
            it: qvector< twinline_t const * >::iterator
            x: twinline_t const *const &
        """
        return _ida_kernwin.section_lines_refs_t_insert(self, *args)

    def erase(self, *args) -> "qvector< twinline_t const * >::iterator":
        r"""


        erase(self, it) -> qvector< twinline_t const * >::iterator
            it: qvector< twinline_t const * >::iterator
        

        erase(self, first, last) -> qvector< twinline_t const * >::iterator
            first: qvector< twinline_t const * >::iterator
            last: qvector< twinline_t const * >::iterator
        """
        return _ida_kernwin.section_lines_refs_t_erase(self, *args)

    def find(self, *args) -> "qvector< twinline_t const * >::const_iterator":
        r"""


        find(self, x) -> qvector< twinline_t const * >::iterator
            x: twinline_t const *const &
        

        find(self, x) -> qvector< twinline_t const * >::const_iterator
            x: twinline_t const *const &
        """
        return _ida_kernwin.section_lines_refs_t_find(self, *args)

    def has(self, *args) -> "bool":
        r"""


        has(self, x) -> bool
            x: twinline_t const *const &
        """
        return _ida_kernwin.section_lines_refs_t_has(self, *args)

    def add_unique(self, *args) -> "bool":
        r"""


        add_unique(self, x) -> bool
            x: twinline_t const *const &
        """
        return _ida_kernwin.section_lines_refs_t_add_unique(self, *args)

    def _del(self, *args) -> "bool":
        r"""


        _del(self, x) -> bool
            x: twinline_t const *const &
        """
        return _ida_kernwin.section_lines_refs_t__del(self, *args)

    def __len__(self, *args) -> "size_t":
        r"""
        __len__(self) -> size_t
        """
        return _ida_kernwin.section_lines_refs_t___len__(self, *args)

    def __getitem__(self, *args) -> "twinline_t const *const &":
        r"""


        __getitem__(self, i) -> twinline_t
            i: size_t
        """
        return _ida_kernwin.section_lines_refs_t___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        r"""


        __setitem__(self, i, v)
            i: size_t
            v: twinline_t const *const &
        """
        return _ida_kernwin.section_lines_refs_t___setitem__(self, *args)

    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator


# Register section_lines_refs_t in _ida_kernwin:
_ida_kernwin.section_lines_refs_t_swigregister(section_lines_refs_t)

class sections_lines_refs_t(object):
    r"""
    Proxy of C++ qvector< section_lines_refs_t > class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        __init__(self) -> sections_lines_refs_t
            x: qvector< section_lines_refs_t > const &
        """
        _ida_kernwin.sections_lines_refs_t_swiginit(self, _ida_kernwin.new_sections_lines_refs_t(*args))
    __swig_destroy__ = _ida_kernwin.delete_sections_lines_refs_t

    def push_back(self, *args) -> "section_lines_refs_t &":
        r"""


        push_back(self, x)
            x: section_lines_refs_t const &
        """
        return _ida_kernwin.sections_lines_refs_t_push_back(self, *args)

    def pop_back(self, *args) -> "void":
        r"""
        pop_back(self)
        """
        return _ida_kernwin.sections_lines_refs_t_pop_back(self, *args)

    def size(self, *args) -> "size_t":
        r"""
        size(self) -> size_t
        """
        return _ida_kernwin.sections_lines_refs_t_size(self, *args)

    def empty(self, *args) -> "bool":
        r"""
        empty(self) -> bool
        """
        return _ida_kernwin.sections_lines_refs_t_empty(self, *args)

    def at(self, *args) -> "section_lines_refs_t const &":
        r"""


        at(self, _idx) -> section_lines_refs_t
            _idx: size_t
        """
        return _ida_kernwin.sections_lines_refs_t_at(self, *args)

    def qclear(self, *args) -> "void":
        r"""
        qclear(self)
        """
        return _ida_kernwin.sections_lines_refs_t_qclear(self, *args)

    def clear(self, *args) -> "void":
        r"""
        clear(self)
        """
        return _ida_kernwin.sections_lines_refs_t_clear(self, *args)

    def resize(self, *args) -> "void":
        r"""


        resize(self, _newsize, x)
            _newsize: size_t
            x: section_lines_refs_t const &
        

        resize(self, _newsize)
            _newsize: size_t
        """
        return _ida_kernwin.sections_lines_refs_t_resize(self, *args)

    def grow(self, *args) -> "void":
        r"""


        grow(self, x=section_lines_refs_t())
            x: section_lines_refs_t const &
        """
        return _ida_kernwin.sections_lines_refs_t_grow(self, *args)

    def capacity(self, *args) -> "size_t":
        r"""
        capacity(self) -> size_t
        """
        return _ida_kernwin.sections_lines_refs_t_capacity(self, *args)

    def reserve(self, *args) -> "void":
        r"""


        reserve(self, cnt)
            cnt: size_t
        """
        return _ida_kernwin.sections_lines_refs_t_reserve(self, *args)

    def truncate(self, *args) -> "void":
        r"""
        truncate(self)
        """
        return _ida_kernwin.sections_lines_refs_t_truncate(self, *args)

    def swap(self, *args) -> "void":
        r"""


        swap(self, r)
            r: qvector< section_lines_refs_t > &
        """
        return _ida_kernwin.sections_lines_refs_t_swap(self, *args)

    def extract(self, *args) -> "section_lines_refs_t *":
        r"""
        extract(self) -> section_lines_refs_t
        """
        return _ida_kernwin.sections_lines_refs_t_extract(self, *args)

    def inject(self, *args) -> "void":
        r"""


        inject(self, s, len)
            s: section_lines_refs_t *
            len: size_t
        """
        return _ida_kernwin.sections_lines_refs_t_inject(self, *args)

    def __eq__(self, *args) -> "bool":
        r"""


        __eq__(self, r) -> bool
            r: qvector< section_lines_refs_t > const &
        """
        return _ida_kernwin.sections_lines_refs_t___eq__(self, *args)

    def __ne__(self, *args) -> "bool":
        r"""


        __ne__(self, r) -> bool
            r: qvector< section_lines_refs_t > const &
        """
        return _ida_kernwin.sections_lines_refs_t___ne__(self, *args)

    def begin(self, *args) -> "qvector< section_lines_refs_t >::const_iterator":
        r"""
        begin(self) -> qvector< section_lines_refs_t >::iterator
        begin(self) -> qvector< section_lines_refs_t >::const_iterator
        """
        return _ida_kernwin.sections_lines_refs_t_begin(self, *args)

    def end(self, *args) -> "qvector< section_lines_refs_t >::const_iterator":
        r"""
        end(self) -> qvector< section_lines_refs_t >::iterator
        end(self) -> qvector< section_lines_refs_t >::const_iterator
        """
        return _ida_kernwin.sections_lines_refs_t_end(self, *args)

    def insert(self, *args) -> "qvector< section_lines_refs_t >::iterator":
        r"""


        insert(self, it, x) -> qvector< section_lines_refs_t >::iterator
            it: qvector< section_lines_refs_t >::iterator
            x: section_lines_refs_t const &
        """
        return _ida_kernwin.sections_lines_refs_t_insert(self, *args)

    def erase(self, *args) -> "qvector< section_lines_refs_t >::iterator":
        r"""


        erase(self, it) -> qvector< section_lines_refs_t >::iterator
            it: qvector< section_lines_refs_t >::iterator
        

        erase(self, first, last) -> qvector< section_lines_refs_t >::iterator
            first: qvector< section_lines_refs_t >::iterator
            last: qvector< section_lines_refs_t >::iterator
        """
        return _ida_kernwin.sections_lines_refs_t_erase(self, *args)

    def find(self, *args) -> "qvector< section_lines_refs_t >::const_iterator":
        r"""


        find(self, x) -> qvector< section_lines_refs_t >::iterator
            x: section_lines_refs_t const &
        

        find(self, x) -> qvector< section_lines_refs_t >::const_iterator
            x: section_lines_refs_t const &
        """
        return _ida_kernwin.sections_lines_refs_t_find(self, *args)

    def has(self, *args) -> "bool":
        r"""


        has(self, x) -> bool
            x: section_lines_refs_t const &
        """
        return _ida_kernwin.sections_lines_refs_t_has(self, *args)

    def add_unique(self, *args) -> "bool":
        r"""


        add_unique(self, x) -> bool
            x: section_lines_refs_t const &
        """
        return _ida_kernwin.sections_lines_refs_t_add_unique(self, *args)

    def _del(self, *args) -> "bool":
        r"""


        _del(self, x) -> bool
            x: section_lines_refs_t const &
        """
        return _ida_kernwin.sections_lines_refs_t__del(self, *args)

    def __len__(self, *args) -> "size_t":
        r"""
        __len__(self) -> size_t
        """
        return _ida_kernwin.sections_lines_refs_t___len__(self, *args)

    def __getitem__(self, *args) -> "section_lines_refs_t const &":
        r"""


        __getitem__(self, i) -> section_lines_refs_t
            i: size_t
        """
        return _ida_kernwin.sections_lines_refs_t___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        r"""


        __setitem__(self, i, v)
            i: size_t
            v: section_lines_refs_t const &
        """
        return _ida_kernwin.sections_lines_refs_t___setitem__(self, *args)

    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator


# Register sections_lines_refs_t in _ida_kernwin:
_ida_kernwin.sections_lines_refs_t_swigregister(sections_lines_refs_t)

class text_t(object):
    r"""
    Proxy of C++ qvector< twinline_t > class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        __init__(self) -> text_t
            x: qvector< twinline_t > const &
        """
        _ida_kernwin.text_t_swiginit(self, _ida_kernwin.new_text_t(*args))
    __swig_destroy__ = _ida_kernwin.delete_text_t

    def push_back(self, *args) -> "twinline_t &":
        r"""


        push_back(self, x)
            x: twinline_t const &
        """
        return _ida_kernwin.text_t_push_back(self, *args)

    def pop_back(self, *args) -> "void":
        r"""
        pop_back(self)
        """
        return _ida_kernwin.text_t_pop_back(self, *args)

    def size(self, *args) -> "size_t":
        r"""
        size(self) -> size_t
        """
        return _ida_kernwin.text_t_size(self, *args)

    def empty(self, *args) -> "bool":
        r"""
        empty(self) -> bool
        """
        return _ida_kernwin.text_t_empty(self, *args)

    def at(self, *args) -> "twinline_t const &":
        r"""


        at(self, _idx) -> twinline_t
            _idx: size_t
        """
        return _ida_kernwin.text_t_at(self, *args)

    def qclear(self, *args) -> "void":
        r"""
        qclear(self)
        """
        return _ida_kernwin.text_t_qclear(self, *args)

    def clear(self, *args) -> "void":
        r"""
        clear(self)
        """
        return _ida_kernwin.text_t_clear(self, *args)

    def resize(self, *args) -> "void":
        r"""


        resize(self, _newsize, x)
            _newsize: size_t
            x: twinline_t const &
        

        resize(self, _newsize)
            _newsize: size_t
        """
        return _ida_kernwin.text_t_resize(self, *args)

    def grow(self, *args) -> "void":
        r"""


        grow(self, x=twinline_t())
            x: twinline_t const &
        """
        return _ida_kernwin.text_t_grow(self, *args)

    def capacity(self, *args) -> "size_t":
        r"""
        capacity(self) -> size_t
        """
        return _ida_kernwin.text_t_capacity(self, *args)

    def reserve(self, *args) -> "void":
        r"""


        reserve(self, cnt)
            cnt: size_t
        """
        return _ida_kernwin.text_t_reserve(self, *args)

    def truncate(self, *args) -> "void":
        r"""
        truncate(self)
        """
        return _ida_kernwin.text_t_truncate(self, *args)

    def swap(self, *args) -> "void":
        r"""


        swap(self, r)
            r: qvector< twinline_t > &
        """
        return _ida_kernwin.text_t_swap(self, *args)

    def extract(self, *args) -> "twinline_t *":
        r"""
        extract(self) -> twinline_t
        """
        return _ida_kernwin.text_t_extract(self, *args)

    def inject(self, *args) -> "void":
        r"""


        inject(self, s, len)
            s: twinline_t *
            len: size_t
        """
        return _ida_kernwin.text_t_inject(self, *args)

    def begin(self, *args) -> "qvector< twinline_t >::const_iterator":
        r"""
        begin(self) -> twinline_t
        begin(self) -> twinline_t
        """
        return _ida_kernwin.text_t_begin(self, *args)

    def end(self, *args) -> "qvector< twinline_t >::const_iterator":
        r"""
        end(self) -> twinline_t
        end(self) -> twinline_t
        """
        return _ida_kernwin.text_t_end(self, *args)

    def insert(self, *args) -> "qvector< twinline_t >::iterator":
        r"""


        insert(self, it, x) -> twinline_t
            it: qvector< twinline_t >::iterator
            x: twinline_t const &
        """
        return _ida_kernwin.text_t_insert(self, *args)

    def erase(self, *args) -> "qvector< twinline_t >::iterator":
        r"""


        erase(self, it) -> twinline_t
            it: qvector< twinline_t >::iterator
        

        erase(self, first, last) -> twinline_t
            first: qvector< twinline_t >::iterator
            last: qvector< twinline_t >::iterator
        """
        return _ida_kernwin.text_t_erase(self, *args)

    def __len__(self, *args) -> "size_t":
        r"""
        __len__(self) -> size_t
        """
        return _ida_kernwin.text_t___len__(self, *args)

    def __getitem__(self, *args) -> "twinline_t const &":
        r"""


        __getitem__(self, i) -> twinline_t
            i: size_t
        """
        return _ida_kernwin.text_t___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        r"""


        __setitem__(self, i, v)
            i: size_t
            v: twinline_t const &
        """
        return _ida_kernwin.text_t___setitem__(self, *args)

    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator


# Register text_t in _ida_kernwin:
_ida_kernwin.text_t_swigregister(text_t)

class sync_source_vec_t(object):
    r"""
    Proxy of C++ qvector< sync_source_t > class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        __init__(self) -> sync_source_vec_t
            x: qvector< sync_source_t > const &
        """
        _ida_kernwin.sync_source_vec_t_swiginit(self, _ida_kernwin.new_sync_source_vec_t(*args))
    __swig_destroy__ = _ida_kernwin.delete_sync_source_vec_t

    def push_back(self, *args) -> "void":
        r"""


        push_back(self, x)
            x: sync_source_t const &
        """
        return _ida_kernwin.sync_source_vec_t_push_back(self, *args)

    def pop_back(self, *args) -> "void":
        r"""
        pop_back(self)
        """
        return _ida_kernwin.sync_source_vec_t_pop_back(self, *args)

    def size(self, *args) -> "size_t":
        r"""
        size(self) -> size_t
        """
        return _ida_kernwin.sync_source_vec_t_size(self, *args)

    def empty(self, *args) -> "bool":
        r"""
        empty(self) -> bool
        """
        return _ida_kernwin.sync_source_vec_t_empty(self, *args)

    def at(self, *args) -> "sync_source_t const &":
        r"""


        at(self, _idx) -> sync_source_t
            _idx: size_t
        """
        return _ida_kernwin.sync_source_vec_t_at(self, *args)

    def qclear(self, *args) -> "void":
        r"""
        qclear(self)
        """
        return _ida_kernwin.sync_source_vec_t_qclear(self, *args)

    def clear(self, *args) -> "void":
        r"""
        clear(self)
        """
        return _ida_kernwin.sync_source_vec_t_clear(self, *args)

    def capacity(self, *args) -> "size_t":
        r"""
        capacity(self) -> size_t
        """
        return _ida_kernwin.sync_source_vec_t_capacity(self, *args)

    def reserve(self, *args) -> "void":
        r"""


        reserve(self, cnt)
            cnt: size_t
        """
        return _ida_kernwin.sync_source_vec_t_reserve(self, *args)

    def truncate(self, *args) -> "void":
        r"""
        truncate(self)
        """
        return _ida_kernwin.sync_source_vec_t_truncate(self, *args)

    def swap(self, *args) -> "void":
        r"""


        swap(self, r)
            r: qvector< sync_source_t > &
        """
        return _ida_kernwin.sync_source_vec_t_swap(self, *args)

    def extract(self, *args) -> "sync_source_t *":
        r"""
        extract(self) -> sync_source_t
        """
        return _ida_kernwin.sync_source_vec_t_extract(self, *args)

    def inject(self, *args) -> "void":
        r"""


        inject(self, s, len)
            s: sync_source_t *
            len: size_t
        """
        return _ida_kernwin.sync_source_vec_t_inject(self, *args)

    def __eq__(self, *args) -> "bool":
        r"""


        __eq__(self, r) -> bool
            r: qvector< sync_source_t > const &
        """
        return _ida_kernwin.sync_source_vec_t___eq__(self, *args)

    def __ne__(self, *args) -> "bool":
        r"""


        __ne__(self, r) -> bool
            r: qvector< sync_source_t > const &
        """
        return _ida_kernwin.sync_source_vec_t___ne__(self, *args)

    def begin(self, *args) -> "qvector< sync_source_t >::const_iterator":
        r"""
        begin(self) -> sync_source_t
        begin(self) -> sync_source_t
        """
        return _ida_kernwin.sync_source_vec_t_begin(self, *args)

    def end(self, *args) -> "qvector< sync_source_t >::const_iterator":
        r"""
        end(self) -> sync_source_t
        end(self) -> sync_source_t
        """
        return _ida_kernwin.sync_source_vec_t_end(self, *args)

    def insert(self, *args) -> "qvector< sync_source_t >::iterator":
        r"""


        insert(self, it, x) -> sync_source_t
            it: qvector< sync_source_t >::iterator
            x: sync_source_t const &
        """
        return _ida_kernwin.sync_source_vec_t_insert(self, *args)

    def erase(self, *args) -> "qvector< sync_source_t >::iterator":
        r"""


        erase(self, it) -> sync_source_t
            it: qvector< sync_source_t >::iterator
        

        erase(self, first, last) -> sync_source_t
            first: qvector< sync_source_t >::iterator
            last: qvector< sync_source_t >::iterator
        """
        return _ida_kernwin.sync_source_vec_t_erase(self, *args)

    def find(self, *args) -> "qvector< sync_source_t >::const_iterator":
        r"""


        find(self, x) -> sync_source_t
            x: sync_source_t const &
        

        find(self, x) -> sync_source_t
            x: sync_source_t const &
        """
        return _ida_kernwin.sync_source_vec_t_find(self, *args)

    def has(self, *args) -> "bool":
        r"""


        has(self, x) -> bool
            x: sync_source_t const &
        """
        return _ida_kernwin.sync_source_vec_t_has(self, *args)

    def add_unique(self, *args) -> "bool":
        r"""


        add_unique(self, x) -> bool
            x: sync_source_t const &
        """
        return _ida_kernwin.sync_source_vec_t_add_unique(self, *args)

    def _del(self, *args) -> "bool":
        r"""


        _del(self, x) -> bool
            x: sync_source_t const &
        """
        return _ida_kernwin.sync_source_vec_t__del(self, *args)

    def __len__(self, *args) -> "size_t":
        r"""
        __len__(self) -> size_t
        """
        return _ida_kernwin.sync_source_vec_t___len__(self, *args)

    def __getitem__(self, *args) -> "sync_source_t const &":
        r"""


        __getitem__(self, i) -> sync_source_t
            i: size_t
        """
        return _ida_kernwin.sync_source_vec_t___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        r"""


        __setitem__(self, i, v)
            i: size_t
            v: sync_source_t const &
        """
        return _ida_kernwin.sync_source_vec_t___setitem__(self, *args)

    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator


# Register sync_source_vec_t in _ida_kernwin:
_ida_kernwin.sync_source_vec_t_swigregister(sync_source_vec_t)

mbox_internal = _ida_kernwin.mbox_internal

mbox_info = _ida_kernwin.mbox_info

mbox_warning = _ida_kernwin.mbox_warning

mbox_error = _ida_kernwin.mbox_error

mbox_nomem = _ida_kernwin.mbox_nomem

mbox_feedback = _ida_kernwin.mbox_feedback

mbox_readerror = _ida_kernwin.mbox_readerror

mbox_writeerror = _ida_kernwin.mbox_writeerror

mbox_filestruct = _ida_kernwin.mbox_filestruct

mbox_wait = _ida_kernwin.mbox_wait

mbox_hide = _ida_kernwin.mbox_hide

mbox_replace = _ida_kernwin.mbox_replace

chtype_generic = _ida_kernwin.chtype_generic

chtype_idasgn = _ida_kernwin.chtype_idasgn

chtype_entry = _ida_kernwin.chtype_entry

chtype_name = _ida_kernwin.chtype_name

chtype_stkvar_xref = _ida_kernwin.chtype_stkvar_xref

chtype_xref = _ida_kernwin.chtype_xref

chtype_enum = _ida_kernwin.chtype_enum

chtype_enum_by_value = _ida_kernwin.chtype_enum_by_value

chtype_func = _ida_kernwin.chtype_func

chtype_segm = _ida_kernwin.chtype_segm

chtype_struc = _ida_kernwin.chtype_struc

chtype_strpath = _ida_kernwin.chtype_strpath

chtype_idatil = _ida_kernwin.chtype_idatil

chtype_enum_by_value_and_size = _ida_kernwin.chtype_enum_by_value_and_size

chtype_srcp = _ida_kernwin.chtype_srcp

beep_default = _ida_kernwin.beep_default

TCCRT_INVALID = _ida_kernwin.TCCRT_INVALID

TCCRT_FLAT = _ida_kernwin.TCCRT_FLAT

TCCRT_GRAPH = _ida_kernwin.TCCRT_GRAPH

TCCRT_PROXIMITY = _ida_kernwin.TCCRT_PROXIMITY

TCCPT_INVALID = _ida_kernwin.TCCPT_INVALID

TCCPT_PLACE = _ida_kernwin.TCCPT_PLACE

TCCPT_SIMPLELINE_PLACE = _ida_kernwin.TCCPT_SIMPLELINE_PLACE

TCCPT_IDAPLACE = _ida_kernwin.TCCPT_IDAPLACE

TCCPT_ENUMPLACE = _ida_kernwin.TCCPT_ENUMPLACE

TCCPT_STRUCTPLACE = _ida_kernwin.TCCPT_STRUCTPLACE

VME_UNKNOWN = _ida_kernwin.VME_UNKNOWN

VME_LEFT_BUTTON = _ida_kernwin.VME_LEFT_BUTTON

VME_RIGHT_BUTTON = _ida_kernwin.VME_RIGHT_BUTTON

VME_MID_BUTTON = _ida_kernwin.VME_MID_BUTTON

SETMENU_POSMASK = _ida_kernwin.SETMENU_POSMASK

SETMENU_INS = _ida_kernwin.SETMENU_INS
"""
add menu item before the specified path (default)
"""

SETMENU_APP = _ida_kernwin.SETMENU_APP
"""
add menu item after the specified path
"""

SETMENU_FIRST = _ida_kernwin.SETMENU_FIRST
"""
add item to the beginning of menu
"""

CREATETB_ADV = _ida_kernwin.CREATETB_ADV
"""
toolbar is for 'advanced mode' only
"""

HIF_IDENTIFIER = _ida_kernwin.HIF_IDENTIFIER
"""
text is an identifier (i.e., when searching for the current highlight,
SEARCH_IDENT will be used)
"""

HIF_REGISTER = _ida_kernwin.HIF_REGISTER
"""
text represents a register (aliases/subregisters will be highlit as
well)
"""

HIF_LOCKED = _ida_kernwin.HIF_LOCKED
"""
locked; clicking/moving the cursor around doesn't change the highlight
"""

HIF_NOCASE = _ida_kernwin.HIF_NOCASE
"""
case insensitive
"""

REG_HINTS_MARKER = _ida_kernwin.REG_HINTS_MARKER

REG_HINTS_MARKER_LEN = _ida_kernwin.REG_HINTS_MARKER_LEN

SRCDBG_HINTS_MARKER = _ida_kernwin.SRCDBG_HINTS_MARKER

SRCDBG_HINTS_MARKER_LEN = _ida_kernwin.SRCDBG_HINTS_MARKER_LEN


def get_kernel_version(*args) -> "size_t":
    r"""


    Get IDA kernel version (in a string like "5.1").
    """
    return _ida_kernwin.get_kernel_version(*args)
class place_t(object):
    r"""
    Proxy of C++ place_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    lnnum = property(_ida_kernwin.place_t_lnnum_get, _ida_kernwin.place_t_lnnum_set)

    def _print(self, *args) -> "void":
        r"""


        _print(self, out_buf, ud)
            out_buf: qstring *
            ud: void *
        """
        return _ida_kernwin.place_t__print(self, *args)

    def touval(self, *args) -> "uval_t":
        r"""


        Map the location to a number. This mapping is used to draw the
        vertical scrollbar.
        
        touval(self, ud) -> uval_t
            @param ud: pointer to user-defined context data. Is supplied by
                       linearray_t (C++: void *)
        """
        return _ida_kernwin.place_t_touval(self, *args)

    def clone(self, *args) -> "place_t *":
        r"""


        Clone the location.
        """
        return _ida_kernwin.place_t_clone(self, *args)

    def copyfrom(self, *args) -> "void":
        r"""


        Copy the specified location object to the current object.
        
        copyfrom(self, _from)
            @param _from (C++: const  place_t  *)
        """
        return _ida_kernwin.place_t_copyfrom(self, *args)

    def makeplace(self, *args) -> "place_t *":
        r"""


        Map a number to a location. When the user clicks on the scrollbar and
        drags it, we need to determine the location corresponding to the new
        scrollbar position. This function is used to determine it. It builds a
        location object for the specified 'x' and returns a pointer to it.
        
        makeplace(self, ud, x, lnnum) -> place_t
            @param ud: pointer to user-defined context data. Is supplied by
                       linearray_t (C++: void *)
            @param x: number to map (C++: uval_t)
            @param lnnum: line number to initialize 'lnnum' (C++: int)
            @return: a freshly allocated object. See also PCF_MAKEPLACE_ALLOCATES
        """
        return _ida_kernwin.place_t_makeplace(self, *args)

    def compare(self, *args) -> "int":
        r"""


        Deprecated. Please consider compare2(const place_t *, void *) instead.
        
        compare(self, t2) -> int
            @param t2 (C++: const  place_t  *)
        """
        return _ida_kernwin.place_t_compare(self, *args)

    def adjust(self, *args) -> "void":
        r"""


        Adjust the current location to point to a displayable object. This
        function validates the location and makes sure that it points to an
        existing object. For example, if the location points to the middle of
        an instruction, it will be adjusted to point to the beginning of the
        instruction.
        
        adjust(self, ud)
            @param ud: pointer to user-defined context data. Is supplied by
                       linearray_t (C++: void *)
        """
        return _ida_kernwin.place_t_adjust(self, *args)

    def prev(self, *args) -> "bool":
        r"""


        Move to the previous displayable location.
        
        prev(self, ud) -> bool
            @param ud: pointer to user-defined context data. Is supplied by
                       linearray_t (C++: void *)
            @return: success
        """
        return _ida_kernwin.place_t_prev(self, *args)

    def next(self, *args) -> "bool":
        r"""


        Move to the next displayable location.
        
        next(self, ud) -> bool
            @param ud: pointer to user-defined context data. Is supplied by
                       linearray_t (C++: void *)
            @return: success
        """
        return _ida_kernwin.place_t_next(self, *args)

    def beginning(self, *args) -> "bool":
        r"""


        Are we at the first displayable object?.
        
        beginning(self, ud) -> bool
            @param ud: pointer to user-defined context data. Is supplied by
                       linearray_t (C++: void *)
            @return: true if the current location points to the first displayable
                     object
        """
        return _ida_kernwin.place_t_beginning(self, *args)

    def ending(self, *args) -> "bool":
        r"""


        Are we at the last displayable object?.
        
        ending(self, ud) -> bool
            @param ud: pointer to user-defined context data. Is supplied by
                       linearray_t (C++: void *)
            @return: true if the current location points to the last displayable
                     object
        """
        return _ida_kernwin.place_t_ending(self, *args)

    def serialize(self, *args) -> "void":
        r"""


        Serialize this instance. It is fundamental that all instances of a
        particular subclass of of 'place_t' occupy the same number of bytes
        when serialized.
        """
        return _ida_kernwin.place_t_serialize(self, *args)

    def id(self, *args) -> "int":
        r"""


        Get the place's ID (i.e., the value returned by
        'register_place_class()' )
        """
        return _ida_kernwin.place_t_id(self, *args)

    def name(self, *args) -> "char const *":
        r"""


        Get this place type name. All instances of a given class must return
        the same string.
        """
        return _ida_kernwin.place_t_name(self, *args)

    def toea(self, *args) -> "ea_t":
        r"""


        Map the location to an ea_t.
        """
        return _ida_kernwin.place_t_toea(self, *args)

    def rebase(self, *args) -> "bool":
        r"""


        Rebase the place instance
        
        rebase(self, arg2) -> bool
            arg2: segm_move_infos_t const &
            @return: true if place was rebased, false otherwise
        """
        return _ida_kernwin.place_t_rebase(self, *args)

    def enter(self, *args) -> "place_t *":
        r"""


        Visit this place, possibly 'unhiding' a section of text. If entering
        that place required some expanding, a 'place_t' should be returned
        that represents that section, plus some flags for later use by '
        'leave()' '.
        
        enter(self, arg2) -> place_t
            arg2: uint32 *
            @return: a  place_t  corresponding to the beginning of the section of
                     text that had to be expanded. That  place_t 's  leave()  will
                     be called with the flags contained in 'out_flags' when the
                     user navigates away from it.
        """
        return _ida_kernwin.place_t_enter(self, *args)

    def leave(self, *args) -> "void":
        r"""


        Leave this place, possibly 'hiding' a section of text that was
        previously expanded (at 'enter()' -time.)
        
        leave(self, arg2)
            arg2: uint32
        """
        return _ida_kernwin.place_t_leave(self, *args)

    def compare2(self, *args) -> "int":
        r"""


        Compare two locations except line numbers (lnnum). This function is
        used to organize loops. For example, if the user has selected an
        range, its boundaries are remembered as location objects. Any
        operation within the selection will have the following look: for (
        loc=starting_location; loc < ending_location; loc.next() ) In this
        loop, the comparison function is used.
        
        compare2(self, t2, arg3) -> int
            @param t2: the place to compare this one to. (C++: const  place_t  *)
            arg3: void *
            @retval: -1 - if the current location is less than 't2'
            @retval: 0 - if the current location is equal to than 't2'
            @retval: 1 - if the current location is greater than 't2'
        """
        return _ida_kernwin.place_t_compare2(self, *args)

    def deserialize(self, *args) -> "bool":
        r"""


        De-serialize into this instance. 'pptr' should be incremented by as
        many bytes as de-serialization consumed.
        
        deserialize(self, _in) -> bool
            in: bytevec_t const &
            @return: whether de-serialization was successful
        """
        return _ida_kernwin.place_t_deserialize(self, *args)

    @staticmethod
    def as_idaplace_t(*args) -> "idaplace_t *":
        r"""


        as_idaplace_t(p) -> idaplace_t
            p: place_t *
        """
        return _ida_kernwin.place_t_as_idaplace_t(*args)

    @staticmethod
    def as_enumplace_t(*args) -> "enumplace_t *":
        r"""


        as_enumplace_t(p) -> enumplace_t
            p: place_t *
        """
        return _ida_kernwin.place_t_as_enumplace_t(*args)

    @staticmethod
    def as_structplace_t(*args) -> "structplace_t *":
        r"""


        as_structplace_t(p) -> structplace_t
            p: place_t *
        """
        return _ida_kernwin.place_t_as_structplace_t(*args)

    @staticmethod
    def as_simpleline_place_t(*args) -> "simpleline_place_t *":
        r"""


        as_simpleline_place_t(p) -> simpleline_place_t
            p: place_t *
        """
        return _ida_kernwin.place_t_as_simpleline_place_t(*args)

    def generate(self, *args) -> "PyObject *":
        r"""


        Generate text lines for the current location.
        
        generate(self, ud, maxsize) -> PyObject *
            @param ud: pointer to user-defined context data. Is supplied by
                       linearray_t (C++: void *)
            @param maxsize: the maximum number of lines to generate (C++: int)
            @return: number of generated lines
        """
        return _ida_kernwin.place_t_generate(self, *args)
    __swig_destroy__ = _ida_kernwin.delete_place_t

# Register place_t in _ida_kernwin:
_ida_kernwin.place_t_swigregister(place_t)

def place_t_as_idaplace_t(*args) -> "idaplace_t *":
    r"""


    place_t_as_idaplace_t(p) -> idaplace_t
        p: place_t *
    """
    return _ida_kernwin.place_t_as_idaplace_t(*args)

def place_t_as_enumplace_t(*args) -> "enumplace_t *":
    r"""


    place_t_as_enumplace_t(p) -> enumplace_t
        p: place_t *
    """
    return _ida_kernwin.place_t_as_enumplace_t(*args)

def place_t_as_structplace_t(*args) -> "structplace_t *":
    r"""


    place_t_as_structplace_t(p) -> structplace_t
        p: place_t *
    """
    return _ida_kernwin.place_t_as_structplace_t(*args)

def place_t_as_simpleline_place_t(*args) -> "simpleline_place_t *":
    r"""


    place_t_as_simpleline_place_t(p) -> simpleline_place_t
        p: place_t *
    """
    return _ida_kernwin.place_t_as_simpleline_place_t(*args)

DEFAULT_PLACE_LNNUM = _ida_kernwin.DEFAULT_PLACE_LNNUM

class simpleline_t(object):
    r"""
    Proxy of C++ simpleline_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    line = property(_ida_kernwin.simpleline_t_line_get, _ida_kernwin.simpleline_t_line_set)
    color = property(_ida_kernwin.simpleline_t_color_get, _ida_kernwin.simpleline_t_color_set)
    bgcolor = property(_ida_kernwin.simpleline_t_bgcolor_get, _ida_kernwin.simpleline_t_bgcolor_set)

    def __init__(self, *args):
        r"""


        __init__(self) -> simpleline_t
            c: color_t
            str: char const *
        

        __init__(self, str) -> simpleline_t
            str: char const *
        """
        _ida_kernwin.simpleline_t_swiginit(self, _ida_kernwin.new_simpleline_t(*args))
    __swig_destroy__ = _ida_kernwin.delete_simpleline_t

# Register simpleline_t in _ida_kernwin:
_ida_kernwin.simpleline_t_swigregister(simpleline_t)

class simpleline_place_t(place_t):
    r"""
    Proxy of C++ simpleline_place_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    n = property(_ida_kernwin.simpleline_place_t_n_get, _ida_kernwin.simpleline_place_t_n_set)
    __swig_destroy__ = _ida_kernwin.delete_simpleline_place_t

# Register simpleline_place_t in _ida_kernwin:
_ida_kernwin.simpleline_place_t_swigregister(simpleline_place_t)

class idaplace_t(place_t):
    r"""
    Proxy of C++ idaplace_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    ea = property(_ida_kernwin.idaplace_t_ea_get, _ida_kernwin.idaplace_t_ea_set)
    __swig_destroy__ = _ida_kernwin.delete_idaplace_t

# Register idaplace_t in _ida_kernwin:
_ida_kernwin.idaplace_t_swigregister(idaplace_t)

class enumplace_t(place_t):
    r"""
    Proxy of C++ enumplace_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    idx = property(_ida_kernwin.enumplace_t_idx_get, _ida_kernwin.enumplace_t_idx_set)
    bmask = property(_ida_kernwin.enumplace_t_bmask_get, _ida_kernwin.enumplace_t_bmask_set)
    value = property(_ida_kernwin.enumplace_t_value_get, _ida_kernwin.enumplace_t_value_set)
    serial = property(_ida_kernwin.enumplace_t_serial_get, _ida_kernwin.enumplace_t_serial_set)
    __swig_destroy__ = _ida_kernwin.delete_enumplace_t

# Register enumplace_t in _ida_kernwin:
_ida_kernwin.enumplace_t_swigregister(enumplace_t)

class structplace_t(place_t):
    r"""
    Proxy of C++ structplace_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    idx = property(_ida_kernwin.structplace_t_idx_get, _ida_kernwin.structplace_t_idx_set)
    offset = property(_ida_kernwin.structplace_t_offset_get, _ida_kernwin.structplace_t_offset_set)
    __swig_destroy__ = _ida_kernwin.delete_structplace_t

# Register structplace_t in _ida_kernwin:
_ida_kernwin.structplace_t_swigregister(structplace_t)

PCF_EA_CAPABLE = _ida_kernwin.PCF_EA_CAPABLE
"""
toea() implementation returns meaningful data
"""

PCF_MAKEPLACE_ALLOCATES = _ida_kernwin.PCF_MAKEPLACE_ALLOCATES
"""
makeplace() returns a freshly allocated (i.e., non-static) instance.
All new code should pass that flag to 'register_place_class()' , and
the corresponding makeplace() class implementation should return new
instances.
"""


def internal_register_place_class(*args) -> "int":
    r"""


    internal_register_place_class(tmplate, flags, owner, sdk_version) -> int
        @param tmplate (C++: const  place_t  *)
        @param flags (C++: int)
        @param owner (C++: const  plugin_t  *)
        @param sdk_version (C++: int)
    """
    return _ida_kernwin.internal_register_place_class(*args)

def get_place_class(*args) -> "place_t const *":
    r"""


    Get information about a previously-registered 'place_t' class. See
    also 'register_place_class()' .
    
    get_place_class(out_flags, out_sdk_version, id) -> place_t
        @param out_flags: output flags (can be NULL) (C++: int *)
        @param out_sdk_version: sdk version the place was created with (can be
                                NULL) (C++: int *)
        @param id: place class ID (C++: int)
        @return: the  place_t  template, or NULL if not found
    """
    return _ida_kernwin.get_place_class(*args)

def get_place_class_template(*args) -> "place_t const *":
    r"""


    See 'get_place_class()'
    
    get_place_class_template(id) -> place_t
        @param id (C++: int)
    """
    return _ida_kernwin.get_place_class_template(*args)

def is_place_class_ea_capable(*args) -> "bool":
    r"""


    See 'get_place_class()'
    
    is_place_class_ea_capable(id) -> bool
        @param id (C++: int)
    """
    return _ida_kernwin.is_place_class_ea_capable(*args)

def get_place_class_id(*args) -> "int":
    r"""


    Get the place class ID for the place that has been registered as
    'name'.
    
    get_place_class_id(name) -> int
        @param name: the class name (C++: const char *)
        @return: the place class ID, or -1 if not found
    """
    return _ida_kernwin.get_place_class_id(*args)
class sync_source_t(object):
    r"""
    Proxy of C++ sync_source_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        __init__(self, _view) -> sync_source_t
            _view: TWidget const *
        

        __init__(self, _regname) -> sync_source_t
            _regname: char const *
        """
        _ida_kernwin.sync_source_t_swiginit(self, _ida_kernwin.new_sync_source_t(*args))

    def __eq__(self, *args) -> "bool":
        r"""


        __eq__(self, _o) -> bool
            _o: sync_source_t const &
        """
        return _ida_kernwin.sync_source_t___eq__(self, *args)

    def __ne__(self, *args) -> "bool":
        r"""


        __ne__(self, _o) -> bool
            _o: sync_source_t const &
        """
        return _ida_kernwin.sync_source_t___ne__(self, *args)

    def is_register(self, *args) -> "bool":
        r"""
        is_register(self) -> bool
        """
        return _ida_kernwin.sync_source_t_is_register(self, *args)

    def is_widget(self, *args) -> "bool":
        r"""
        is_widget(self) -> bool
        """
        return _ida_kernwin.sync_source_t_is_widget(self, *args)

    def get_widget(self, *args) -> "TWidget const *":
        r"""
        get_widget(self) -> TWidget const *
        """
        return _ida_kernwin.sync_source_t_get_widget(self, *args)

    def get_register(self, *args) -> "char const *":
        r"""
        get_register(self) -> char const *
        """
        return _ida_kernwin.sync_source_t_get_register(self, *args)
    __swig_destroy__ = _ida_kernwin.delete_sync_source_t

# Register sync_source_t in _ida_kernwin:
_ida_kernwin.sync_source_t_swigregister(sync_source_t)

class synced_group_t(sync_source_vec_t):
    r"""
    Proxy of C++ synced_group_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def has_widget(self, *args) -> "bool":
        r"""


        has_widget(self, v) -> bool
            @param v (C++: const TWidget *)
        """
        return _ida_kernwin.synced_group_t_has_widget(self, *args)

    def has_register(self, *args) -> "bool":
        r"""


        has_register(self, r) -> bool
            @param r (C++: const char *)
        """
        return _ida_kernwin.synced_group_t_has_register(self, *args)

    def has(self, *args) -> "bool":
        r"""


        has(self, ss) -> bool
            @param ss (C++: const  sync_source_t  &)
        """
        return _ida_kernwin.synced_group_t_has(self, *args)

    def __init__(self, *args):
        r"""
        __init__(self) -> synced_group_t
        """
        _ida_kernwin.synced_group_t_swiginit(self, _ida_kernwin.new_synced_group_t(*args))
    __swig_destroy__ = _ida_kernwin.delete_synced_group_t

# Register synced_group_t in _ida_kernwin:
_ida_kernwin.synced_group_t_swigregister(synced_group_t)

LECVT_CANCELED = _ida_kernwin.LECVT_CANCELED

LECVT_ERROR = _ida_kernwin.LECVT_ERROR

LECVT_OK = _ida_kernwin.LECVT_OK

class twinpos_t(object):
    r"""
    Proxy of C++ twinpos_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    at = property(_ida_kernwin.twinpos_t_at_get, _ida_kernwin.twinpos_t_at_set)
    x = property(_ida_kernwin.twinpos_t_x_get, _ida_kernwin.twinpos_t_x_set)

    def __init__(self, *args):
        r"""


        __init__(self) -> twinpos_t
            t: place_t *
        

        __init__(self, t, x0) -> twinpos_t
            t: place_t *
            x0: int
        """
        _ida_kernwin.twinpos_t_swiginit(self, _ida_kernwin.new_twinpos_t(*args))

    def place_as_idaplace_t(self):
        return place_t.as_idaplace_t(self.at)
    def place_as_enumplace_t(self):
        return place_t.as_enumplace_t(self.at)
    def place_as_structplace_t(self):
        return place_t.as_structplace_t(self.at)
    def place_as_simpleline_place_t(self):
        return place_t.as_simpleline_place_t(self.at)

    def place(self, view):
        ptype = get_viewer_place_type(view)
        if ptype == TCCPT_IDAPLACE:
            return self.place_as_idaplace_t()
        elif ptype == TCCPT_ENUMPLACE:
            return self.place_as_enumplace_t()
        elif ptype == TCCPT_STRUCTPLACE:
            return self.place_as_structplace_t()
        elif ptype == TCCPT_SIMPLELINE_PLACE:
            return self.place_as_simpleline_place_t()
        else:
            return self.at

    __swig_destroy__ = _ida_kernwin.delete_twinpos_t

# Register twinpos_t in _ida_kernwin:
_ida_kernwin.twinpos_t_swigregister(twinpos_t)

class twinline_t(object):
    r"""
    Proxy of C++ twinline_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    at = property(_ida_kernwin.twinline_t_at_get, _ida_kernwin.twinline_t_at_set)
    line = property(_ida_kernwin.twinline_t_line_get, _ida_kernwin.twinline_t_line_set)
    prefix_color = property(_ida_kernwin.twinline_t_prefix_color_get, _ida_kernwin.twinline_t_prefix_color_set)
    bg_color = property(_ida_kernwin.twinline_t_bg_color_get, _ida_kernwin.twinline_t_bg_color_set)
    is_default = property(_ida_kernwin.twinline_t_is_default_get, _ida_kernwin.twinline_t_is_default_set)

    def __init__(self, *args):
        r"""


        __init__(self) -> twinline_t
            t: place_t *
            pc: color_t
            bc: bgcolor_t
        """
        _ida_kernwin.twinline_t_swiginit(self, _ida_kernwin.new_twinline_t(*args))
    __swig_destroy__ = _ida_kernwin.delete_twinline_t

# Register twinline_t in _ida_kernwin:
_ida_kernwin.twinline_t_swigregister(twinline_t)

class lines_rendering_input_t(object):
    r"""
    Proxy of C++ lines_rendering_input_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    cb = property(_ida_kernwin.lines_rendering_input_t_cb_get, _ida_kernwin.lines_rendering_input_t_cb_set)
    sections_lines = property(_ida_kernwin.lines_rendering_input_t_sections_lines_get, _ida_kernwin.lines_rendering_input_t_sections_lines_set)
    sync_group = property(_ida_kernwin.lines_rendering_input_t_sync_group_get, _ida_kernwin.lines_rendering_input_t_sync_group_set)

    def __init__(self, *args):
        r"""
        __init__(self) -> lines_rendering_input_t
        """
        _ida_kernwin.lines_rendering_input_t_swiginit(self, _ida_kernwin.new_lines_rendering_input_t(*args))
    __swig_destroy__ = _ida_kernwin.delete_lines_rendering_input_t

# Register lines_rendering_input_t in _ida_kernwin:
_ida_kernwin.lines_rendering_input_t_swigregister(lines_rendering_input_t)

CK_TRACE = _ida_kernwin.CK_TRACE
"""
traced address
"""

CK_TRACE_OVL = _ida_kernwin.CK_TRACE_OVL
"""
overlay trace address
"""

CK_EXTRA1 = _ida_kernwin.CK_EXTRA1
"""
extra background overlay #1
"""

CK_EXTRA2 = _ida_kernwin.CK_EXTRA2
"""
extra background overlay #2
"""

CK_EXTRA3 = _ida_kernwin.CK_EXTRA3
"""
extra background overlay #3
"""

CK_EXTRA4 = _ida_kernwin.CK_EXTRA4
"""
extra background overlay #4
"""

CK_EXTRA5 = _ida_kernwin.CK_EXTRA5
"""
extra background overlay #5
"""

CK_EXTRA6 = _ida_kernwin.CK_EXTRA6
"""
extra background overlay #6
"""

CK_EXTRA7 = _ida_kernwin.CK_EXTRA7
"""
extra background overlay #7
"""

CK_EXTRA8 = _ida_kernwin.CK_EXTRA8
"""
extra background overlay #8
"""

CK_EXTRA9 = _ida_kernwin.CK_EXTRA9
"""
extra background overlay #9
"""

CK_EXTRA10 = _ida_kernwin.CK_EXTRA10
"""
extra background overlay #10
"""

CK_EXTRA11 = _ida_kernwin.CK_EXTRA11
"""
extra background overlay #11
"""

CK_EXTRA12 = _ida_kernwin.CK_EXTRA12
"""
extra background overlay #12
"""

CK_EXTRA13 = _ida_kernwin.CK_EXTRA13
"""
extra background overlay #13
"""

CK_EXTRA14 = _ida_kernwin.CK_EXTRA14
"""
extra background overlay #14
"""

CK_EXTRA15 = _ida_kernwin.CK_EXTRA15
"""
extra background overlay #15
"""

CK_EXTRA16 = _ida_kernwin.CK_EXTRA16
"""
extra background overlay #16
"""

LROEF_MASK = _ida_kernwin.LROEF_MASK

LROEF_FULL_LINE = _ida_kernwin.LROEF_FULL_LINE
"""
full line background
"""

LROEF_CPS_RANGE = _ida_kernwin.LROEF_CPS_RANGE
"""
background for range of chars
"""

class line_rendering_output_entry_t(object):
    r"""
    Proxy of C++ line_rendering_output_entry_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    line = property(_ida_kernwin.line_rendering_output_entry_t_line_get, _ida_kernwin.line_rendering_output_entry_t_line_set)
    flags = property(_ida_kernwin.line_rendering_output_entry_t_flags_get, _ida_kernwin.line_rendering_output_entry_t_flags_set)
    bg_color = property(_ida_kernwin.line_rendering_output_entry_t_bg_color_get, _ida_kernwin.line_rendering_output_entry_t_bg_color_set)
    cpx = property(_ida_kernwin.line_rendering_output_entry_t_cpx_get, _ida_kernwin.line_rendering_output_entry_t_cpx_set)
    nchars = property(_ida_kernwin.line_rendering_output_entry_t_nchars_get, _ida_kernwin.line_rendering_output_entry_t_nchars_set)

    def __init__(self, *args):
        r"""


        __init__(self, _line, _flags=0, _bg_color=0) -> line_rendering_output_entry_t
            _line: twinline_t const *
            _flags: uint32
            _bg_color: bgcolor_t
        

        __init__(self, _line, _cpx, _nchars, _flags, _bg_color) -> line_rendering_output_entry_t
            _line: twinline_t const *
            _cpx: int
            _nchars: int
            _flags: uint32
            _bg_color: bgcolor_t
        """
        _ida_kernwin.line_rendering_output_entry_t_swiginit(self, _ida_kernwin.new_line_rendering_output_entry_t(*args))

    def is_bg_color_empty(self, *args) -> "bool":
        r"""
        is_bg_color_empty(self) -> bool
        """
        return _ida_kernwin.line_rendering_output_entry_t_is_bg_color_empty(self, *args)

    def is_bg_color_key(self, *args) -> "bool":
        r"""
        is_bg_color_key(self) -> bool
        """
        return _ida_kernwin.line_rendering_output_entry_t_is_bg_color_key(self, *args)

    def is_bg_color_direct(self, *args) -> "bool":
        r"""
        is_bg_color_direct(self) -> bool
        """
        return _ida_kernwin.line_rendering_output_entry_t_is_bg_color_direct(self, *args)

    def __eq__(self, *args) -> "bool":
        r"""


        __eq__(self, r) -> bool
            r: line_rendering_output_entry_t const &
        """
        return _ida_kernwin.line_rendering_output_entry_t___eq__(self, *args)

    def __ne__(self, *args) -> "bool":
        r"""


        __ne__(self, r) -> bool
            r: line_rendering_output_entry_t const &
        """
        return _ida_kernwin.line_rendering_output_entry_t___ne__(self, *args)
    __swig_destroy__ = _ida_kernwin.delete_line_rendering_output_entry_t

# Register line_rendering_output_entry_t in _ida_kernwin:
_ida_kernwin.line_rendering_output_entry_t_swigregister(line_rendering_output_entry_t)

class lines_rendering_output_t(object):
    r"""
    Proxy of C++ lines_rendering_output_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    entries = property(_ida_kernwin.lines_rendering_output_t_entries_get, _ida_kernwin.lines_rendering_output_t_entries_set)
    flags = property(_ida_kernwin.lines_rendering_output_t_flags_get, _ida_kernwin.lines_rendering_output_t_flags_set)

    def __init__(self, *args):
        r"""
        __init__(self) -> lines_rendering_output_t
        """
        _ida_kernwin.lines_rendering_output_t_swiginit(self, _ida_kernwin.new_lines_rendering_output_t(*args))
    __swig_destroy__ = _ida_kernwin.delete_lines_rendering_output_t

    def clear(self, *args) -> "void":
        r"""
        clear(self)
        """
        return _ida_kernwin.lines_rendering_output_t_clear(self, *args)

    def __eq__(self, *args) -> "bool":
        r"""


        __eq__(self, r) -> bool
            r: lines_rendering_output_t const &
        """
        return _ida_kernwin.lines_rendering_output_t___eq__(self, *args)

    def __ne__(self, *args) -> "bool":
        r"""


        __ne__(self, r) -> bool
            r: lines_rendering_output_t const &
        """
        return _ida_kernwin.lines_rendering_output_t___ne__(self, *args)

    def swap(self, *args) -> "void":
        r"""


        swap(self, r)
            @param r (C++: lines_rendering_output_t  &)
        """
        return _ida_kernwin.lines_rendering_output_t_swap(self, *args)

# Register lines_rendering_output_t in _ida_kernwin:
_ida_kernwin.lines_rendering_output_t_swigregister(lines_rendering_output_t)


def request_refresh(*args) -> "void":
    r"""


    Request a refresh of a builtin window.
    
    request_refresh(mask, cnd=True)
        @param mask: Window refresh flags (C++: uint64)
        @param cnd: set if true or clear flag otherwise (C++: bool)
    """
    return _ida_kernwin.request_refresh(*args)

def clear_refresh_request(*args) -> "void":
    r"""


    clear_refresh_request(mask)
        @param mask (C++: uint64)
    """
    return _ida_kernwin.clear_refresh_request(*args)

def is_refresh_requested(*args) -> "bool":
    r"""


    Get a refresh request state
    
    is_refresh_requested(mask) -> bool
        @param mask: Window refresh flags (C++: uint64)
        @return: the state (set or cleared)
    """
    return _ida_kernwin.is_refresh_requested(*args)
BWN_UNKNOWN = _ida_kernwin.BWN_UNKNOWN
"""
unknown window
"""

BWN_EXPORTS = _ida_kernwin.BWN_EXPORTS
"""
exports
"""

BWN_IMPORTS = _ida_kernwin.BWN_IMPORTS
"""
imports
"""

BWN_NAMES = _ida_kernwin.BWN_NAMES
"""
names
"""

BWN_FUNCS = _ida_kernwin.BWN_FUNCS
"""
functions
"""

BWN_STRINGS = _ida_kernwin.BWN_STRINGS
"""
strings
"""

BWN_SEGS = _ida_kernwin.BWN_SEGS
"""
segments
"""

BWN_SEGREGS = _ida_kernwin.BWN_SEGREGS
"""
segment registers
"""

BWN_SELS = _ida_kernwin.BWN_SELS
"""
selectors
"""

BWN_SIGNS = _ida_kernwin.BWN_SIGNS
"""
signatures
"""

BWN_TILS = _ida_kernwin.BWN_TILS
"""
type libraries
"""

BWN_LOCTYPS = _ida_kernwin.BWN_LOCTYPS
"""
local types
"""

BWN_CALLS = _ida_kernwin.BWN_CALLS
"""
function calls
"""

BWN_PROBS = _ida_kernwin.BWN_PROBS
"""
problems
"""

BWN_BPTS = _ida_kernwin.BWN_BPTS
"""
breakpoints
"""

BWN_THREADS = _ida_kernwin.BWN_THREADS
"""
threads
"""

BWN_MODULES = _ida_kernwin.BWN_MODULES
"""
modules
"""

BWN_TRACE = _ida_kernwin.BWN_TRACE
"""
trace view
"""

BWN_CALL_STACK = _ida_kernwin.BWN_CALL_STACK
"""
call stack
"""

BWN_XREFS = _ida_kernwin.BWN_XREFS
"""
xrefs
"""

BWN_SEARCH = _ida_kernwin.BWN_SEARCH
"""
search results
"""

BWN_FRAME = _ida_kernwin.BWN_FRAME
"""
function frame
"""

BWN_NAVBAND = _ida_kernwin.BWN_NAVBAND
"""
navigation band
"""

BWN_ENUMS = _ida_kernwin.BWN_ENUMS
"""
enumerations
"""

BWN_STRUCTS = _ida_kernwin.BWN_STRUCTS
"""
structures
"""

BWN_DISASM = _ida_kernwin.BWN_DISASM
"""
disassembly views
"""

BWN_DUMP = _ida_kernwin.BWN_DUMP
"""
hex dumps
"""

BWN_NOTEPAD = _ida_kernwin.BWN_NOTEPAD
"""
notepad
"""

BWN_OUTPUT = _ida_kernwin.BWN_OUTPUT
"""
the text area, in the output window
"""

BWN_CLI = _ida_kernwin.BWN_CLI
"""
the command-line, in the output window
"""

BWN_WATCH = _ida_kernwin.BWN_WATCH
"""
the 'watches' debugger window
"""

BWN_LOCALS = _ida_kernwin.BWN_LOCALS
"""
the 'locals' debugger window
"""

BWN_STKVIEW = _ida_kernwin.BWN_STKVIEW
"""
the 'Stack view' debugger window
"""

BWN_CHOOSER = _ida_kernwin.BWN_CHOOSER
"""
a non-builtin chooser
"""

BWN_SHORTCUTCSR = _ida_kernwin.BWN_SHORTCUTCSR
"""
the shortcuts chooser (Qt version only)
"""

BWN_SHORTCUTWIN = _ida_kernwin.BWN_SHORTCUTWIN
"""
the shortcuts window (Qt version only)
"""

BWN_CPUREGS = _ida_kernwin.BWN_CPUREGS
"""
one of the 'General registers', 'FPU register', ... debugger windows
"""

BWN_SO_STRUCTS = _ida_kernwin.BWN_SO_STRUCTS
"""
the 'Structure offsets' dialog's 'Structures and Unions' panel
"""

BWN_SO_OFFSETS = _ida_kernwin.BWN_SO_OFFSETS
"""
the 'Structure offsets' dialog's offset panel
"""

BWN_CMDPALCSR = _ida_kernwin.BWN_CMDPALCSR
"""
the command palette chooser (Qt version only)
"""

BWN_CMDPALWIN = _ida_kernwin.BWN_CMDPALWIN
"""
the command palette window (Qt version only)
"""

BWN_SNIPPETS = _ida_kernwin.BWN_SNIPPETS
"""
the 'Execute script' window
"""

BWN_CUSTVIEW = _ida_kernwin.BWN_CUSTVIEW
"""
custom viewers
"""

BWN_ADDRWATCH = _ida_kernwin.BWN_ADDRWATCH
"""
the 'Watch List' window
"""

BWN_PSEUDOCODE = _ida_kernwin.BWN_PSEUDOCODE
"""
hexrays decompiler views
"""

BWN_CALLS_CALLERS = _ida_kernwin.BWN_CALLS_CALLERS
"""
function calls, callers
"""

BWN_CALLS_CALLEES = _ida_kernwin.BWN_CALLS_CALLEES
"""
function calls, callees
"""

BWN_MDVIEWCSR = _ida_kernwin.BWN_MDVIEWCSR
"""
lumina metadata view chooser
"""

BWN_DISASM_ARROWS = _ida_kernwin.BWN_DISASM_ARROWS
"""
disassembly arrows widget
"""

BWN_CV_LINE_INFOS = _ida_kernwin.BWN_CV_LINE_INFOS
"""
custom viewers' lineinfo widget
"""

BWN_SRCPTHMAP_CSR = _ida_kernwin.BWN_SRCPTHMAP_CSR
"""
"Source paths..."'s path mappings chooser
"""

BWN_SRCPTHUND_CSR = _ida_kernwin.BWN_SRCPTHUND_CSR
"""
"Source paths..."'s undesired paths chooser
"""

BWN_UNDOHIST = _ida_kernwin.BWN_UNDOHIST
"""
Undo history.
"""

BWN_SNIPPETS_CSR = _ida_kernwin.BWN_SNIPPETS_CSR
"""
the list of snippets in the 'Execute script' window
"""

BWN_SCRIPTS_CSR = _ida_kernwin.BWN_SCRIPTS_CSR
"""
the "Recent scripts" chooser
"""

BWN_STACK = _ida_kernwin.BWN_STACK
"""
Alias. Some BWN_* were confusing, and thus have been renamed. This is
to ensure bw-compat.
"""

BWN_DISASMS = _ida_kernwin.BWN_DISASMS
"""
Alias. Some BWN_* were confusing, and thus have been renamed. This is
to ensure bw-compat.
"""

BWN_DUMPS = _ida_kernwin.BWN_DUMPS
"""
Alias. Some BWN_* were confusing, and thus have been renamed. This is
to ensure bw-compat.
"""

BWN_SEARCHS = _ida_kernwin.BWN_SEARCHS
"""
Alias. Some BWN_* were confusing, and thus have been renamed. This is
to ensure bw-compat.
"""

IWID_EXPORTS = _ida_kernwin.IWID_EXPORTS
"""
exports (0)
"""

IWID_IMPORTS = _ida_kernwin.IWID_IMPORTS
"""
imports (1)
"""

IWID_NAMES = _ida_kernwin.IWID_NAMES
"""
names (2)
"""

IWID_FUNCS = _ida_kernwin.IWID_FUNCS
"""
functions (3)
"""

IWID_STRINGS = _ida_kernwin.IWID_STRINGS
"""
strings (4)
"""

IWID_SEGS = _ida_kernwin.IWID_SEGS
"""
segments (5)
"""

IWID_SEGREGS = _ida_kernwin.IWID_SEGREGS
"""
segment registers (6)
"""

IWID_SELS = _ida_kernwin.IWID_SELS
"""
selectors (7)
"""

IWID_SIGNS = _ida_kernwin.IWID_SIGNS
"""
signatures (8)
"""

IWID_TILS = _ida_kernwin.IWID_TILS
"""
type libraries (9)
"""

IWID_LOCTYPS = _ida_kernwin.IWID_LOCTYPS
"""
local types (10)
"""

IWID_CALLS = _ida_kernwin.IWID_CALLS
"""
function calls (11)
"""

IWID_PROBS = _ida_kernwin.IWID_PROBS
"""
problems (12)
"""

IWID_BPTS = _ida_kernwin.IWID_BPTS
"""
breakpoints (13)
"""

IWID_THREADS = _ida_kernwin.IWID_THREADS
"""
threads (14)
"""

IWID_MODULES = _ida_kernwin.IWID_MODULES
"""
modules (15)
"""

IWID_TRACE = _ida_kernwin.IWID_TRACE
"""
trace view (16)
"""

IWID_CALL_STACK = _ida_kernwin.IWID_CALL_STACK
"""
call stack (17)
"""

IWID_XREFS = _ida_kernwin.IWID_XREFS
"""
xrefs (18)
"""

IWID_SEARCH = _ida_kernwin.IWID_SEARCH
"""
search results (19)
"""

IWID_FRAME = _ida_kernwin.IWID_FRAME
"""
function frame (25)
"""

IWID_NAVBAND = _ida_kernwin.IWID_NAVBAND
"""
navigation band (26)
"""

IWID_ENUMS = _ida_kernwin.IWID_ENUMS
"""
enumerations (27)
"""

IWID_STRUCTS = _ida_kernwin.IWID_STRUCTS
"""
structures (28)
"""

IWID_DISASM = _ida_kernwin.IWID_DISASM
"""
disassembly views (29)
"""

IWID_DUMP = _ida_kernwin.IWID_DUMP
"""
hex dumps (30)
"""

IWID_NOTEPAD = _ida_kernwin.IWID_NOTEPAD
"""
notepad (31)
"""

IWID_OUTPUT = _ida_kernwin.IWID_OUTPUT
"""
output (32)
"""

IWID_CLI = _ida_kernwin.IWID_CLI
"""
input line (33)
"""

IWID_WATCH = _ida_kernwin.IWID_WATCH
"""
watches (34)
"""

IWID_LOCALS = _ida_kernwin.IWID_LOCALS
"""
locals (35)
"""

IWID_STKVIEW = _ida_kernwin.IWID_STKVIEW
"""
stack view (36)
"""

IWID_CHOOSER = _ida_kernwin.IWID_CHOOSER
"""
chooser (37)
"""

IWID_SHORTCUTCSR = _ida_kernwin.IWID_SHORTCUTCSR
"""
shortcuts chooser (38)
"""

IWID_SHORTCUTWIN = _ida_kernwin.IWID_SHORTCUTWIN
"""
shortcuts window (39)
"""

IWID_CPUREGS = _ida_kernwin.IWID_CPUREGS
"""
registers (40)
"""

IWID_SO_STRUCTS = _ida_kernwin.IWID_SO_STRUCTS
"""
stroff (41)
"""

IWID_SO_OFFSETS = _ida_kernwin.IWID_SO_OFFSETS
"""
stroff (42)
"""

IWID_CMDPALCSR = _ida_kernwin.IWID_CMDPALCSR
"""
command palette (43)
"""

IWID_CMDPALWIN = _ida_kernwin.IWID_CMDPALWIN
"""
command palette (44)
"""

IWID_SNIPPETS = _ida_kernwin.IWID_SNIPPETS
"""
snippets (45)
"""

IWID_CUSTVIEW = _ida_kernwin.IWID_CUSTVIEW
"""
custom viewers (46)
"""

IWID_ADDRWATCH = _ida_kernwin.IWID_ADDRWATCH
"""
address watches (47)
"""

IWID_PSEUDOCODE = _ida_kernwin.IWID_PSEUDOCODE
"""
decompiler (48)
"""

IWID_CALLS_CALLERS = _ida_kernwin.IWID_CALLS_CALLERS
"""
funcalls, callers (49)
"""

IWID_CALLS_CALLEES = _ida_kernwin.IWID_CALLS_CALLEES
"""
funcalls, callees (50)
"""

IWID_MDVIEWCSR = _ida_kernwin.IWID_MDVIEWCSR
"""
lumina md view (51)
"""

IWID_DISASM_ARROWS = _ida_kernwin.IWID_DISASM_ARROWS
"""
arrows widget (52)
"""

IWID_CV_LINE_INFOS = _ida_kernwin.IWID_CV_LINE_INFOS
"""
lineinfo widget (53)
"""

IWID_SRCPTHMAP_CSR = _ida_kernwin.IWID_SRCPTHMAP_CSR
"""
mappings chooser (54)
"""

IWID_SRCPTHUND_CSR = _ida_kernwin.IWID_SRCPTHUND_CSR
"""
undesired chooser (55)
"""

IWID_UNDOHIST = _ida_kernwin.IWID_UNDOHIST
"""
Undo history (56)
"""

IWID_SNIPPETS_CSR = _ida_kernwin.IWID_SNIPPETS_CSR
"""
snippets chooser (57)
"""

IWID_SCRIPTS_CSR = _ida_kernwin.IWID_SCRIPTS_CSR
"""
recent scripts (58)
"""

IWID_ALL = _ida_kernwin.IWID_ALL
"""
mask
"""

IWID_STACK = _ida_kernwin.IWID_STACK
"""
Alias. Some IWID_* were confusing, and thus have been renamed. This is
to ensure bw-compat.
"""

IWID_DISASMS = _ida_kernwin.IWID_DISASMS

IWID_DUMPS = _ida_kernwin.IWID_DUMPS

IWID_SEARCHS = _ida_kernwin.IWID_SEARCHS


def is_chooser_widget(*args) -> "bool":
    r"""


    Does the given widget type specify a chooser widget?
    
    is_chooser_widget(t) -> bool
        @param t (C++: twidget_type_t)
    """
    return _ida_kernwin.is_chooser_widget(*args)
CH_MODAL = _ida_kernwin.CH_MODAL
"""
Modal chooser.
"""

CH_KEEP = _ida_kernwin.CH_KEEP
"""
The chooser instance's lifecycle is not tied to the lifecycle of the
widget showing its contents. Closing the widget will not destroy the
chooser structure. This allows for, e.g., static global chooser
instances that don't need to be allocated on the heap. Also stack-
allocated chooser instances must set this bit.
"""

CH_MULTI = _ida_kernwin.CH_MULTI
"""
Obsolete.

The chooser will allow multi-selection (only for GUI choosers). This
bit is set when using the 'chooser_multi_t' structure.
"""

CH_MULTI_EDIT = _ida_kernwin.CH_MULTI_EDIT

CH_NOBTNS = _ida_kernwin.CH_NOBTNS
"""
do not display ok/cancel/help/search buttons. Meaningful only for gui
modal windows because non-modal windows do not have any buttons
anyway. Text mode does not have them neither.
"""

CH_ATTRS = _ida_kernwin.CH_ATTRS
"""
generate ui_get_chooser_item_attrs (gui only)
"""

CH_NOIDB = _ida_kernwin.CH_NOIDB
"""
use the chooser before opening the database
"""

CH_FORCE_DEFAULT = _ida_kernwin.CH_FORCE_DEFAULT
"""
if a non-modal chooser was already open, change selection to the
default one
"""

CH_CAN_INS = _ida_kernwin.CH_CAN_INS
"""
allow to insert new items
"""

CH_CAN_DEL = _ida_kernwin.CH_CAN_DEL
"""
allow to delete existing item(s)
"""

CH_CAN_EDIT = _ida_kernwin.CH_CAN_EDIT
"""
allow to edit existing item(s)
"""

CH_CAN_REFRESH = _ida_kernwin.CH_CAN_REFRESH
"""
allow to refresh chooser
"""

CH_QFLT = _ida_kernwin.CH_QFLT
"""
open with quick filter enabled and focused
"""

CH_QFTYP_SHIFT = _ida_kernwin.CH_QFTYP_SHIFT

CH_QFTYP_DEFAULT = _ida_kernwin.CH_QFTYP_DEFAULT
"""
set quick filtering type to the possible existing default for this
chooser
"""

CH_QFTYP_NORMAL = _ida_kernwin.CH_QFTYP_NORMAL
"""
normal (i.e., lexicographical) quick filter type
"""

CH_QFTYP_WHOLE_WORDS = _ida_kernwin.CH_QFTYP_WHOLE_WORDS
"""
whole words quick filter type
"""

CH_QFTYP_REGEX = _ida_kernwin.CH_QFTYP_REGEX
"""
regex quick filter type
"""

CH_QFTYP_FUZZY = _ida_kernwin.CH_QFTYP_FUZZY
"""
fuzzy search quick filter type
"""

CH_QFTYP_MASK = _ida_kernwin.CH_QFTYP_MASK

CH_NO_STATUS_BAR = _ida_kernwin.CH_NO_STATUS_BAR
"""
don't show a status bar
"""

CH_RESTORE = _ida_kernwin.CH_RESTORE
"""
restore floating position if present (equivalent of WOPN_RESTORE) (GUI
version only)
"""

CH_BUILTIN_SHIFT = _ida_kernwin.CH_BUILTIN_SHIFT

CH_BUILTIN_MASK = _ida_kernwin.CH_BUILTIN_MASK
"""
Mask for builtin chooser numbers. Plugins should not use them.
"""

CH_HAS_DIRTREE = _ida_kernwin.CH_HAS_DIRTREE
"""
The chooser can provide a 'dirtree_t' , meaning a tree-like structure
can be provided to the user (instead of a flat table)
"""

CH_TM_NO_TREE = _ida_kernwin.CH_TM_NO_TREE
"""
chooser will show up in no-tree mode
"""

CH_TM_FOLDERS_ONLY = _ida_kernwin.CH_TM_FOLDERS_ONLY
"""
chooser will show in folders-only mode
"""

CH_TM_FULL_TREE = _ida_kernwin.CH_TM_FULL_TREE
"""
chooser will show in no-tree mode
"""

CH_TM_SHIFT = _ida_kernwin.CH_TM_SHIFT

CH_TM_MASK = _ida_kernwin.CH_TM_MASK

CHCOL_PLAIN = _ida_kernwin.CHCOL_PLAIN
"""
plain string
"""

CHCOL_PATH = _ida_kernwin.CHCOL_PATH
"""
file path
"""

CHCOL_HEX = _ida_kernwin.CHCOL_HEX
"""
hexadecimal number
"""

CHCOL_DEC = _ida_kernwin.CHCOL_DEC
"""
decimal number
"""

CHCOL_EA = _ida_kernwin.CHCOL_EA
"""
address
"""

CHCOL_FNAME = _ida_kernwin.CHCOL_FNAME
"""
function name
"""

CHCOL_FORMAT = _ida_kernwin.CHCOL_FORMAT
"""
column format mask
"""

CHCOL_DEFHIDDEN = _ida_kernwin.CHCOL_DEFHIDDEN
"""
column should be hidden by default
"""

CHCOL_DRAGHINT = _ida_kernwin.CHCOL_DRAGHINT
"""
the column number that will be used to build hints for the dragging
undo label. This should be provided for at most one column for any
given chooser.
"""

CHCOL_INODENAME = _ida_kernwin.CHCOL_INODENAME
"""
if CH_HAS_DIRTREE has been specified, this instructs the chooser that
this column shows the inode name. This should be provided for at most
one column for any given chooser.
"""

CHITEM_BOLD = _ida_kernwin.CHITEM_BOLD
"""
display the item in bold
"""

CHITEM_ITALIC = _ida_kernwin.CHITEM_ITALIC
"""
display the item in italic
"""

CHITEM_UNDER = _ida_kernwin.CHITEM_UNDER
"""
underline the item
"""

CHITEM_STRIKE = _ida_kernwin.CHITEM_STRIKE
"""
strikeout the item
"""

CHITEM_GRAY = _ida_kernwin.CHITEM_GRAY
"""
gray out the item
"""

CHOOSER_NOMAINMENU = _ida_kernwin.CHOOSER_NOMAINMENU

CHOOSER_NOSTATUSBAR = _ida_kernwin.CHOOSER_NOSTATUSBAR

class chooser_item_attrs_t(object):
    r"""
    Proxy of C++ chooser_item_attrs_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    flags = property(_ida_kernwin.chooser_item_attrs_t_flags_get, _ida_kernwin.chooser_item_attrs_t_flags_set)
    color = property(_ida_kernwin.chooser_item_attrs_t_color_get, _ida_kernwin.chooser_item_attrs_t_color_set)

    def __init__(self, *args):
        r"""
        __init__(self) -> chooser_item_attrs_t
        """
        _ida_kernwin.chooser_item_attrs_t_swiginit(self, _ida_kernwin.new_chooser_item_attrs_t(*args))

    def reset(self, *args) -> "void":
        r"""
        reset(self)
        """
        return _ida_kernwin.chooser_item_attrs_t_reset(self, *args)
    __swig_destroy__ = _ida_kernwin.delete_chooser_item_attrs_t

# Register chooser_item_attrs_t in _ida_kernwin:
_ida_kernwin.chooser_item_attrs_t_swigregister(chooser_item_attrs_t)

CHOOSER_NO_SELECTION = _ida_kernwin.CHOOSER_NO_SELECTION
"""
Flags.

enable even if there's no selected item. 'n' will be NO_SELECTION for
a callback.
"""

CHOOSER_MULTI_SELECTION = _ida_kernwin.CHOOSER_MULTI_SELECTION
"""
enable for multiple selections. A callback of type
'chooser_multi_cb_t' will be called for all selected items.
"""

CHOOSER_POPUP_MENU = _ida_kernwin.CHOOSER_POPUP_MENU
"""
Add command to the popup menu.
"""

CHOOSER_MENU_EDIT = _ida_kernwin.CHOOSER_MENU_EDIT
"""
Values of the 'menu_index' parameter.

Obsolete. Please don't use
"""

CHOOSER_MENU_JUMP = _ida_kernwin.CHOOSER_MENU_JUMP
"""
Obsolete. Please don't use.
"""

CHOOSER_MENU_SEARCH = _ida_kernwin.CHOOSER_MENU_SEARCH
"""
Obsolete. Please don't use.
"""

nat_lib = _ida_kernwin.nat_lib

nat_fun = _ida_kernwin.nat_fun

nat_cod = _ida_kernwin.nat_cod

nat_dat = _ida_kernwin.nat_dat

nat_und = _ida_kernwin.nat_und

nat_ext = _ida_kernwin.nat_ext

nat_err = _ida_kernwin.nat_err

nat_gap = _ida_kernwin.nat_gap

nat_cur = _ida_kernwin.nat_cur

nat_auto = _ida_kernwin.nat_auto

nat_lum = _ida_kernwin.nat_lum

nat_last = _ida_kernwin.nat_last

CVH_USERDATA = _ida_kernwin.CVH_USERDATA

CVH_KEYDOWN = _ida_kernwin.CVH_KEYDOWN

CVH_POPUP = _ida_kernwin.CVH_POPUP

CVH_DBLCLICK = _ida_kernwin.CVH_DBLCLICK

CVH_CURPOS = _ida_kernwin.CVH_CURPOS

CVH_CLOSE = _ida_kernwin.CVH_CLOSE

CVH_CLICK = _ida_kernwin.CVH_CLICK

CVH_QT_AWARE = _ida_kernwin.CVH_QT_AWARE

CVH_HELP = _ida_kernwin.CVH_HELP

CVH_MOUSEMOVE = _ida_kernwin.CVH_MOUSEMOVE

CDVH_USERDATA = _ida_kernwin.CDVH_USERDATA

CDVH_SRCVIEW = _ida_kernwin.CDVH_SRCVIEW

CDVH_LINES_CLICK = _ida_kernwin.CDVH_LINES_CLICK

CDVH_LINES_DBLCLICK = _ida_kernwin.CDVH_LINES_DBLCLICK

CDVH_LINES_POPUP = _ida_kernwin.CDVH_LINES_POPUP

CDVH_LINES_DRAWICON = _ida_kernwin.CDVH_LINES_DRAWICON

CDVH_LINES_LINENUM = _ida_kernwin.CDVH_LINES_LINENUM

CDVH_LINES_ICONMARGIN = _ida_kernwin.CDVH_LINES_ICONMARGIN

CDVH_LINES_RADIX = _ida_kernwin.CDVH_LINES_RADIX

CDVH_LINES_ALIGNMENT = _ida_kernwin.CDVH_LINES_ALIGNMENT

VES_SHIFT = _ida_kernwin.VES_SHIFT
"""
state & 1 => Shift is pressedstate & 2 => Alt is pressedstate & 4 =>
Ctrl is pressedstate & 8 => Mouse left button is pressedstate & 16 =>
Mouse right button is pressedstate & 32 => Mouse middle button is
pressedstate & 128 => Meta is pressed (OSX only)
"""

VES_ALT = _ida_kernwin.VES_ALT

VES_CTRL = _ida_kernwin.VES_CTRL

VES_MOUSE_LEFT = _ida_kernwin.VES_MOUSE_LEFT

VES_MOUSE_RIGHT = _ida_kernwin.VES_MOUSE_RIGHT

VES_MOUSE_MIDDLE = _ida_kernwin.VES_MOUSE_MIDDLE

VES_META = _ida_kernwin.VES_META

msg_activated = _ida_kernwin.msg_activated

msg_deactivated = _ida_kernwin.msg_deactivated

msg_click = _ida_kernwin.msg_click

msg_dblclick = _ida_kernwin.msg_dblclick

msg_closed = _ida_kernwin.msg_closed

msg_keydown = _ida_kernwin.msg_keydown

class renderer_pos_info_t(object):
    r"""
    Proxy of C++ renderer_pos_info_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(self) -> renderer_pos_info_t
        """
        _ida_kernwin.renderer_pos_info_t_swiginit(self, _ida_kernwin.new_renderer_pos_info_t(*args))
    node = property(_ida_kernwin.renderer_pos_info_t_node_get, _ida_kernwin.renderer_pos_info_t_node_set)
    cx = property(_ida_kernwin.renderer_pos_info_t_cx_get, _ida_kernwin.renderer_pos_info_t_cx_set)
    cy = property(_ida_kernwin.renderer_pos_info_t_cy_get, _ida_kernwin.renderer_pos_info_t_cy_set)
    sx = property(_ida_kernwin.renderer_pos_info_t_sx_get, _ida_kernwin.renderer_pos_info_t_sx_set)

    def __eq__(self, *args) -> "bool":
        r"""


        __eq__(self, r) -> bool
            r: renderer_pos_info_t const &
        """
        return _ida_kernwin.renderer_pos_info_t___eq__(self, *args)

    def __ne__(self, *args) -> "bool":
        r"""


        __ne__(self, r) -> bool
            r: renderer_pos_info_t const &
        """
        return _ida_kernwin.renderer_pos_info_t___ne__(self, *args)
    __swig_destroy__ = _ida_kernwin.delete_renderer_pos_info_t

# Register renderer_pos_info_t in _ida_kernwin:
_ida_kernwin.renderer_pos_info_t_swigregister(renderer_pos_info_t)

class view_mouse_event_location_t(object):
    r"""
    Proxy of C++ view_mouse_event_location_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    ea = property(_ida_kernwin.view_mouse_event_location_t_ea_get, _ida_kernwin.view_mouse_event_location_t_ea_set)
    item = property(_ida_kernwin.view_mouse_event_location_t_item_get, _ida_kernwin.view_mouse_event_location_t_item_set)

    def __init__(self, *args):
        r"""
        __init__(self) -> view_mouse_event_location_t
        """
        _ida_kernwin.view_mouse_event_location_t_swiginit(self, _ida_kernwin.new_view_mouse_event_location_t(*args))
    __swig_destroy__ = _ida_kernwin.delete_view_mouse_event_location_t

# Register view_mouse_event_location_t in _ida_kernwin:
_ida_kernwin.view_mouse_event_location_t_swigregister(view_mouse_event_location_t)

class view_mouse_event_t(object):
    r"""
    Proxy of C++ view_mouse_event_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    rtype = property(_ida_kernwin.view_mouse_event_t_rtype_get, _ida_kernwin.view_mouse_event_t_rtype_set)
    x = property(_ida_kernwin.view_mouse_event_t_x_get, _ida_kernwin.view_mouse_event_t_x_set)
    y = property(_ida_kernwin.view_mouse_event_t_y_get, _ida_kernwin.view_mouse_event_t_y_set)
    location = property(_ida_kernwin.view_mouse_event_t_location_get, _ida_kernwin.view_mouse_event_t_location_set)
    state = property(_ida_kernwin.view_mouse_event_t_state_get, _ida_kernwin.view_mouse_event_t_state_set)
    button = property(_ida_kernwin.view_mouse_event_t_button_get, _ida_kernwin.view_mouse_event_t_button_set)
    renderer_pos = property(_ida_kernwin.view_mouse_event_t_renderer_pos_get, _ida_kernwin.view_mouse_event_t_renderer_pos_set)

    def __init__(self, *args):
        r"""
        __init__(self) -> view_mouse_event_t
        """
        _ida_kernwin.view_mouse_event_t_swiginit(self, _ida_kernwin.new_view_mouse_event_t(*args))
    __swig_destroy__ = _ida_kernwin.delete_view_mouse_event_t

# Register view_mouse_event_t in _ida_kernwin:
_ida_kernwin.view_mouse_event_t_swigregister(view_mouse_event_t)

view_activated = _ida_kernwin.view_activated

view_deactivated = _ida_kernwin.view_deactivated

view_keydown = _ida_kernwin.view_keydown

view_click = _ida_kernwin.view_click

view_dblclick = _ida_kernwin.view_dblclick

view_curpos = _ida_kernwin.view_curpos

view_created = _ida_kernwin.view_created

view_close = _ida_kernwin.view_close

view_switched = _ida_kernwin.view_switched

view_mouse_over = _ida_kernwin.view_mouse_over

view_loc_changed = _ida_kernwin.view_loc_changed

view_mouse_moved = _ida_kernwin.view_mouse_moved

MFF_FAST = _ida_kernwin.MFF_FAST
"""
Execute code as soon as possible. this mode is ok for calling ui
related functions that do not query the database.
"""

MFF_READ = _ida_kernwin.MFF_READ
"""
Execute code only when ida is idle and it is safe to query the
database. this mode is recommended only for code that does not modify
the database. (nb: ida may be in the middle of executing another user
request, for example it may be waiting for him to enter values into a
modal dialog box)
"""

MFF_WRITE = _ida_kernwin.MFF_WRITE
"""
Execute code only when ida is idle and it is safe to modify the
database. in particular, this flag will suspend execution if there is
a modal dialog box on the screen this mode can be used to call any ida
api function 'MFF_WRITE' implies 'MFF_READ'
"""

MFF_NOWAIT = _ida_kernwin.MFF_NOWAIT
"""
Do not wait for the request to be executed. the caller should ensure
that the request is not destroyed until the execution completes. if
not, the request will be ignored. the request must be created using
the 'new' operator to use it with this flag. it can be used in
'cancel_exec_request()' . This flag can be used to delay the code
execution until the next UI loop run even from the main thread.
"""

class ui_requests_t(object):
    r"""
    Proxy of C++ ui_requests_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(self) -> ui_requests_t
        """
        _ida_kernwin.ui_requests_t_swiginit(self, _ida_kernwin.new_ui_requests_t(*args))
    __swig_destroy__ = _ida_kernwin.delete_ui_requests_t

# Register ui_requests_t in _ida_kernwin:
_ida_kernwin.ui_requests_t_swigregister(ui_requests_t)

UIJMP_ACTIVATE = _ida_kernwin.UIJMP_ACTIVATE
"""
activate the new window
"""

UIJMP_DONTPUSH = _ida_kernwin.UIJMP_DONTPUSH
"""
in the navigation history

do not remember the current address
"""

UIJMP_VIEWMASK = _ida_kernwin.UIJMP_VIEWMASK

UIJMP_ANYVIEW = _ida_kernwin.UIJMP_ANYVIEW
"""
jump in any ea_t-capable view
"""

UIJMP_IDAVIEW = _ida_kernwin.UIJMP_IDAVIEW
"""
jump in idaview
"""

UIJMP_IDAVIEW_NEW = _ida_kernwin.UIJMP_IDAVIEW_NEW
"""
jump in new idaview
"""

class action_ctx_base_t(object):
    r"""
    Proxy of C++ action_ctx_base_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(self) -> action_ctx_base_t
        """
        _ida_kernwin.action_ctx_base_t_swiginit(self, _ida_kernwin.new_action_ctx_base_t(*args))

    def reset(self, *args) -> "void":
        r"""


        Invalidate all context info.
        """
        return _ida_kernwin.action_ctx_base_t_reset(self, *args)
    widget = property(_ida_kernwin.action_ctx_base_t_widget_get, _ida_kernwin.action_ctx_base_t_widget_set)
    widget_type = property(_ida_kernwin.action_ctx_base_t_widget_type_get, _ida_kernwin.action_ctx_base_t_widget_type_set)
    widget_title = property(_ida_kernwin.action_ctx_base_t_widget_title_get, _ida_kernwin.action_ctx_base_t_widget_title_set)
    chooser_selection = property(_ida_kernwin.action_ctx_base_t_chooser_selection_get, _ida_kernwin.action_ctx_base_t_chooser_selection_set)
    action = property(_ida_kernwin.action_ctx_base_t_action_get, _ida_kernwin.action_ctx_base_t_action_set)
    cur_flags = property(_ida_kernwin.action_ctx_base_t_cur_flags_get, _ida_kernwin.action_ctx_base_t_cur_flags_set)

    def has_flag(self, *args) -> "bool":
        r"""


        Check if the given flag is set.
        
        has_flag(self, flag) -> bool
            @param flag (C++: uint32)
        """
        return _ida_kernwin.action_ctx_base_t_has_flag(self, *args)
    cur_ea = property(_ida_kernwin.action_ctx_base_t_cur_ea_get, _ida_kernwin.action_ctx_base_t_cur_ea_set)
    cur_value = property(_ida_kernwin.action_ctx_base_t_cur_value_get, _ida_kernwin.action_ctx_base_t_cur_value_set)
    cur_func = property(_ida_kernwin.action_ctx_base_t_cur_func_get, _ida_kernwin.action_ctx_base_t_cur_func_set)
    cur_fchunk = property(_ida_kernwin.action_ctx_base_t_cur_fchunk_get, _ida_kernwin.action_ctx_base_t_cur_fchunk_set)
    cur_struc = property(_ida_kernwin.action_ctx_base_t_cur_struc_get, _ida_kernwin.action_ctx_base_t_cur_struc_set)
    cur_strmem = property(_ida_kernwin.action_ctx_base_t_cur_strmem_get, _ida_kernwin.action_ctx_base_t_cur_strmem_set)
    cur_enum = property(_ida_kernwin.action_ctx_base_t_cur_enum_get, _ida_kernwin.action_ctx_base_t_cur_enum_set)
    cur_seg = property(_ida_kernwin.action_ctx_base_t_cur_seg_get, _ida_kernwin.action_ctx_base_t_cur_seg_set)
    regname = property(_ida_kernwin.action_ctx_base_t_regname_get, _ida_kernwin.action_ctx_base_t_regname_set)
    focus = property(_ida_kernwin.action_ctx_base_t_focus_get, _ida_kernwin.action_ctx_base_t_focus_set)
    graph_selection = property(_ida_kernwin.action_ctx_base_t_graph_selection_get, _ida_kernwin.action_ctx_base_t_graph_selection_set)
    cur_enum_member = property(_ida_kernwin.action_ctx_base_t_cur_enum_member_get, _ida_kernwin.action_ctx_base_t_cur_enum_member_set)
    dirtree_selection = property(_ida_kernwin.action_ctx_base_t_dirtree_selection_get, _ida_kernwin.action_ctx_base_t_dirtree_selection_set)

    def _get_form(self, *args) -> "TWidget *":
        r"""
        _get_form(self) -> TWidget *
        """
        return _ida_kernwin.action_ctx_base_t__get_form(self, *args)

    def _get_form_type(self, *args) -> "twidget_type_t":
        r"""
        _get_form_type(self) -> twidget_type_t
        """
        return _ida_kernwin.action_ctx_base_t__get_form_type(self, *args)

    def _get_form_title(self, *args) -> "qstring":
        r"""
        _get_form_title(self) -> qstring
        """
        return _ida_kernwin.action_ctx_base_t__get_form_title(self, *args)

    cur_extracted_ea = cur_value

    form = property(_get_form)
    form_type = property(_get_form_type)
    form_title = property(_get_form_title)


    __swig_destroy__ = _ida_kernwin.delete_action_ctx_base_t

# Register action_ctx_base_t in _ida_kernwin:
_ida_kernwin.action_ctx_base_t_swigregister(action_ctx_base_t)
ACF_HAS_SELECTION = _ida_kernwin.ACF_HAS_SELECTION
"""
there is currently a valid selection
"""

ACF_XTRN_EA = _ida_kernwin.ACF_XTRN_EA
"""
cur_ea is in 'externs' segment
"""

ACF_HAS_FIELD_DIRTREE_SELECTION = _ida_kernwin.ACF_HAS_FIELD_DIRTREE_SELECTION
"""
'cur_enum_member' and 'dirtree_selection' fields are present
"""


AHF_VERSION = _ida_kernwin.AHF_VERSION
"""
action handler version (used by 'action_handler_t::flags' )
"""

AHF_VERSION_MASK = _ida_kernwin.AHF_VERSION_MASK
"""
mask for 'action_handler_t::flags'
"""

AST_ENABLE_ALWAYS = _ida_kernwin.AST_ENABLE_ALWAYS

AST_ENABLE_FOR_IDB = _ida_kernwin.AST_ENABLE_FOR_IDB

AST_ENABLE_FOR_WIDGET = _ida_kernwin.AST_ENABLE_FOR_WIDGET

AST_ENABLE = _ida_kernwin.AST_ENABLE

AST_DISABLE_ALWAYS = _ida_kernwin.AST_DISABLE_ALWAYS

AST_DISABLE_FOR_IDB = _ida_kernwin.AST_DISABLE_FOR_IDB

AST_DISABLE_FOR_WIDGET = _ida_kernwin.AST_DISABLE_FOR_WIDGET

AST_DISABLE = _ida_kernwin.AST_DISABLE


def is_action_enabled(*args) -> "bool":
    r"""


    Check if the given action state is one of AST_ENABLE*.
    
    is_action_enabled(s) -> bool
        @param s (C++: action_state_t)
    """
    return _ida_kernwin.is_action_enabled(*args)
class action_desc_t(object):
    r"""
    Proxy of C++ action_desc_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    cb = property(_ida_kernwin.action_desc_t_cb_get, _ida_kernwin.action_desc_t_cb_set)
    name = property(_ida_kernwin.action_desc_t_name_get, _ida_kernwin.action_desc_t_name_set)
    label = property(_ida_kernwin.action_desc_t_label_get, _ida_kernwin.action_desc_t_label_set)
    owner = property(_ida_kernwin.action_desc_t_owner_get, _ida_kernwin.action_desc_t_owner_set)
    shortcut = property(_ida_kernwin.action_desc_t_shortcut_get, _ida_kernwin.action_desc_t_shortcut_set)
    tooltip = property(_ida_kernwin.action_desc_t_tooltip_get, _ida_kernwin.action_desc_t_tooltip_set)
    icon = property(_ida_kernwin.action_desc_t_icon_get, _ida_kernwin.action_desc_t_icon_set)
    flags = property(_ida_kernwin.action_desc_t_flags_get, _ida_kernwin.action_desc_t_flags_set)

    def __init__(self, *args):
        r"""


        __init__(self, name, label, handler, shortcut=None, tooltip=None, icon=-1, flags=0) -> action_desc_t
            name: char const *
            label: char const *
            handler: PyObject *
            shortcut: char const *
            tooltip: char const *
            icon: int
            flags: int
        """
        _ida_kernwin.action_desc_t_swiginit(self, _ida_kernwin.new_action_desc_t(*args))
    __swig_destroy__ = _ida_kernwin.delete_action_desc_t

# Register action_desc_t in _ida_kernwin:
_ida_kernwin.action_desc_t_swigregister(action_desc_t)
ADF_OWN_HANDLER = _ida_kernwin.ADF_OWN_HANDLER
"""
handler is owned by the action; it'll be destroyed when the action is
unregistered. You shouldn't have to use this.
"""

ADF_NO_UNDO = _ida_kernwin.ADF_NO_UNDO
"""
useful for actions that do not modify the database.

the action does not create an undo point.
"""

ADF_OT_MASK = _ida_kernwin.ADF_OT_MASK
"""
Owner type mask.
"""

ADF_OT_PLUGIN = _ida_kernwin.ADF_OT_PLUGIN
"""
Owner is a 'plugin_t' .
"""

ADF_OT_PLUGMOD = _ida_kernwin.ADF_OT_PLUGMOD
"""
Owner is a 'plugmod_t' .
"""

ADF_OT_PROCMOD = _ida_kernwin.ADF_OT_PROCMOD
"""
Owner is a 'procmod_t' .
"""

ADF_GLOBAL = _ida_kernwin.ADF_GLOBAL
"""
available even if no IDB is present

Register the action globally, so that it's
"""

ADF_NO_HIGHLIGHT = _ida_kernwin.ADF_NO_HIGHLIGHT
"""
according to what's under the cursor (listings only.)

After activating, do not update the highlight
"""


AA_NONE = _ida_kernwin.AA_NONE

AA_LABEL = _ida_kernwin.AA_LABEL

AA_SHORTCUT = _ida_kernwin.AA_SHORTCUT

AA_TOOLTIP = _ida_kernwin.AA_TOOLTIP

AA_ICON = _ida_kernwin.AA_ICON

AA_STATE = _ida_kernwin.AA_STATE

AA_CHECKABLE = _ida_kernwin.AA_CHECKABLE

AA_CHECKED = _ida_kernwin.AA_CHECKED

AA_VISIBILITY = _ida_kernwin.AA_VISIBILITY


def cancel_exec_request(*args) -> "bool":
    r"""


    Try to cancel an asynchronous exec request ( 'ui_cancel_exec_request'
    ).
    
    cancel_exec_request(req_id) -> bool
        @param req_id: request id (C++: int)
        @retval: true - successfully canceled
        @retval: false - request has already been processed.
    """
    return _ida_kernwin.cancel_exec_request(*args)

def cancel_thread_exec_requests(*args) -> "int":
    r"""


    Try to cancel asynchronous exec requests created by the specified
    thread.
    
    cancel_thread_exec_requests(tid) -> int
        @param tid: thread id (C++: qthread_t)
        @return: number of the canceled requests.
    """
    return _ida_kernwin.cancel_thread_exec_requests(*args)

def get_synced_group(*args) -> "synced_group_t const *":
    r"""


    Get the group of widgets/registers this view is synchronized with
    
    get_synced_group(w) -> synced_group_t
        @param w: the widget (C++: const TWidget *)
        @return: the group of widgets/registers, or NULL
    """
    return _ida_kernwin.get_synced_group(*args)

def banner(*args) -> "bool":
    r"""


    Show a banner dialog box ( 'ui_banner' ).
    
    banner(wait) -> bool
        @param wait: time to wait before closing (C++: int)
        @retval: 1 - ok
        @retval: 0 - esc was pressed
    """
    return _ida_kernwin.banner(*args)

def is_msg_inited(*args) -> "bool":
    r"""


    Can we use msg() functions?
    """
    return _ida_kernwin.is_msg_inited(*args)

def refresh_idaview(*args) -> "void":
    r"""


    Refresh marked windows ( 'ui_refreshmarked' )
    """
    return _ida_kernwin.refresh_idaview(*args)

def refresh_idaview_anyway(*args) -> "void":
    r"""


    Refresh all disassembly views ( 'ui_refresh' ), forces an immediate
    refresh. Please consider 'request_refresh()' instead
    """
    return _ida_kernwin.refresh_idaview_anyway(*args)

def analyzer_options(*args) -> "void":
    r"""


    Allow the user to set analyzer options. (show a dialog box) (
    'ui_analyzer_options' )
    """
    return _ida_kernwin.analyzer_options(*args)

def get_screen_ea(*args) -> "ea_t":
    r"""


    Get the address at the screen cursor ( 'ui_screenea' )
    """
    return _ida_kernwin.get_screen_ea(*args)

def get_opnum(*args) -> "int":
    r"""


    Get current operand number, -1 means no operand ( 'ui_get_opnum' )
    """
    return _ida_kernwin.get_opnum(*args)

def get_cursor(*args) -> "int *, int *":
    r"""


    Get the cursor position on the screen ( 'ui_get_cursor' ).coordinates
    are 0-based
    """
    return _ida_kernwin.get_cursor(*args)

def get_output_cursor(*args) -> "int *, int *":
    r"""


    Get coordinates of the output window's cursor ( 'ui_get_output_cursor'
    ).coordinates are 0-basedthis function will succeed even if the output
    window is not visible
    """
    return _ida_kernwin.get_output_cursor(*args)

def get_curline(*args) -> "char const *":
    r"""


    Get current line from the disassemble window ( 'ui_get_curline' ).
    """
    return _ida_kernwin.get_curline(*args)

def open_url(*args) -> "void":
    r"""


    Open the given url ( 'ui_open_url' )
    
    open_url(url)
        @param url (C++: const char *)
    """
    return _ida_kernwin.open_url(*args)

def get_hexdump_ea(*args) -> "ea_t":
    r"""


    Get the current address in a hex view.
    
    get_hexdump_ea(hexdump_num) -> ea_t
        @param hexdump_num: number of hexview window (C++: int)
    """
    return _ida_kernwin.get_hexdump_ea(*args)

def get_key_code(*args) -> "ushort":
    r"""


    Get keyboard key code by its name ( 'ui_get_key_code' )
    
    get_key_code(keyname) -> ushort
        @param keyname (C++: const char *)
    """
    return _ida_kernwin.get_key_code(*args)

def lookup_key_code(*args) -> "ushort":
    r"""


    Get shortcut code previously created by 'ui_get_key_code' .
    
    lookup_key_code(key, shift, is_qt) -> ushort
        @param key: key constant (C++: int)
        @param shift: modifiers (C++: int)
        @param is_qt: are we using gui version? (C++: bool)
    """
    return _ida_kernwin.lookup_key_code(*args)

def refresh_navband(*args) -> "void":
    r"""


    Refresh navigation band if changed ( 'ui_refresh_navband' ).
    
    refresh_navband(force)
        @param force: refresh regardless (C++: bool)
    """
    return _ida_kernwin.refresh_navband(*args)

def refresh_chooser(*args) -> "bool":
    r"""


    Mark a non-modal custom chooser for a refresh ( 'ui_refresh_chooser'
    ).
    
    refresh_chooser(title) -> bool
        @param title: title of chooser (C++: const char *)
        @return: success
    """
    return _ida_kernwin.refresh_chooser(*args)

def close_chooser(*args) -> "bool":
    r"""


    Close a non-modal chooser ( 'ui_close_chooser' ).
    
    close_chooser(title) -> bool
        @param title: window title of chooser to close (C++: const char *)
        @return: success
    """
    return _ida_kernwin.close_chooser(*args)

def set_dock_pos(*args) -> "bool":
    r"""


    set_dock_pos(src_ctrl, dest_ctrl, orient, left=0, top=0, right=0, bottom=0) -> bool
    Sets the dock orientation of a window relatively to another window.
    
    @param src: Source docking control
    @param dest: Destination docking control
    @param orient: One of DOR_XXXX constants
    @param left, top, right, bottom: These parameter if DOR_FLOATING is used, or if you want to specify the width of docked windows
    @return: Boolean
    
    Example:
        set_dock_pos('Structures', 'Enums', DOR_RIGHT) <- docks the Structures window to the right of Enums window
    """
    return _ida_kernwin.set_dock_pos(*args)

def free_custom_icon(*args) -> "void":
    r"""


    free_custom_icon(icon_id)
    Frees an icon loaded with load_custom_icon()
    """
    return _ida_kernwin.free_custom_icon(*args)
class __qtimer_t(object):
    r"""
    Proxy of C++ __qtimer_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(self) -> __qtimer_t
        """
        _ida_kernwin.__qtimer_t_swiginit(self, _ida_kernwin.new___qtimer_t(*args))
    __swig_destroy__ = _ida_kernwin.delete___qtimer_t

# Register __qtimer_t in _ida_kernwin:
_ida_kernwin.__qtimer_t_swigregister(__qtimer_t)


def unregister_action(*args) -> "bool":
    r"""


    Delete a previously-registered action ( 'ui_unregister_action' ).
    
    unregister_action(name) -> bool
        @param name: name of action (C++: const char *)
        @return: success
    """
    return _ida_kernwin.unregister_action(*args)

def create_toolbar(*args) -> "bool":
    r"""


    Create a toolbar with the given name, label and optional position
    
    create_toolbar(name, label, before=None, flags=0) -> bool
        @param name: name of toolbar (must be unique) (C++: const char *)
        @param label: label of toolbar (C++: const char *)
        @param before: if non-NULL, the toolbar before which the new toolbar
                       will be inserted (C++: const char *)
        @param flags: a combination of  create toolbar flags , to determine
                      toolbar position (C++: int)
        @return: success
    """
    return _ida_kernwin.create_toolbar(*args)

def delete_toolbar(*args) -> "bool":
    r"""


    Delete an existing toolbar
    
    delete_toolbar(name) -> bool
        @param name: name of toolbar (C++: const char *)
        @return: success
    """
    return _ida_kernwin.delete_toolbar(*args)

def create_menu(*args) -> "bool":
    r"""


    Create a menu with the given name, label and optional position, either
    in the menubar, or as a submenu. If 'menupath' is non-NULL, it
    provides information about where the menu should be positioned. First,
    IDA will try and resolve the corresponding menu by its name. If such
    an existing menu is found and is present in the menubar, then the new
    menu will be inserted in the menubar before it. Otherwise, IDA will
    try to resolve 'menupath' as it would for 'attach_action_to_menu()'
    and, if found, add the new menu like so:
    
    // The new 'My menu' submenu will appear in the 'Comments' submenu
    // before the 'Enter comment..." command
    create_menu("(...)", "My menu", "Edit/Comments/Enter comment...");
    
    or
    
    // The new 'My menu' submenu will appear at the end of the
    // 'Comments' submenu.
    create_menu("(...)", "My menu", "Edit/Comments/");
    
    If the above fails, the new menu will be appended to the menubar.
    
    create_menu(name, label, menupath=None) -> bool
        @param name: name of menu (must be unique) (C++: const char *)
        @param label: label of menu (C++: const char *)
        @param menupath: where should the menu be inserted (C++: const char *)
        @return: success
    """
    return _ida_kernwin.create_menu(*args)

def delete_menu(*args) -> "bool":
    r"""


    Delete an existing menu
    
    delete_menu(name) -> bool
        @param name: name of menu (C++: const char *)
        @return: success
    """
    return _ida_kernwin.delete_menu(*args)

def attach_action_to_menu(*args) -> "bool":
    r"""


    Attach a previously-registered action to the menu (
    'ui_attach_action_to_menu' ).You should not change top level menu, or
    the Edit,Plugins submenus If you want to modify the debugger menu, do
    it at the ui_debugger_menu_change event (ida might destroy your menu
    item if you do it elsewhere).
    
    attach_action_to_menu(menupath, name, flags) -> bool
        @param menupath: path to the menu item after or before which the
                         insertion will take place.      Example:
                         Debug/StartProcess   Whitespace, punctuation are
                         ignored.   It is allowed to specify only the prefix
                         of the menu item.   Comparison is case insensitive.
                         menupath may start with the following prefixes:   [S]
                         - modify the main menu of the structure window   [E]
                         - modify the main menu of the enum window (C++: const
                         char *)
        @param name: the action name (C++: const char *)
        @param flags: a combination of  Set menu flags , to determine menu
                      item position (C++: int)
        @return: success
    """
    return _ida_kernwin.attach_action_to_menu(*args)

def detach_action_from_menu(*args) -> "bool":
    r"""


    Detach an action from the menu ( 'ui_detach_action_from_menu' ).
    
    detach_action_from_menu(menupath, name) -> bool
        @param menupath: path to the menu item (C++: const char *)
        @param name: the action name (C++: const char *)
        @return: success
    """
    return _ida_kernwin.detach_action_from_menu(*args)

def attach_action_to_toolbar(*args) -> "bool":
    r"""


    Attach an action to an existing toolbar (
    'ui_attach_action_to_toolbar' ).
    
    attach_action_to_toolbar(toolbar_name, name) -> bool
        @param toolbar_name: the name of the toolbar (C++: const char *)
        @param name: the action name (C++: const char *)
        @return: success
    """
    return _ida_kernwin.attach_action_to_toolbar(*args)

def detach_action_from_toolbar(*args) -> "bool":
    r"""


    Detach an action from the toolbar ( 'ui_detach_action_from_toolbar' ).
    
    detach_action_from_toolbar(toolbar_name, name) -> bool
        @param toolbar_name: the name of the toolbar (C++: const char *)
        @param name: the action name (C++: const char *)
        @return: success
    """
    return _ida_kernwin.detach_action_from_toolbar(*args)

def register_and_attach_to_menu(*args) -> "bool":
    r"""


    Helper.You are not encouraged to use this, as it mixes flags for both
    'register_action()' , and 'attach_action_to_menu()' .The only reason
    for its existence is to make it simpler to port existing plugins to
    the new actions API.
    
    register_and_attach_to_menu(menupath, name, label, shortcut, flags, handler, owner, action_desc_t_flags) -> bool
        @param menupath (C++: const char *)
        @param name (C++: const char *)
        @param label (C++: const char *)
        @param shortcut (C++: const char *)
        @param flags (C++: int)
        @param handler (C++: action_handler_t  *)
        @param owner (C++: void *)
        @param action_desc_t_flags (C++: int)
    """
    return _ida_kernwin.register_and_attach_to_menu(*args)

def display_widget(*args) -> "void":
    r"""


    Display a widget, dock it if not done before
    
    display_widget(widget, options, dest_ctrl=None)
        @param widget: widget to display (C++: TWidget *)
        @param options: Widget open flags (C++: uint32)
        @param dest_ctrl: where to dock: if NULL or invalid then use the
                          active docker if there is not create a new tab
                          relative to current active tab (C++: const char *)
    """
    return _ida_kernwin.display_widget(*args)

def close_widget(*args) -> "void":
    r"""


    Close widget ( 'ui_close_widget' , only gui version).
    
    close_widget(widget, options)
        @param widget: pointer to the widget to close (C++: TWidget *)
        @param options: Form close flags (C++: int)
    """
    return _ida_kernwin.close_widget(*args)

def activate_widget(*args) -> "void":
    r"""


    Activate widget (only gui version) ( 'ui_activate_widget' ).
    
    activate_widget(widget, take_focus)
        @param widget: existing widget to display (C++: TWidget *)
        @param take_focus: give focus to given widget (C++: bool)
    """
    return _ida_kernwin.activate_widget(*args)

def find_widget(*args) -> "TWidget *":
    r"""


    Find widget with the specified caption (only gui version) (
    'ui_find_widget' ). NB: this callback works only with the tabbed
    widgets!
    
    find_widget(caption) -> TWidget *
        @param caption: title of tab, or window title if widget is not tabbed
                        (C++: const char *)
        @return: pointer to the TWidget, NULL if none is found
    """
    return _ida_kernwin.find_widget(*args)

def get_current_widget(*args) -> "TWidget *":
    r"""


    Get a pointer to the current widget ( 'ui_get_current_widget' ).
    """
    return _ida_kernwin.get_current_widget(*args)

def get_widget_type(*args) -> "twidget_type_t":
    r"""


    Get the type of the TWidget * ( 'ui_get_widget_type' ).
    
    get_widget_type(widget) -> twidget_type_t
        @param widget (C++: TWidget *)
    """
    return _ida_kernwin.get_widget_type(*args)

def get_widget_title(*args) -> "qstring *":
    r"""


    Get the TWidget's title ( 'ui_get_widget_title' ).
    
    get_widget_title(widget) -> str
        @param widget (C++: TWidget *)
    """
    return _ida_kernwin.get_widget_title(*args)

def custom_viewer_jump(*args) -> "bool":
    r"""


    Append 'loc' to the viewer's history, and cause the viewer to display
    it.
    
    custom_viewer_jump(v, loc, flags=0) -> bool
        @param v: (TWidget *) (C++: TWidget *)
        @param loc: (const  lochist_entry_t  &) (C++: const  lochist_entry_t
                    &)
        @param flags: (uint32) or'ed combination of CVNF_* values (C++:
                      uint32)
        @return: success
    """
    return _ida_kernwin.custom_viewer_jump(*args)

def ea_viewer_history_push_and_jump(*args) -> "bool":
    r"""


    Push current location in the history and jump to the given location (
    'ui_ea_viewer_history_push_and_jump' ). This will jump in the given ea
    viewer and also in other synchronized views.
    
    ea_viewer_history_push_and_jump(v, ea, x, y, lnnum) -> bool
        @param v: ea viewer (C++: TWidget *)
        @param ea: jump destination (C++: ea_t)
        @param x: coords on screen (C++: int)
        @param y: coords on screen (C++: int)
        @param lnnum: desired line number of given address (C++: int)
    """
    return _ida_kernwin.ea_viewer_history_push_and_jump(*args)

def get_ea_viewer_history_info(*args) -> "bool":
    r"""


    Get information about what's in the history (
    'ui_ea_viewer_history_info' ).
    
    get_ea_viewer_history_info(nback, nfwd, v) -> bool
        @param nback: number of available back steps (C++: int *)
        @param nfwd: number of available forward steps (C++: int *)
        @param v: ea viewer (C++: TWidget *)
        @retval: false - if the given ea viewer does not exist
        @retval: true - otherwise
    """
    return _ida_kernwin.get_ea_viewer_history_info(*args)

def repaint_custom_viewer(*args) -> "void":
    r"""


    Repaint the given widget immediately ( 'ui_repaint_qwidget' )
    
    repaint_custom_viewer(custom_viewer)
        @param custom_viewer (C++: TWidget *)
    """
    return _ida_kernwin.repaint_custom_viewer(*args)

def jumpto(*args) -> "bool":
    r"""


    Jump to the specified address ( 'ui_jumpto' ).
    
    jumpto(ea, opnum=-1, uijmp_flags=0x0001) -> bool
        @param ea: destination (C++: ea_t)
        @param opnum: -1: don't change x coord (C++: int)
        @param uijmp_flags: Jump flags (C++: int)
        @return: success
    

    jumpto(custom_viewer, place, x, y) -> bool
        custom_viewer: TWidget *
        place: place_t *
        x: int
        y: int
        @return: success
    """
    return _ida_kernwin.jumpto(*args)

def get_custom_viewer_place(*args) -> "int *, int *":
    r"""


    Get current place in a custom viewer ( 'ui_get_curplace' ).See also
    the more complete 'get_custom_viewer_location()'
    
    get_custom_viewer_place(custom_viewer, mouse) -> place_t
        @param custom_viewer: view (C++: TWidget *)
        @param mouse: mouse position (otherwise cursor position) (C++: bool)
    """
    return _ida_kernwin.get_custom_viewer_place(*args)

def get_custom_viewer_location(*args) -> "bool":
    r"""


    Get the current location in a custom viewer (
    'ui_get_custom_viewer_location' ).
    
    get_custom_viewer_location(out, custom_viewer, mouse=False) -> bool
        @param out (C++: lochist_entry_t  *)
        @param custom_viewer (C++: TWidget *)
        @param mouse (C++: bool)
    """
    return _ida_kernwin.get_custom_viewer_location(*args)

def is_idaq(*args) -> "bool":
    r"""


    is_idaq() -> bool
    Returns True or False depending if IDAPython is hosted by IDAQ
    """
    return _ida_kernwin.is_idaq(*args)

def attach_action_to_popup(*args) -> "bool":
    r"""


    Insert a previously-registered action into the widget's popup menu (
    'ui_attach_action_to_popup' ). This function has two "modes": 'single-
    shot', and 'permanent'.
    
    attach_action_to_popup(widget, popup_handle, name, popuppath=None, flags=0) -> bool
        @param widget: target widget (C++: TWidget *)
        @param popup_handle: target popup menu   if non-NULL, the action is
                             added to this popup menu invocation (i.e.,
                             'single-shot')   if NULL, the action is added to
                             a list of actions that should always be present
                             in context menus for this widget (i.e.,
                             'permanent'.) (C++: TPopupMenu *)
        @param name: action name (C++: const char *)
        @param popuppath: can be NULL (C++: const char *)
        @param flags: a combination of SETMENU_ flags (see  Set menu flags )
                      (C++: int)
        @return: success
    """
    return _ida_kernwin.attach_action_to_popup(*args)

def detach_action_from_popup(*args) -> "bool":
    r"""


    Remove a previously-registered action, from the list of 'permanent'
    context menu actions for this widget ( 'ui_detach_action_from_popup'
    ). This only makes sense if the action has been added to 'widget's
    list of permanent popup actions by calling attach_action_to_popup in
    'permanent' mode.
    
    detach_action_from_popup(widget, name) -> bool
        @param widget: target widget (C++: TWidget *)
        @param name: action name (C++: const char *)
    """
    return _ida_kernwin.detach_action_from_popup(*args)

def update_action_label(*args) -> "bool":
    r"""


    Update an action's label ( 'ui_update_action_attr' ).
    
    update_action_label(name, label) -> bool
        @param name: action name (C++: const char *)
        @param label: new label (C++: const char *)
        @return: success
    """
    return _ida_kernwin.update_action_label(*args)

def update_action_shortcut(*args) -> "bool":
    r"""


    Update an action's shortcut ( 'ui_update_action_attr' ).
    
    update_action_shortcut(name, shortcut) -> bool
        @param name: action name (C++: const char *)
        @param shortcut: new shortcut (C++: const char *)
        @return: success
    """
    return _ida_kernwin.update_action_shortcut(*args)

def update_action_tooltip(*args) -> "bool":
    r"""


    Update an action's tooltip ( 'ui_update_action_attr' ).
    
    update_action_tooltip(name, tooltip) -> bool
        @param name: action name (C++: const char *)
        @param tooltip: new tooltip (C++: const char *)
        @return: success
    """
    return _ida_kernwin.update_action_tooltip(*args)

def update_action_icon(*args) -> "bool":
    r"""


    Update an action's icon ( 'ui_update_action_attr' ).
    
    update_action_icon(name, icon) -> bool
        @param name: action name (C++: const char *)
        @param icon: new icon id (C++: int)
        @return: success
    """
    return _ida_kernwin.update_action_icon(*args)

def update_action_state(*args) -> "bool":
    r"""


    Update an action's state ( 'ui_update_action_attr' ).
    
    update_action_state(name, state) -> bool
        @param name: action name (C++: const char *)
        @param state: new state (C++: action_state_t)
        @return: success
    """
    return _ida_kernwin.update_action_state(*args)

def update_action_checkable(*args) -> "bool":
    r"""


    Update an action's checkability ( 'ui_update_action_attr' ).
    
    update_action_checkable(name, checkable) -> bool
        @param name: action name (C++: const char *)
        @param checkable: new checkability (C++: bool)
        @return: success
    """
    return _ida_kernwin.update_action_checkable(*args)

def update_action_checked(*args) -> "bool":
    r"""


    Update an action's checked state ( 'ui_update_action_attr' ).
    
    update_action_checked(name, checked) -> bool
        @param name: action name (C++: const char *)
        @param checked: new checked state (C++: bool)
        @return: success
    """
    return _ida_kernwin.update_action_checked(*args)

def update_action_visibility(*args) -> "bool":
    r"""


    Update an action's visibility ( 'ui_update_action_attr' ).
    
    update_action_visibility(name, visible) -> bool
        @param name: action name (C++: const char *)
        @param visible: new visibility (C++: bool)
        @return: success
    """
    return _ida_kernwin.update_action_visibility(*args)

def get_action_label(*args) -> "qstring *":
    r"""


    Get an action's label ( 'ui_get_action_attr' ).
    
    get_action_label(name) -> str
        @param name: the action name (C++: const char *)
        @return: success
    """
    return _ida_kernwin.get_action_label(*args)

def get_action_shortcut(*args) -> "qstring *":
    r"""


    Get an action's shortcut ( 'ui_get_action_attr' ).
    
    get_action_shortcut(name) -> str
        @param name: the action name (C++: const char *)
        @return: success
    """
    return _ida_kernwin.get_action_shortcut(*args)

def get_action_tooltip(*args) -> "qstring *":
    r"""


    Get an action's tooltip ( 'ui_get_action_attr' ).
    
    get_action_tooltip(name) -> str
        @param name: the action name (C++: const char *)
        @return: success
    """
    return _ida_kernwin.get_action_tooltip(*args)

def get_action_icon(*args) -> "int *":
    r"""


    Get an action's icon ( 'ui_get_action_attr' ).
    
    get_action_icon(name) -> bool
        @param name: the action name (C++: const char *)
        @return: success
    """
    return _ida_kernwin.get_action_icon(*args)

def get_action_state(*args) -> "action_state_t *":
    r"""


    Get an action's state ( 'ui_get_action_attr' ).
    
    get_action_state(name) -> bool
        @param name: the action name (C++: const char *)
        @return: success
    """
    return _ida_kernwin.get_action_state(*args)

def get_action_checkable(*args) -> "bool *":
    r"""


    Get an action's checkability ( 'ui_get_action_attr' ).
    
    get_action_checkable(name) -> bool
        @param name: the action name (C++: const char *)
        @return: success
    """
    return _ida_kernwin.get_action_checkable(*args)

def get_action_checked(*args) -> "bool *":
    r"""


    Get an action's checked state ( 'ui_get_action_attr' ).
    
    get_action_checked(name) -> bool
        @param name: the action name (C++: const char *)
        @return: success
    """
    return _ida_kernwin.get_action_checked(*args)

def get_action_visibility(*args) -> "bool *":
    r"""


    Get an action's visibility ( 'ui_get_action_attr' ).
    
    get_action_visibility(name) -> bool
        @param name: the action name (C++: const char *)
        @return: success
    """
    return _ida_kernwin.get_action_visibility(*args)

def set_custom_viewer_qt_aware(*args) -> "bool":
    r"""


    Allow the given viewer to interpret Qt events (
    'ui_set_custom_viewer_handler' )
    
    set_custom_viewer_qt_aware(custom_viewer) -> bool
        @param custom_viewer (C++: TWidget *)
    """
    return _ida_kernwin.set_custom_viewer_qt_aware(*args)

def get_custom_viewer_curline(*args) -> "char const *":
    r"""


    Get current line of custom viewer ( 'ui_get_custom_viewer_curline' ).
    The returned line contains color codes
    
    get_custom_viewer_curline(custom_viewer, mouse) -> char const *
        @param custom_viewer: view (C++: TWidget *)
        @param mouse: mouse position (otherwise cursor position) (C++: bool)
        @return: pointer to contents of current line
    """
    return _ida_kernwin.get_custom_viewer_curline(*args)

def get_output_curline(*args) -> "qstring *":
    r"""


    Get current line of output window ( 'ui_get_output_curline' ).
    
    get_output_curline(mouse) -> str
        @param mouse: current for mouse pointer? (C++: bool)
        @return: false if output contains no text
    """
    return _ida_kernwin.get_output_curline(*args)

def get_output_selected_text(*args) -> "qstring *":
    r"""


    Returns selected text from output window (
    'ui_get_output_selected_text' ).
    """
    return _ida_kernwin.get_output_selected_text(*args)

def get_current_viewer(*args) -> "TWidget *":
    r"""


    Get current ida viewer (idaview or custom viewer) (
    'ui_get_current_viewer' )
    """
    return _ida_kernwin.get_current_viewer(*args)

def get_view_renderer_type(*args) -> "tcc_renderer_type_t":
    r"""


    Get the type of renderer currently in use in the given view (
    'ui_get_renderer_type' )
    
    get_view_renderer_type(v) -> tcc_renderer_type_t
        @param v (C++: TWidget *)
    """
    return _ida_kernwin.get_view_renderer_type(*args)

def set_view_renderer_type(*args) -> "void":
    r"""


    Set the type of renderer to use in a view ( 'ui_set_renderer_type' )
    
    set_view_renderer_type(v, rt)
        @param v (C++: TWidget *)
        @param rt (C++: tcc_renderer_type_t)
    """
    return _ida_kernwin.set_view_renderer_type(*args)

def create_empty_widget(*args) -> "TWidget *":
    r"""


    Create an empty widget, serving as a container for custom user widgets
    
    create_empty_widget(title, icon=-1) -> TWidget *
        @param title (C++: const char *)
        @param icon (C++: int)
    """
    return _ida_kernwin.create_empty_widget(*args)

def msg_clear(*args) -> "void":
    r"""


    Clear the "Output window".
    """
    return _ida_kernwin.msg_clear(*args)

def msg_save(*args) -> "bool":
    r"""


    Save the "Output window" contents into a file
    
    msg_save(path) -> bool
        @param path: The path of the file to save the contents into. An empty
                     path means that the user will be prompted for the
                     destination and, if the file already exists, the user
                     will be asked to confirm before overriding its contents.
                     Upon return, 'path' will contain the path that the user
                     chose. (C++: qstring  &)
        @return: success
    """
    return _ida_kernwin.msg_save(*args)

def get_active_modal_widget(*args) -> "TWidget *":
    r"""


    Get the current, active modal TWidget instance. Note that in this
    context, the "wait dialog" is not considered: this function will
    return NULL even if it is currently shown.
    """
    return _ida_kernwin.get_active_modal_widget(*args)

def get_navband_pixel(*args) -> "bool *":
    r"""


    get_navband_pixel(ea) -> int
    Maps an address, onto a pixel coordinate within the navband
    
    @param ea: The address to map
    @return: a list [pixel, is_vertical]
    """
    return _ida_kernwin.get_navband_pixel(*args)

def get_navband_ea(*args) -> "ea_t":
    r"""


    Translate the pixel position on the navigation band, into an address.
    
    get_navband_ea(pixel) -> ea_t
        @param pixel (C++: int)
    """
    return _ida_kernwin.get_navband_ea(*args)

def get_window_id(*args) -> "void *":
    r"""


    Get the system-specific window ID (GUI version only)
    
    get_window_id(name=None) -> void *
        @param name (C++: const char *)
        @return: the low-level window ID
    """
    return _ida_kernwin.get_window_id(*args)

def read_selection(*args) -> "bool":
    r"""


    read_selection(v, p1, p2) -> bool
    Read the user selection, and store its information in p0 (from) and p1 (to).
    
    This can be used as follows:
    
    
    >>> p0 = idaapi.twinpos_t()
    p1 = idaapi.twinpos_t()
    view = idaapi.get_current_viewer()
    idaapi.read_selection(view, p0, p1)
    
    
    At that point, p0 and p1 hold information for the selection.
    But, the 'at' property of p0 and p1 is not properly typed.
    To specialize it, call #place() on it, passing it the view
    they were retrieved from. Like so:
    
    
    >>> place0 = p0.place(view)
    place1 = p1.place(view)
    
    
    This will effectively "cast" the place into a specialized type,
    holding proper information, depending on the view type (e.g.,
    disassembly, structures, enums, ...)
    
    @param view: The view to retrieve the selection for.
    @param p0: Storage for the "from" part of the selection.
    @param p1: Storage for the "to" part of the selection.
    @return: a bool value indicating success.
    """
    return _ida_kernwin.read_selection(*args)

def read_range_selection(*args) -> "ea_t *, ea_t *":
    r"""


    Get the address range for the selected range boundaries, this is the
    convenient function for 'read_selection()'
    
    read_range_selection(v) -> bool
        @param v: view, NULL means the last active window containing addresses
                  (C++: TWidget *)
        @retval: 0 - no range is selected
        @retval: 1 - ok, start ea and end ea are filled
    """
    return _ida_kernwin.read_range_selection(*args)

def unmark_selection(*args) -> "void":
    r"""


    Unmark selection ( 'ui_unmarksel' )
    """
    return _ida_kernwin.unmark_selection(*args)

def create_code_viewer(*args) -> "TWidget *":
    r"""


    Create a code viewer ( 'ui_create_code_viewer' ). A code viewer
    contains on the left side a widget representing the line numbers, and
    on the right side, the child widget passed as parameter. It will
    inherit its title from the child widget.
    
    create_code_viewer(custview, flags=0, parent=None) -> TWidget *
        @param custview: the custom view to be added (C++: TWidget *)
        @param flags: Code viewer flags (C++: int)
        @param parent: widget to contain the new code viewer (C++: TWidget *)
    """
    return _ida_kernwin.create_code_viewer(*args)

def set_code_viewer_handler(*args) -> "void *":
    r"""


    Set a handler for a code viewer event ( 'ui_set_custom_viewer_handler'
    ).
    
    set_code_viewer_handler(code_viewer, handler_id, handler_or_data) -> void *
        @param code_viewer: the code viewer (C++: TWidget *)
        @param handler_id: one of CDVH_ in  custom_viewer_handler_id_t (C++:
                           custom_viewer_handler_id_t)
        @param handler_or_data: can be a handler or data. see examples in
                                Functions: custom viewer handlers (C++: void
                                *)
        @return: old value of the handler or data
    """
    return _ida_kernwin.set_code_viewer_handler(*args)

def set_code_viewer_user_data(*args) -> "bool":
    r"""


    Set the user data on a code viewer ( 'ui_set_custom_viewer_handler' ).
    
    set_code_viewer_user_data(code_viewer, ud) -> bool
        @param code_viewer (C++: TWidget *)
        @param ud (C++: void *)
    """
    return _ida_kernwin.set_code_viewer_user_data(*args)

def get_viewer_user_data(*args) -> "void *":
    r"""


    Get the user data from a custom viewer ( 'ui_get_viewer_user_data' )
    
    get_viewer_user_data(viewer) -> void *
        @param viewer (C++: TWidget *)
    """
    return _ida_kernwin.get_viewer_user_data(*args)

def get_viewer_place_type(*args) -> "tcc_place_type_t":
    r"""


    Get the type of 'place_t' instances a viewer uses & creates (
    'ui_get_viewer_place_type' ).
    
    get_viewer_place_type(viewer) -> tcc_place_type_t
        @param viewer (C++: TWidget *)
    """
    return _ida_kernwin.get_viewer_place_type(*args)

def set_code_viewer_line_handlers(*args) -> "void":
    r"""


    Set handlers for code viewer line events. Any of these handlers may be
    NULL
    
    set_code_viewer_line_handlers(code_viewer, click_handler, popup_handler, dblclick_handler, drawicon_handler, linenum_handler)
        @param code_viewer (C++: TWidget *)
        @param click_handler (C++: code_viewer_lines_click_t  *)
        @param popup_handler (C++: code_viewer_lines_click_t  *)
        @param dblclick_handler (C++: code_viewer_lines_click_t  *)
        @param drawicon_handler (C++: code_viewer_lines_icon_t  *)
        @param linenum_handler (C++: code_viewer_lines_linenum_t  *)
    """
    return _ida_kernwin.set_code_viewer_line_handlers(*args)

def set_code_viewer_lines_icon_margin(*args) -> "bool":
    r"""


    Set space allowed for icons in the margin of a code viewer (
    'ui_set_custom_viewer_handler' ).
    
    set_code_viewer_lines_icon_margin(code_viewer, margin) -> bool
        @param code_viewer (C++: TWidget *)
        @param margin (C++: int)
    """
    return _ida_kernwin.set_code_viewer_lines_icon_margin(*args)

def set_code_viewer_lines_alignment(*args) -> "bool":
    r"""


    Set alignment for lines in a code viewer (
    'ui_set_custom_viewer_handler' ).
    
    set_code_viewer_lines_alignment(code_viewer, align) -> bool
        @param code_viewer (C++: TWidget *)
        @param align (C++: int)
    """
    return _ida_kernwin.set_code_viewer_lines_alignment(*args)

def set_code_viewer_lines_radix(*args) -> "bool":
    r"""


    Set radix for values displayed in a code viewer (
    'ui_set_custom_viewer_handler' ).
    
    set_code_viewer_lines_radix(code_viewer, radix) -> bool
        @param code_viewer (C++: TWidget *)
        @param radix (C++: int)
    """
    return _ida_kernwin.set_code_viewer_lines_radix(*args)

def set_code_viewer_is_source(*args) -> "bool":
    r"""


    Specify that the given code viewer is used to display source code (
    'ui_set_custom_viewer_handler' ).
    
    set_code_viewer_is_source(code_viewer) -> bool
        @param code_viewer (C++: TWidget *)
    """
    return _ida_kernwin.set_code_viewer_is_source(*args)

def get_tab_size(*args) -> "int":
    r"""


    Get the size of a tab in spaces ( 'ui_get_tab_size' ).
    
    get_tab_size(path) -> int
        @param path: the path of the source view for which the tab size is
                     requested.   if NULL, the default size is returned. (C++:
                     const char *)
    """
    return _ida_kernwin.get_tab_size(*args)

def clr_cancelled(*args) -> "void":
    r"""


    Clear "Cancelled" flag ( 'ui_clr_cancelled' )
    """
    return _ida_kernwin.clr_cancelled(*args)

def set_cancelled(*args) -> "void":
    r"""


    Set "Cancelled" flag ( 'ui_set_cancelled' )
    """
    return _ida_kernwin.set_cancelled(*args)

def user_cancelled(*args) -> "bool":
    r"""


    Test the ctrl-break flag ( 'ui_test_cancelled' ).
    """
    return _ida_kernwin.user_cancelled(*args)

def ui_load_new_file(*args) -> "bool":
    r"""


    Display a load file dialog and load file ( 'ui_load_file' ).
    
    ui_load_new_file(temp_file, filename, pli, neflags, ploaders) -> bool
        @param temp_file: name of the file with the extracted archive member.
                          (C++: qstring  *)
        @param filename: the name of input file as is, library or archive name
                         (C++: qstring  *)
        @param pli: loader input source, may be changed to point to temp_file
                    (C++: linput_t **)
        @param neflags: combination of NEF_... bits (see  Load file flags )
                        (C++: ushort)
        @param ploaders: list of loaders which accept file, may be changed for
                         loaders of temp_file (C++: load_info_t  **)
        @retval: true - file was successfully loaded
        @retval: false - otherwise
    """
    return _ida_kernwin.ui_load_new_file(*args)

def ui_run_debugger(*args) -> "bool":
    r"""


    Load a debugger plugin and run the specified program ( 'ui_run_dbg' ).
    
    ui_run_debugger(dbgopts, exename, argc, argv) -> bool
        @param dbgopts: value of the -r command line switch (C++: const char
                        *)
        @param exename: name of the file to run (C++: const char *)
        @param argc: number of arguments for the executable (C++: int)
        @param argv: argument vector (C++: const char *const *)
        @return: success
    """
    return _ida_kernwin.ui_run_debugger(*args)

def load_dbg_dbginfo(*args) -> "bool":
    r"""


    Load debugging information from a file.
    
    load_dbg_dbginfo(path, li=None, base=BADADDR, verbose=False) -> bool
        @param path: path to file (C++: const char *)
        @param li: loader input. if NULL, check DBG_NAME_KEY (C++: linput_t *)
        @param base: loading address (C++: ea_t)
        @param verbose: dump status to message window (C++: bool)
    """
    return _ida_kernwin.load_dbg_dbginfo(*args)

def add_idc_hotkey(*args) -> "int":
    r"""


    Add hotkey for IDC function ( 'ui_add_idckey' ).
    
    add_idc_hotkey(hotkey, idcfunc) -> int
        @param hotkey: hotkey name (C++: const char *)
        @param idcfunc: IDC function name (C++: const char *)
        @return: IDC hotkey error codes
    """
    return _ida_kernwin.add_idc_hotkey(*args)

def del_idc_hotkey(*args) -> "bool":
    r"""


    Delete IDC function hotkey ( 'ui_del_idckey' ).
    
    del_idc_hotkey(hotkey) -> bool
        @param hotkey: hotkey name (C++: const char *)
        @retval: 1 - ok
        @retval: 0 - failed
    """
    return _ida_kernwin.del_idc_hotkey(*args)

def get_user_strlist_options(*args) -> "void":
    r"""


    get_user_strlist_options(out)
        @param out (C++: strwinsetup_t  *)
    """
    return _ida_kernwin.get_user_strlist_options(*args)

def set_highlight(*args) -> "bool":
    r"""


    Set the highlighted identifier in the viewer ( 'ui_set_highlight' ).
    
    set_highlight(viewer, str, flags) -> bool
        @param viewer: the viewer (C++: TWidget *)
        @param str: the text to match, or NULL to remove current (C++: const
                    char *)
        @param flags: combination of HIF_... bits (see  set_highlightr flags )
                      (C++: int)
        @return: false if an error occurred
    """
    return _ida_kernwin.set_highlight(*args)

def open_exports_window(*args) -> "TWidget *":
    r"""


    Open the exports window ( 'ui_open_builtin' ).
    
    open_exports_window(ea) -> TWidget *
        @param ea: index of entry to select by default (C++: ea_t)
        @return: pointer to resulting window
    """
    return _ida_kernwin.open_exports_window(*args)

def open_imports_window(*args) -> "TWidget *":
    r"""


    Open the exports window ( 'ui_open_builtin' ).
    
    open_imports_window(ea) -> TWidget *
        @param ea: index of entry to select by default (C++: ea_t)
        @return: pointer to resulting window
    """
    return _ida_kernwin.open_imports_window(*args)

def open_names_window(*args) -> "TWidget *":
    r"""


    Open the names window ( 'ui_open_builtin' ).
    
    open_names_window(ea) -> TWidget *
        @param ea: index of entry to select by default (C++: ea_t)
        @return: pointer to resulting window
    """
    return _ida_kernwin.open_names_window(*args)

def open_funcs_window(*args) -> "TWidget *":
    r"""


    Open the functions window ( 'ui_open_builtin' ).
    
    open_funcs_window(ea) -> TWidget *
        @param ea: index of entry to select by default (C++: ea_t)
        @return: pointer to resulting window
    """
    return _ida_kernwin.open_funcs_window(*args)

def open_strings_window(*args) -> "TWidget *":
    r"""


    Open the strings window ( 'ui_open_builtin' ).
    
    open_strings_window(ea, selstart=BADADDR, selend=BADADDR) -> TWidget *
        @param ea: index of entry to select by default (C++: ea_t)
        @param selstart: only display strings that occur within this range
                         (C++: ea_t)
        @param selend: only display strings that occur within this range (C++:
                       ea_t)
        @return: pointer to resulting window
    """
    return _ida_kernwin.open_strings_window(*args)

def open_segments_window(*args) -> "TWidget *":
    r"""


    Open the segments window ( 'ui_open_builtin' ).
    
    open_segments_window(ea) -> TWidget *
        @param ea: index of entry to select by default (C++: ea_t)
        @return: pointer to resulting window
    """
    return _ida_kernwin.open_segments_window(*args)

def open_segregs_window(*args) -> "TWidget *":
    r"""


    Open the segment registers window ( 'ui_open_builtin' ).
    
    open_segregs_window(ea) -> TWidget *
        @param ea: index of entry to select by default (C++: ea_t)
        @return: pointer to resulting window
    """
    return _ida_kernwin.open_segregs_window(*args)

def open_selectors_window(*args) -> "TWidget *":
    r"""


    Open the selectors window ( 'ui_open_builtin' ).
    """
    return _ida_kernwin.open_selectors_window(*args)

def open_signatures_window(*args) -> "TWidget *":
    r"""


    Open the signatures window ( 'ui_open_builtin' ).
    """
    return _ida_kernwin.open_signatures_window(*args)

def open_tils_window(*args) -> "TWidget *":
    r"""


    Open the type libraries window ( 'ui_open_builtin' ).
    """
    return _ida_kernwin.open_tils_window(*args)

def open_loctypes_window(*args) -> "TWidget *":
    r"""


    Open the local types window ( 'ui_open_builtin' ).
    
    open_loctypes_window(ordinal) -> TWidget *
        @param ordinal: ordinal of type to select by default (C++: int)
        @return: pointer to resulting window
    """
    return _ida_kernwin.open_loctypes_window(*args)

def open_calls_window(*args) -> "TWidget *":
    r"""


    Open the function calls window ( 'ui_open_builtin' ).
    
    open_calls_window(ea) -> TWidget *
        @param ea (C++: ea_t)
        @return: pointer to resulting window
    """
    return _ida_kernwin.open_calls_window(*args)

def open_problems_window(*args) -> "TWidget *":
    r"""


    Open the problems window ( 'ui_open_builtin' ).
    
    open_problems_window(ea) -> TWidget *
        @param ea: index of entry to select by default (C++: ea_t)
        @return: pointer to resulting window
    """
    return _ida_kernwin.open_problems_window(*args)

def open_bpts_window(*args) -> "TWidget *":
    r"""


    Open the breakpoints window ( 'ui_open_builtin' ).
    
    open_bpts_window(ea) -> TWidget *
        @param ea: index of entry to select by default (C++: ea_t)
        @return: pointer to resulting window
    """
    return _ida_kernwin.open_bpts_window(*args)

def open_threads_window(*args) -> "TWidget *":
    r"""


    Open the threads window ( 'ui_open_builtin' ).
    """
    return _ida_kernwin.open_threads_window(*args)

def open_modules_window(*args) -> "TWidget *":
    r"""


    Open the modules window ( 'ui_open_builtin' ).
    """
    return _ida_kernwin.open_modules_window(*args)

def open_trace_window(*args) -> "TWidget *":
    r"""


    Open the trace window ( 'ui_open_builtin' ).
    """
    return _ida_kernwin.open_trace_window(*args)

def open_stack_window(*args) -> "TWidget *":
    r"""


    Open the call stack window ( 'ui_open_builtin' ).
    """
    return _ida_kernwin.open_stack_window(*args)

def open_xrefs_window(*args) -> "TWidget *":
    r"""


    Open the cross references window ( 'ui_open_builtin' ).
    
    open_xrefs_window(ea) -> TWidget *
        @param ea: index of entry to select by default (C++: ea_t)
        @return: pointer to resulting window
    """
    return _ida_kernwin.open_xrefs_window(*args)

def open_frame_window(*args) -> "TWidget *":
    r"""


    Open the frame window for the given function ( 'ui_open_builtin' ).
    
    open_frame_window(pfn, offset) -> TWidget *
        @param pfn: function to analyze (C++: func_t  *)
        @param offset: offset where the cursor is placed (C++: uval_t)
        @return: pointer to resulting window if 'pfn' is a valid function and
                 the window was displayed,    NULL otherwise
    """
    return _ida_kernwin.open_frame_window(*args)

def open_navband_window(*args) -> "TWidget *":
    r"""


    Open the navigation band window ( 'ui_open_builtin' ).
    
    open_navband_window(ea, zoom) -> TWidget *
        @param ea: sets the address of the navband arrow (C++: ea_t)
        @param zoom: sets the navband zoom level (C++: int)
        @return: pointer to resulting window
    """
    return _ida_kernwin.open_navband_window(*args)

def open_enums_window(*args) -> "TWidget *":
    r"""


    Open the enums window ( 'ui_open_builtin' ).
    
    open_enums_window(const_id=BADADDR) -> TWidget *
        @param const_id: index of entry to select by default (C++: tid_t)
        @return: pointer to resulting window
    """
    return _ida_kernwin.open_enums_window(*args)

def open_structs_window(*args) -> "TWidget *":
    r"""


    Open the structs window ( 'ui_open_builtin' ).
    
    open_structs_window(id=BADADDR, offset=0) -> TWidget *
        @param id: index of entry to select by default (C++: tid_t)
        @param offset: offset where the cursor is placed (C++: uval_t)
        @return: pointer to resulting window
    """
    return _ida_kernwin.open_structs_window(*args)

def open_disasm_window(*args) -> "TWidget *":
    r"""


    Open a disassembly view ( 'ui_open_builtin' ).
    
    open_disasm_window(window_title, ranges=None) -> TWidget *
        @param window_title: title of view to open (C++: const char *)
        @param ranges: if != NULL, then display a flow chart with the
                       specified ranges (C++: const  rangevec_t  *)
        @return: pointer to resulting window
    """
    return _ida_kernwin.open_disasm_window(*args)

def open_hexdump_window(*args) -> "TWidget *":
    r"""


    Open a hexdump view ( 'ui_open_builtin' ).
    
    open_hexdump_window(window_title) -> TWidget *
        @param window_title: title of view to open (C++: const char *)
        @return: pointer to resulting window
    """
    return _ida_kernwin.open_hexdump_window(*args)

def open_notepad_window(*args) -> "TWidget *":
    r"""


    Open the notepad window ( 'ui_open_builtin' ).
    """
    return _ida_kernwin.open_notepad_window(*args)

def sync_sources(*args) -> "bool":
    r"""


    [Un]synchronize sources
    
    sync_sources(what, _with, sync) -> bool
        @param what (C++: const  sync_source_t  &)
        @param _with (C++: const  sync_source_t  &)
        @param sync (C++: bool)
        @return: success
    """
    return _ida_kernwin.sync_sources(*args)

def choose_til(*args) -> "qstring *":
    r"""


    Choose a type library ( 'ui_choose' , 'chtype_idatil' ).
    """
    return _ida_kernwin.choose_til(*args)

def choose_entry(*args) -> "ea_t":
    r"""


    Choose an entry point ( 'ui_choose' , 'chtype_entry' ).
    
    choose_entry(title) -> ea_t
        @param title: chooser title (C++: const char *)
        @return: ea of selected entry point,  BADADDR  if none selected
    """
    return _ida_kernwin.choose_entry(*args)

def choose_name(*args) -> "ea_t":
    r"""


    Choose a name ( 'ui_choose' , 'chtype_name' ).
    
    choose_name(title) -> ea_t
        @param title: chooser title (C++: const char *)
        @return: ea of selected name,  BADADDR  if none selected
    """
    return _ida_kernwin.choose_name(*args)

def choose_stkvar_xref(*args) -> "ea_t":
    r"""


    Choose an xref to a stack variable ( 'ui_choose' , 'chtype_name' ).
    
    choose_stkvar_xref(pfn, mptr) -> ea_t
        @param pfn: function (C++: func_t  *)
        @param mptr: variable (C++: member_t  *)
        @return: ea of the selected xref, BADADDR if none selected
    """
    return _ida_kernwin.choose_stkvar_xref(*args)

def choose_xref(*args) -> "ea_t":
    r"""


    Choose an xref to an address ( 'ui_choose' , 'chtype_xref' ).
    
    choose_xref(to) -> ea_t
        @param to: referenced address (C++: ea_t)
        @return: ea of selected xref, BADADDR if none selected
    """
    return _ida_kernwin.choose_xref(*args)

def choose_enum(*args) -> "enum_t":
    r"""


    Choose an enum ( 'ui_choose' , 'chtype_enum' ).
    
    choose_enum(title, default_id) -> enum_t
        @param title: chooser title (C++: const char *)
        @param default_id: id of enum to select by default (C++: enum_t)
        @return: enum id of selected enum,  BADNODE  if none selected
    """
    return _ida_kernwin.choose_enum(*args)

def choose_enum_by_value(*args) -> "uchar *":
    r"""


    Choose an enum, restricted by value & size ( 'ui_choose' ,
    'chtype_enum_by_value_and_size' ). If the given value cannot be found
    initially, this function will ask if the user would like to import a
    standard enum.
    
    choose_enum_by_value(title, default_id, value, nbytes) -> enum_t
        @param title: chooser title (C++: const char *)
        @param default_id: id of enum to select by default (C++: enum_t)
        @param value: value to search for (C++: uint64)
        @param nbytes: size of value (C++: int)
        @return: enum id of selected (or imported) enum,  BADNODE  if none was
                 found
    """
    return _ida_kernwin.choose_enum_by_value(*args)

def choose_func(*args) -> "func_t *":
    r"""


    Choose a function ( 'ui_choose' , 'chtype_func' ).
    
    choose_func(title, default_ea) -> func_t *
        @param title: chooser title (C++: const char *)
        @param default_ea: ea of function to select by default (C++: ea_t)
        @return: pointer to function that was selected, NULL if none selected
    """
    return _ida_kernwin.choose_func(*args)

def choose_segm(*args) -> "segment_t *":
    r"""


    Choose a segment ( 'ui_choose' , 'chtype_segm' ).
    
    choose_segm(title, default_ea) -> segment_t *
        @param title: chooser title (C++: const char *)
        @param default_ea: ea of segment to select by default (C++: ea_t)
        @return: pointer to segment that was selected, NULL if none selected
    """
    return _ida_kernwin.choose_segm(*args)

def choose_struc(*args) -> "struc_t *":
    r"""


    Choose a structure ( 'ui_choose' , 'chtype_segm' ).
    
    choose_struc(title) -> struc_t *
        @param title: chooser title; (C++: const char *)
        @return: pointer to structure that was selected, NULL if none selected
    """
    return _ida_kernwin.choose_struc(*args)

def choose_srcp(*args) -> "sreg_range_t *":
    r"""


    Choose a segment register change point ( 'ui_choose' , 'chtype_srcp'
    ).
    
    choose_srcp(title) -> sreg_range_t *
        @param title: chooser title (C++: const char *)
        @return: pointer to segment register range of selected change point,
                 NULL if none selected
    """
    return _ida_kernwin.choose_srcp(*args)

def get_chooser_obj(*args) -> "void *":
    r"""


    Get the underlying object of the specified chooser (
    'ui_get_chooser_obj' ).This is object is chooser-specific.
    
    get_chooser_obj(chooser_caption) -> void *
        @param chooser_caption (C++: const char *)
        @return: the object that was used to create the chooser
    """
    return _ida_kernwin.get_chooser_obj(*args)

def enable_chooser_item_attrs(*args) -> "bool":
    r"""


    Enable item-specific attributes for chooser items (
    'ui_enable_chooser_item_attrs' ). For example: color list items
    differently depending on a criterium.If enabled, the chooser will
    generate ui_get_chooser_item_attrsevents that can be intercepted by a
    plugin to modify the item attributes.This event is generated only in
    the GUI version of IDA.Specifying 'CH_ATTRS' bit at the chooser
    creation time has the same effect.
    
    enable_chooser_item_attrs(chooser_caption, enable) -> bool
        @param chooser_caption (C++: const char *)
        @param enable (C++: bool)
        @return: success
    """
    return _ida_kernwin.enable_chooser_item_attrs(*args)

def replace_wait_box(*args) -> "void":
    r"""


    Replace the label of "Please wait dialog box".
    
    replace_wait_box(format)
        @param format (C++: const char *)
    """
    return _ida_kernwin.replace_wait_box(*args)

def beep(*args) -> "void":
    r"""


    Issue a beeping sound ( 'ui_beep' ).
    
    beep(beep_type=beep_default)
        @param beep_type: beep_t (C++: beep_t)
    """
    return _ida_kernwin.beep(*args)

def display_copyright_warning(*args) -> "bool":
    r"""


    Display copyright warning ( 'ui_copywarn' ).
    """
    return _ida_kernwin.display_copyright_warning(*args)

def ask_for_feedback(*args) -> "void":
    r"""


    Show a message box asking to send the input file tosupport@hex-
    rays.com.
    
    ask_for_feedback(format)
        @param format: the reason why the input file is bad (C++: const char
                       *)
    """
    return _ida_kernwin.ask_for_feedback(*args)

def _ask_addr(*args) -> "ea_t *":
    r"""


    _ask_addr(addr, format) -> bool
        addr: ea_t *
        format: char const *
    """

    import ida_kernwin
#kludge: we can't use %feature("shadow") for top-level
    # functions (see https://github.com/swig/swig/issues/980)
    # Thus we'll %feature("pythonprepend") some code, and return from it,
#making the original code unreachable. Not pretty, but I
#don't have anything better at the moment.
    with ida_kernwin.disabled_script_timeout_t():
        return _ida_kernwin.ask_addr(*args)


    return _ida_kernwin._ask_addr(*args)

def _ask_seg(*args) -> "sel_t *":
    r"""


    _ask_seg(sel, format) -> bool
        sel: sel_t *
        format: char const *
    """

    import ida_kernwin
#kludge: we can't use %feature("shadow") for top-level
    # functions (see https://github.com/swig/swig/issues/980)
    # Thus we'll %feature("pythonprepend") some code, and return from it,
#making the original code unreachable. Not pretty, but I
#don't have anything better at the moment.
    with ida_kernwin.disabled_script_timeout_t():
        return _ida_kernwin.ask_seg(*args)


    return _ida_kernwin._ask_seg(*args)

def _ask_long(*args) -> "sval_t *":
    r"""


    _ask_long(value, format) -> bool
        value: sval_t *
        format: char const *
    """

    import ida_kernwin
#kludge: we can't use %feature("shadow") for top-level
    # functions (see https://github.com/swig/swig/issues/980)
    # Thus we'll %feature("pythonprepend") some code, and return from it,
#making the original code unreachable. Not pretty, but I
#don't have anything better at the moment.
    with ida_kernwin.disabled_script_timeout_t():
        return _ida_kernwin.ask_long(*args)


    return _ida_kernwin._ask_long(*args)

def error(*args) -> "void":
    r"""


    error(format)
    Display a fatal message in a message box and quit IDA
    
    @param format: message to print
    """
    return _ida_kernwin.error(*args)

def warning(*args) -> "void":
    r"""


    warning(format)
    Display a message in a message box
    
    @param message: message to print (formatting is done in Python)
    
    This function can be used to debug IDAPython scripts
    The user will be able to hide messages if they appear twice in a row on
    the screen
    """
    return _ida_kernwin.warning(*args)

def info(*args) -> "void":
    r"""


    info(format)
        @param format (C++: const char *)
    """
    return _ida_kernwin.info(*args)

def nomem(*args) -> "void":
    r"""


    nomem(format)
        @param format (C++: const char *)
    """
    return _ida_kernwin.nomem(*args)
ASKBTN_YES = _ida_kernwin.ASKBTN_YES
"""
Yes button.
"""

ASKBTN_NO = _ida_kernwin.ASKBTN_NO
"""
No button.
"""

ASKBTN_CANCEL = _ida_kernwin.ASKBTN_CANCEL
"""
Cancel button.
"""

ASKBTN_BTN1 = _ida_kernwin.ASKBTN_BTN1
"""
First (Yes) button.
"""

ASKBTN_BTN2 = _ida_kernwin.ASKBTN_BTN2
"""
Second (No) button.
"""

ASKBTN_BTN3 = _ida_kernwin.ASKBTN_BTN3
"""
Third (Cancel) button.
"""


def ask_yn(*args) -> "int":
    r"""


    Display a dialog box and get choice from "Yes", "No", "Cancel".
    
    ask_yn(deflt, format) -> int
        @param deflt: default choice: one of  Button IDs (C++: int)
        @param format: The question in printf() style format (C++: const char
                       *)
        @return: the selected button (one of  Button IDs ). Esc key returns
                 ASKBTN_CANCEL .
    """

    import ida_kernwin
#kludge: we can't use %feature("shadow") for top-level
    # functions (see https://github.com/swig/swig/issues/980)
    # Thus we'll %feature("pythonprepend") some code, and return from it,
#making the original code unreachable. Not pretty, but I
#don't have anything better at the moment.
    with ida_kernwin.disabled_script_timeout_t():
        return _ida_kernwin.ask_yn(*args)


    return _ida_kernwin.ask_yn(*args)

def ask_buttons(*args) -> "int":
    r"""


    Display a dialog box and get choice from maximum three possibilities (
    'ui_ask_buttons' ).for all buttons:use "" or NULL to take the default
    name for the button.use 'format' to hide the cancel button
    
    ask_buttons(Yes, No, Cancel, deflt, format) -> int
        @param Yes: text for the first button (C++: const char *)
        @param No: text for the second button (C++: const char *)
        @param Cancel: text for the third button (C++: const char *)
        @param deflt: default choice: one of  Button IDs (C++: int)
        @param format: printf-style format string for question. It may have
                       some prefixes, see below. (C++: const char *)
        @return: one of  Button IDs  specifying the selected button (Esc key
                 returns Cancel/3rd button value)
    """

    import ida_kernwin
#kludge: we can't use %feature("shadow") for top-level
    # functions (see https://github.com/swig/swig/issues/980)
    # Thus we'll %feature("pythonprepend") some code, and return from it,
#making the original code unreachable. Not pretty, but I
#don't have anything better at the moment.
    with ida_kernwin.disabled_script_timeout_t():
        return _ida_kernwin.ask_buttons(*args)


    return _ida_kernwin.ask_buttons(*args)
HIST_SEG = _ida_kernwin.HIST_SEG
"""
segment names
"""

HIST_CMT = _ida_kernwin.HIST_CMT
"""
comments
"""

HIST_SRCH = _ida_kernwin.HIST_SRCH
"""
search substrings
"""

HIST_IDENT = _ida_kernwin.HIST_IDENT
"""
names
"""

HIST_FILE = _ida_kernwin.HIST_FILE
"""
file names
"""

HIST_TYPE = _ida_kernwin.HIST_TYPE
"""
type declarations
"""

HIST_CMD = _ida_kernwin.HIST_CMD
"""
commands
"""

HIST_DIR = _ida_kernwin.HIST_DIR
"""
directory names (text version only)
"""


def ask_file(*args) -> "char *":
    r"""


    ask_file(for_saving, defval, format) -> char *
        @param for_saving (C++: bool)
        @param defval (C++: const char *)
        @param format (C++: const char *)
    """

    import ida_kernwin
#kludge: we can't use %feature("shadow") for top-level
    # functions (see https://github.com/swig/swig/issues/980)
    # Thus we'll %feature("pythonprepend") some code, and return from it,
#making the original code unreachable. Not pretty, but I
#don't have anything better at the moment.
    with ida_kernwin.disabled_script_timeout_t():
        return _ida_kernwin.ask_file(*args)


    return _ida_kernwin.ask_file(*args)
class addon_info_t(object):
    r"""
    Proxy of C++ addon_info_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    cb = property(_ida_kernwin.addon_info_t_cb_get, _ida_kernwin.addon_info_t_cb_set)
    id = property(_ida_kernwin.addon_info_t_id_get, _ida_kernwin.addon_info_t_id_set)
    name = property(_ida_kernwin.addon_info_t_name_get, _ida_kernwin.addon_info_t_name_set)
    producer = property(_ida_kernwin.addon_info_t_producer_get, _ida_kernwin.addon_info_t_producer_set)
    version = property(_ida_kernwin.addon_info_t_version_get, _ida_kernwin.addon_info_t_version_set)
    url = property(_ida_kernwin.addon_info_t_url_get, _ida_kernwin.addon_info_t_url_set)
    freeform = property(_ida_kernwin.addon_info_t_freeform_get, _ida_kernwin.addon_info_t_freeform_set)
    custom_data = property(_ida_kernwin.addon_info_t_custom_data_get, _ida_kernwin.addon_info_t_custom_data_set)
    custom_size = property(_ida_kernwin.addon_info_t_custom_size_get, _ida_kernwin.addon_info_t_custom_size_set)

    def __init__(self, *args):
        r"""
        __init__(self) -> addon_info_t
        """
        _ida_kernwin.addon_info_t_swiginit(self, _ida_kernwin.new_addon_info_t(*args))
    __swig_destroy__ = _ida_kernwin.delete_addon_info_t

# Register addon_info_t in _ida_kernwin:
_ida_kernwin.addon_info_t_swigregister(addon_info_t)
cvar = _ida_kernwin.cvar


def register_addon(*args) -> "int":
    r"""


    Register an add-on. Show its info in the About box. For plugins,
    should be called from init() function (repeated calls with the same
    product code overwrite previous entries) returns: index of the add-on
    in the list, or -1 on error
    
    register_addon(info) -> int
        @param info (C++: const  addon_info_t  *)
    """
    return _ida_kernwin.register_addon(*args)

def addon_count(*args) -> "int":
    r"""


    Get number of installed addons.
    """
    return _ida_kernwin.addon_count(*args)

def get_addon_info(*args) -> "bool":
    r"""


    Get info about a registered addon with a given product code. info->cb
    must be valid! NB: all pointers are invalidated by next call to
    register_addon or get_addon_info
    
    get_addon_info(id, info) -> bool
        @param id (C++: const char *)
        @param info (C++: addon_info_t  *)
        @return: false if not found
    """
    return _ida_kernwin.get_addon_info(*args)

def get_addon_info_idx(*args) -> "bool":
    r"""


    Get info about a registered addon with specific index. info->cb must
    be valid! NB: all pointers are invalidated by next call to
    register_addon or get_addon_info
    
    get_addon_info_idx(index, info) -> bool
        @param index (C++: int)
        @param info (C++: addon_info_t  *)
        @return: false if index is out of range
    """
    return _ida_kernwin.get_addon_info_idx(*args)
class strarray_t(object):
    r"""
    Proxy of C++ strarray_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    code = property(_ida_kernwin.strarray_t_code_get, _ida_kernwin.strarray_t_code_set)
    text = property(_ida_kernwin.strarray_t_text_get, _ida_kernwin.strarray_t_text_set)

    def __init__(self, *args):
        r"""
        __init__(self) -> strarray_t
        """
        _ida_kernwin.strarray_t_swiginit(self, _ida_kernwin.new_strarray_t(*args))
    __swig_destroy__ = _ida_kernwin.delete_strarray_t

# Register strarray_t in _ida_kernwin:
_ida_kernwin.strarray_t_swigregister(strarray_t)

CLNL_RTRIM = _ida_kernwin.CLNL_RTRIM
"""
Remove trailing space characters.
"""

CLNL_LTRIM = _ida_kernwin.CLNL_LTRIM
"""
Remove leading space characters.
"""

CLNL_FINDCMT = _ida_kernwin.CLNL_FINDCMT
"""
Search for the comment symbol everywhere in the line, not only at the
beginning.
"""

CLNL_TRIM = _ida_kernwin.CLNL_TRIM


def qcleanline(*args) -> "qstring *":
    r"""


    Performs some cleanup operations to a line.
    
    qcleanline(cmt_char='\0', flags=((1 << 0)|(1 << 1))|(1 << 2)) -> str
        @param cmt_char: character that denotes the start of a comment:   the
                         entire text is removed if the line begins with this
                         character (ignoring leading spaces)   all text after
                         (and including) this character is removed if flag
                         CLNL_FINDCMT is set (C++: char)
        @param flags: a combination of  line cleanup flags . defaults to
                      CLNL_TRIM (C++: uint32)
        @return: length of line
    """
    return _ida_kernwin.qcleanline(*args)

def strarray(*args) -> "char const *":
    r"""


    Find a line with the specified code in the 'strarray_t' array. If the
    last element of the array has code==0 then it is considered as the
    default entry.If no default entry exists and the code is not found,
    'strarray()' returns "".
    
    strarray(array, array_size, code) -> char const *
        @param array (C++: const  strarray_t  *)
        @param array_size (C++: size_t)
        @param code (C++: int)
    """
    return _ida_kernwin.strarray(*args)

def ea2str(*args) -> "size_t":
    r"""


    Convert linear address to UTF-8 string.
    
    ea2str(ea) -> str
        @param ea (C++: ea_t)
    """
    return _ida_kernwin.ea2str(*args)
IK_CANCEL = _ida_kernwin.IK_CANCEL

IK_BACK = _ida_kernwin.IK_BACK

IK_TAB = _ida_kernwin.IK_TAB

IK_CLEAR = _ida_kernwin.IK_CLEAR

IK_RETURN = _ida_kernwin.IK_RETURN

IK_SHIFT = _ida_kernwin.IK_SHIFT

IK_CONTROL = _ida_kernwin.IK_CONTROL

IK_MENU = _ida_kernwin.IK_MENU

IK_PAUSE = _ida_kernwin.IK_PAUSE

IK_CAPITAL = _ida_kernwin.IK_CAPITAL

IK_KANA = _ida_kernwin.IK_KANA

IK_ESCAPE = _ida_kernwin.IK_ESCAPE

IK_MODECHANGE = _ida_kernwin.IK_MODECHANGE

IK_SPACE = _ida_kernwin.IK_SPACE

IK_PRIOR = _ida_kernwin.IK_PRIOR

IK_NEXT = _ida_kernwin.IK_NEXT

IK_END = _ida_kernwin.IK_END

IK_HOME = _ida_kernwin.IK_HOME

IK_LEFT = _ida_kernwin.IK_LEFT

IK_UP = _ida_kernwin.IK_UP

IK_RIGHT = _ida_kernwin.IK_RIGHT

IK_DOWN = _ida_kernwin.IK_DOWN

IK_SELECT = _ida_kernwin.IK_SELECT

IK_PRINT = _ida_kernwin.IK_PRINT

IK_EXECUTE = _ida_kernwin.IK_EXECUTE

IK_SNAPSHOT = _ida_kernwin.IK_SNAPSHOT

IK_INSERT = _ida_kernwin.IK_INSERT

IK_DELETE = _ida_kernwin.IK_DELETE

IK_HELP = _ida_kernwin.IK_HELP

IK_LWIN = _ida_kernwin.IK_LWIN

IK_RWIN = _ida_kernwin.IK_RWIN

IK_APPS = _ida_kernwin.IK_APPS

IK_SLEEP = _ida_kernwin.IK_SLEEP

IK_NUMPAD0 = _ida_kernwin.IK_NUMPAD0

IK_NUMPAD1 = _ida_kernwin.IK_NUMPAD1

IK_NUMPAD2 = _ida_kernwin.IK_NUMPAD2

IK_NUMPAD3 = _ida_kernwin.IK_NUMPAD3

IK_NUMPAD4 = _ida_kernwin.IK_NUMPAD4

IK_NUMPAD5 = _ida_kernwin.IK_NUMPAD5

IK_NUMPAD6 = _ida_kernwin.IK_NUMPAD6

IK_NUMPAD7 = _ida_kernwin.IK_NUMPAD7

IK_NUMPAD8 = _ida_kernwin.IK_NUMPAD8

IK_NUMPAD9 = _ida_kernwin.IK_NUMPAD9

IK_MULTIPLY = _ida_kernwin.IK_MULTIPLY

IK_ADD = _ida_kernwin.IK_ADD

IK_SEPARATOR = _ida_kernwin.IK_SEPARATOR

IK_SUBTRACT = _ida_kernwin.IK_SUBTRACT

IK_DECIMAL = _ida_kernwin.IK_DECIMAL

IK_DIVIDE = _ida_kernwin.IK_DIVIDE

IK_F1 = _ida_kernwin.IK_F1

IK_F2 = _ida_kernwin.IK_F2

IK_F3 = _ida_kernwin.IK_F3

IK_F4 = _ida_kernwin.IK_F4

IK_F5 = _ida_kernwin.IK_F5

IK_F6 = _ida_kernwin.IK_F6

IK_F7 = _ida_kernwin.IK_F7

IK_F8 = _ida_kernwin.IK_F8

IK_F9 = _ida_kernwin.IK_F9

IK_F10 = _ida_kernwin.IK_F10

IK_F11 = _ida_kernwin.IK_F11

IK_F12 = _ida_kernwin.IK_F12

IK_F13 = _ida_kernwin.IK_F13

IK_F14 = _ida_kernwin.IK_F14

IK_F15 = _ida_kernwin.IK_F15

IK_F16 = _ida_kernwin.IK_F16

IK_F17 = _ida_kernwin.IK_F17

IK_F18 = _ida_kernwin.IK_F18

IK_F19 = _ida_kernwin.IK_F19

IK_F20 = _ida_kernwin.IK_F20

IK_F21 = _ida_kernwin.IK_F21

IK_F22 = _ida_kernwin.IK_F22

IK_F23 = _ida_kernwin.IK_F23

IK_F24 = _ida_kernwin.IK_F24

IK_NUMLOCK = _ida_kernwin.IK_NUMLOCK

IK_SCROLL = _ida_kernwin.IK_SCROLL

IK_OEM_FJ_MASSHOU = _ida_kernwin.IK_OEM_FJ_MASSHOU

IK_OEM_FJ_TOUROKU = _ida_kernwin.IK_OEM_FJ_TOUROKU

IK_LSHIFT = _ida_kernwin.IK_LSHIFT

IK_RSHIFT = _ida_kernwin.IK_RSHIFT

IK_LCONTROL = _ida_kernwin.IK_LCONTROL

IK_RCONTROL = _ida_kernwin.IK_RCONTROL

IK_LMENU = _ida_kernwin.IK_LMENU

IK_RMENU = _ida_kernwin.IK_RMENU

IK_BROWSER_BACK = _ida_kernwin.IK_BROWSER_BACK

IK_BROWSER_FORWARD = _ida_kernwin.IK_BROWSER_FORWARD

IK_BROWSER_REFRESH = _ida_kernwin.IK_BROWSER_REFRESH

IK_BROWSER_STOP = _ida_kernwin.IK_BROWSER_STOP

IK_BROWSER_SEARCH = _ida_kernwin.IK_BROWSER_SEARCH

IK_BROWSER_FAVORITES = _ida_kernwin.IK_BROWSER_FAVORITES

IK_BROWSER_HOME = _ida_kernwin.IK_BROWSER_HOME

IK_VOLUME_MUTE = _ida_kernwin.IK_VOLUME_MUTE

IK_VOLUME_DOWN = _ida_kernwin.IK_VOLUME_DOWN

IK_VOLUME_UP = _ida_kernwin.IK_VOLUME_UP

IK_MEDIA_NEXT_TRACK = _ida_kernwin.IK_MEDIA_NEXT_TRACK

IK_MEDIA_PREV_TRACK = _ida_kernwin.IK_MEDIA_PREV_TRACK

IK_MEDIA_STOP = _ida_kernwin.IK_MEDIA_STOP

IK_MEDIA_PLAY_PAUSE = _ida_kernwin.IK_MEDIA_PLAY_PAUSE

IK_LAUNCH_MAIL = _ida_kernwin.IK_LAUNCH_MAIL

IK_LAUNCH_MEDIA_SELECT = _ida_kernwin.IK_LAUNCH_MEDIA_SELECT

IK_LAUNCH_APP1 = _ida_kernwin.IK_LAUNCH_APP1

IK_LAUNCH_APP2 = _ida_kernwin.IK_LAUNCH_APP2

IK_OEM_1 = _ida_kernwin.IK_OEM_1

IK_OEM_PLUS = _ida_kernwin.IK_OEM_PLUS

IK_OEM_COMMA = _ida_kernwin.IK_OEM_COMMA

IK_OEM_MINUS = _ida_kernwin.IK_OEM_MINUS

IK_OEM_PERIOD = _ida_kernwin.IK_OEM_PERIOD

IK_OEM_2 = _ida_kernwin.IK_OEM_2

IK_OEM_3 = _ida_kernwin.IK_OEM_3

IK_OEM_4 = _ida_kernwin.IK_OEM_4

IK_OEM_5 = _ida_kernwin.IK_OEM_5

IK_OEM_6 = _ida_kernwin.IK_OEM_6

IK_OEM_7 = _ida_kernwin.IK_OEM_7

IK_OEM_102 = _ida_kernwin.IK_OEM_102

IK_PLAY = _ida_kernwin.IK_PLAY

IK_ZOOM = _ida_kernwin.IK_ZOOM

IK_OEM_CLEAR = _ida_kernwin.IK_OEM_CLEAR

CB_INIT = _ida_kernwin.CB_INIT

CB_YES = _ida_kernwin.CB_YES

CB_CLOSE = _ida_kernwin.CB_CLOSE

CB_INVISIBLE = _ida_kernwin.CB_INVISIBLE

CB_DESTROYING = _ida_kernwin.CB_DESTROYING

class disasm_text_t(object):
    r"""
    Proxy of C++ qvector< disasm_line_t > class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        __init__(self) -> disasm_text_t
            x: qvector< disasm_line_t > const &
        """
        _ida_kernwin.disasm_text_t_swiginit(self, _ida_kernwin.new_disasm_text_t(*args))
    __swig_destroy__ = _ida_kernwin.delete_disasm_text_t

    def push_back(self, *args) -> "disasm_line_t &":
        r"""


        push_back(self, x)
            x: disasm_line_t const &
        """
        return _ida_kernwin.disasm_text_t_push_back(self, *args)

    def pop_back(self, *args) -> "void":
        r"""
        pop_back(self)
        """
        return _ida_kernwin.disasm_text_t_pop_back(self, *args)

    def size(self, *args) -> "size_t":
        r"""
        size(self) -> size_t
        """
        return _ida_kernwin.disasm_text_t_size(self, *args)

    def empty(self, *args) -> "bool":
        r"""
        empty(self) -> bool
        """
        return _ida_kernwin.disasm_text_t_empty(self, *args)

    def at(self, *args) -> "disasm_line_t const &":
        r"""


        at(self, _idx) -> disasm_line_t
            _idx: size_t
        """
        return _ida_kernwin.disasm_text_t_at(self, *args)

    def qclear(self, *args) -> "void":
        r"""
        qclear(self)
        """
        return _ida_kernwin.disasm_text_t_qclear(self, *args)

    def clear(self, *args) -> "void":
        r"""
        clear(self)
        """
        return _ida_kernwin.disasm_text_t_clear(self, *args)

    def resize(self, *args) -> "void":
        r"""


        resize(self, _newsize, x)
            _newsize: size_t
            x: disasm_line_t const &
        

        resize(self, _newsize)
            _newsize: size_t
        """
        return _ida_kernwin.disasm_text_t_resize(self, *args)

    def grow(self, *args) -> "void":
        r"""


        grow(self, x=disasm_line_t())
            x: disasm_line_t const &
        """
        return _ida_kernwin.disasm_text_t_grow(self, *args)

    def capacity(self, *args) -> "size_t":
        r"""
        capacity(self) -> size_t
        """
        return _ida_kernwin.disasm_text_t_capacity(self, *args)

    def reserve(self, *args) -> "void":
        r"""


        reserve(self, cnt)
            cnt: size_t
        """
        return _ida_kernwin.disasm_text_t_reserve(self, *args)

    def truncate(self, *args) -> "void":
        r"""
        truncate(self)
        """
        return _ida_kernwin.disasm_text_t_truncate(self, *args)

    def swap(self, *args) -> "void":
        r"""


        swap(self, r)
            r: qvector< disasm_line_t > &
        """
        return _ida_kernwin.disasm_text_t_swap(self, *args)

    def extract(self, *args) -> "disasm_line_t *":
        r"""
        extract(self) -> disasm_line_t
        """
        return _ida_kernwin.disasm_text_t_extract(self, *args)

    def inject(self, *args) -> "void":
        r"""


        inject(self, s, len)
            s: disasm_line_t *
            len: size_t
        """
        return _ida_kernwin.disasm_text_t_inject(self, *args)

    def begin(self, *args) -> "qvector< disasm_line_t >::const_iterator":
        r"""
        begin(self) -> disasm_line_t
        begin(self) -> disasm_line_t
        """
        return _ida_kernwin.disasm_text_t_begin(self, *args)

    def end(self, *args) -> "qvector< disasm_line_t >::const_iterator":
        r"""
        end(self) -> disasm_line_t
        end(self) -> disasm_line_t
        """
        return _ida_kernwin.disasm_text_t_end(self, *args)

    def insert(self, *args) -> "qvector< disasm_line_t >::iterator":
        r"""


        insert(self, it, x) -> disasm_line_t
            it: qvector< disasm_line_t >::iterator
            x: disasm_line_t const &
        """
        return _ida_kernwin.disasm_text_t_insert(self, *args)

    def erase(self, *args) -> "qvector< disasm_line_t >::iterator":
        r"""


        erase(self, it) -> disasm_line_t
            it: qvector< disasm_line_t >::iterator
        

        erase(self, first, last) -> disasm_line_t
            first: qvector< disasm_line_t >::iterator
            last: qvector< disasm_line_t >::iterator
        """
        return _ida_kernwin.disasm_text_t_erase(self, *args)

    def __len__(self, *args) -> "size_t":
        r"""
        __len__(self) -> size_t
        """
        return _ida_kernwin.disasm_text_t___len__(self, *args)

    def __getitem__(self, *args) -> "disasm_line_t const &":
        r"""


        __getitem__(self, i) -> disasm_line_t
            i: size_t
        """
        return _ida_kernwin.disasm_text_t___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        r"""


        __setitem__(self, i, v)
            i: size_t
            v: disasm_line_t const &
        """
        return _ida_kernwin.disasm_text_t___setitem__(self, *args)

    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator


# Register disasm_text_t in _ida_kernwin:
_ida_kernwin.disasm_text_t_swigregister(disasm_text_t)


#<pycode(py_kernwin)>
DP_LEFT           = 0x0001
"""
Dock src_form to the left of dest_form.
"""
DP_TOP            = 0x0002
"""
Dock src_form above dest_form.
"""
DP_RIGHT          = 0x0004
"""
Dock src_form to the right of dest_form.
"""
DP_BOTTOM         = 0x0008
"""
Dock src_form below dest_form.
"""
DP_INSIDE         = 0x0010
"""
Create a new tab bar with both src_form and dest_form.
"""
# if not before, then it is after
# (use DP_INSIDE | DP_BEFORE to insert a tab before a given tab)
# this flag alone cannot be used to determine orientation
DP_BEFORE         = 0x0020
"""
used with 'DP_INSIDE' .

place src_form before dst_form in the tab bar instead of after
"""
# used with combination of other flags
DP_TAB            = 0x0040
"""
Place src_form into a tab next to dest_form, if dest_form is in a tab
bar (otherwise the same as 'DP_INSIDE' )
"""
DP_FLOATING       = 0x0080
"""
Make src_form floating.
"""

# ----------------------------------------------------------------------
def load_custom_icon(file_name=None, data=None, format=None):
    """


        Loads a custom icon and returns an identifier that can be used with other APIs
    
        If file_name is passed then the other two arguments are ignored.
    
        @param file_name: The icon file name
        @param data: The icon data
        @param format: The icon data format
    
        @return: Icon id or 0 on failure.
                 Use free_custom_icon() to free it
    """
    if file_name is not None:
       return _ida_kernwin.py_load_custom_icon_fn(file_name)
    elif not (data is None and format is None):
       return _ida_kernwin.py_load_custom_icon_data(data, format)
    else:
      return 0

# ----------------------------------------------------------------------
def ask_long(defval, format):
    res, val = _ida_kernwin._ask_long(defval, format)

    if res == 1:
        return val
    else:
        return None

# ----------------------------------------------------------------------
def ask_addr(defval, format):
    res, ea = _ida_kernwin._ask_addr(defval, format)

    if res == 1:
        return ea
    else:
        return None

# ----------------------------------------------------------------------
def ask_seg(defval, format):
    res, sel = _ida_kernwin._ask_seg(defval, format)

    if res == 1:
        return sel
    else:
        return None

# ----------------------------------------------------------------------
def ask_ident(defval, format):
    return ask_str(defval, HIST_IDENT, format)

# ----------------------------------------------------------------------
class action_handler_t(object):
    def __init__(self):
        pass

    def activate(self, ctx):
        return 0

    def update(self, ctx):
        pass

# ----------------------------------------------------------------------
# This provides an alternative to register_action()+attach_action_to_popup_menu()
class quick_widget_commands_t:

    class _cmd_t:
        def __init__(self, caption, flags, menu_index, icon, emb, shortcut):
            self.caption = caption
            self.flags = flags
            self.menu_index = menu_index
            self.icon = icon
            self.emb = emb
            self.shortcut = shortcut

    class _ah_t(action_handler_t):
        def __init__(self, parent, cmd_id):
            action_handler_t.__init__(self)
            self.parent = parent
            self.cmd_id = cmd_id

        def activate(self, ctx):
            self.parent.callback(ctx, self.cmd_id)

        def update(self, ctx):
            return AST_ENABLE_ALWAYS


    def __init__(self, callback):
        self.callback = callback
        self.cmds = []

    def add(self, caption, flags, menu_index, icon, emb, shortcut):
        for idx, cmd in enumerate(self.cmds):
            if cmd.caption == caption:
                return idx
        self.cmds.append(
            quick_widget_commands_t._cmd_t(
                caption, flags, menu_index, icon, emb, shortcut))
        return len(self.cmds) - 1

    def populate_popup(self, widget, popup):
        for idx, cmd in enumerate(self.cmds):
            if (cmd.flags & CHOOSER_POPUP_MENU) != 0:
                desc = action_desc_t(None,
                                     cmd.caption,
                                     quick_widget_commands_t._ah_t(self, idx),
                                     cmd.shortcut,
                                     None,
                                     cmd.icon)
                attach_dynamic_action_to_popup(widget, popup, desc)

class disabled_script_timeout_t(object):
    def __enter__(self):
        import _ida_idaapi
        self.was_timeout = _ida_idaapi.set_script_timeout(0)

    def __exit__(self, type, value, tb):
        import _ida_idaapi
        _ida_idaapi.set_script_timeout(self.was_timeout)

import ida_ida
ida_ida.__wrap_hooks_callback(
    UI_Hooks,
    "database_closed",
    "term",
    lambda cb, *args: cb(*args))


# ----------------------------------------------------------------------
# bw-compat/deprecated. You shouldn't rely on this in new code
from ida_pro import str2user

#</pycode(py_kernwin)>


def choose_find(*args) -> "PyObject *":
    r"""


    choose_find(title) -> PyObject *
        title: char const *
    """
    return _ida_kernwin.choose_find(*args)

def choose_refresh(*args) -> "void":
    r"""


    choose_refresh(_self)
        self: PyObject *
    """
    return _ida_kernwin.choose_refresh(*args)

def choose_close(*args) -> "void":
    r"""


    choose_close(_self)
        self: PyObject *
    """
    return _ida_kernwin.choose_close(*args)

def choose_get_widget(*args) -> "TWidget *":
    r"""


    choose_get_widget(_self) -> TWidget *
        self: PyObject *
    """
    return _ida_kernwin.choose_get_widget(*args)

def choose_choose(*args) -> "PyObject *":
    r"""


    choose_choose(_self) -> PyObject *
        self: PyObject *
    """
    return _ida_kernwin.choose_choose(*args)

def choose_activate(*args) -> "void":
    r"""


    choose_activate(_self)
        self: PyObject *
    """
    return _ida_kernwin.choose_activate(*args)

def choose_create_embedded_chobj(*args) -> "PyObject *":
    r"""


    choose_create_embedded_chobj(_self) -> PyObject *
        self: PyObject *
    """
    return _ida_kernwin.choose_create_embedded_chobj(*args)

def get_chooser_data(*args) -> "PyObject *":
    r"""


    Get the text corresponding to the index N in the chooser data. Use -1
    to get the header.
    
    get_chooser_data(chooser_caption, n) -> PyObject *
        @param chooser_caption (C++: const char *)
        @param n (C++: int)
    """
    return _ida_kernwin.get_chooser_data(*args)

#<pycode(py_kernwin_choose)>
import _ida_kernwin

class Choose(object):
    """
    Chooser wrapper class.

    Some constants are defined in this class.
    Please refer to kernwin.hpp for more information.
    """

    CH_MODAL        = _ida_kernwin.CH_MODAL
    """
    Modal chooser
    """

    CH_MULTI        = _ida_kernwin.CH_MULTI
    """
    Allow multi selection.
    Refer the description of the OnInsertLine(), OnDeleteLine(),
    OnEditLine(), OnSelectLine(), OnRefresh(), OnSelectionChange() to
    see a difference between single and multi selection callbacks.
    """

    CH_NOBTNS       = _ida_kernwin.CH_NOBTNS

    CH_ATTRS        = _ida_kernwin.CH_ATTRS

    CH_NOIDB        = _ida_kernwin.CH_NOIDB
    """
    use the chooser even without an open database, same as x0=-2
    """

    CH_FORCE_DEFAULT = _ida_kernwin.CH_FORCE_DEFAULT
    """
    If a non-modal chooser was already open, change selection to the given
    default one
    """

    CH_CAN_INS      = _ida_kernwin.CH_CAN_INS
    """
    allow to insert new items
    """

    CH_CAN_DEL      = _ida_kernwin.CH_CAN_DEL
    """
    allow to delete existing item(s)
    """

    CH_CAN_EDIT     = _ida_kernwin.CH_CAN_EDIT
    """
    allow to edit existing item(s)
    """

    CH_CAN_REFRESH  = _ida_kernwin.CH_CAN_REFRESH
    """
    allow to refresh chooser
    """

    CH_QFLT         =  _ida_kernwin.CH_QFLT
    """
    open with quick filter enabled and focused
    """

    CH_QFTYP_SHIFT  = _ida_kernwin.CH_QFTYP_SHIFT
    CH_QFTYP_DEFAULT     = _ida_kernwin.CH_QFTYP_DEFAULT
    CH_QFTYP_NORMAL      = _ida_kernwin.CH_QFTYP_NORMAL
    CH_QFTYP_WHOLE_WORDS = _ida_kernwin.CH_QFTYP_WHOLE_WORDS
    CH_QFTYP_REGEX       = _ida_kernwin.CH_QFTYP_REGEX
    CH_QFTYP_FUZZY       = _ida_kernwin.CH_QFTYP_FUZZY
    CH_QFTYP_MASK        = _ida_kernwin.CH_QFTYP_MASK

    CH_NO_STATUS_BAR = _ida_kernwin.CH_NO_STATUS_BAR
    """
    don't show a status bar
    """
    CH_RESTORE       = _ida_kernwin.CH_RESTORE
    """
    restore floating position if present (equivalent of WOPN_RESTORE) (GUI version only)
    """

    CH_BUILTIN_SHIFT = _ida_kernwin.CH_BUILTIN_SHIFT
    CH_BUILTIN_MASK = _ida_kernwin.CH_BUILTIN_MASK

    """The chooser can provide a dirtree_t, meaning a tree-like structure
       can be provided to the user (instead of a flat table)"""
    CH_HAS_DIRTREE = _ida_kernwin.CH_HAS_DIRTREE

# column flags (are specified in the widths array)
    CHCOL_PLAIN     = _ida_kernwin.CHCOL_PLAIN
    CHCOL_PATH      = _ida_kernwin.CHCOL_PATH
    CHCOL_HEX       = _ida_kernwin.CHCOL_HEX
    CHCOL_DEC       = _ida_kernwin.CHCOL_DEC
    CHCOL_EA        = _ida_kernwin.CHCOL_EA
    CHCOL_FNAME     = _ida_kernwin.CHCOL_FNAME
    CHCOL_FORMAT    = _ida_kernwin.CHCOL_FORMAT
    CHCOL_DEFHIDDEN = _ida_kernwin.CHCOL_DEFHIDDEN
    CHCOL_DRAGHINT  = _ida_kernwin.CHCOL_DRAGHINT
    CHCOL_INODENAME = _ida_kernwin.CHCOL_INODENAME

# special values of the chooser index
    NO_SELECTION   = -1
    """
    there is no selected item
    """
    EMPTY_CHOOSER  = -2
    """
    the chooser is initialized
    """
    ALREADY_EXISTS = -3
    """
    the non-modal chooser with the same data is already open
    """
    NO_ATTR        = -4
    """
    some mandatory attribute is missing
    """

# return value of ins(), del(), edit(), enter(), refresh() callbacks
    NOTHING_CHANGED   = 0
    ALL_CHANGED       = 1
    SELECTION_CHANGED = 2

# to construct `forbidden_cb`
    CHOOSE_HAVE_INIT    = 0x0001
    CHOOSE_HAVE_GETICON = 0x0002
    CHOOSE_HAVE_GETATTR = 0x0004
    CHOOSE_HAVE_INS     = 0x0008
    CHOOSE_HAVE_DEL     = 0x0010
    CHOOSE_HAVE_EDIT    = 0x0020
    CHOOSE_HAVE_ENTER   = 0x0040
    CHOOSE_HAVE_REFRESH = 0x0080
    CHOOSE_HAVE_SELECT  = 0x0100
    CHOOSE_HAVE_ONCLOSE = 0x0200

    class UI_Hooks_Trampoline(UI_Hooks):
        def __init__(self, v):
            UI_Hooks.__init__(self)
            self.hook()
            import weakref
            self.v = weakref.ref(v)

        def populating_widget_popup(self, widget, popup_handle):
            chooser = self.v()
            if widget == chooser.GetWidget() and \
               hasattr(chooser, "OnPopup") and \
               callable(getattr(chooser, "OnPopup")):
                chooser.OnPopup(widget, popup_handle)

    def __init__(self, title, cols, flags = 0, popup_names = None,
                 icon=-1, x1=-1, y1=-1, x2=-1, y2=-1,
                 deflt = None,
                 embedded = False, width = None, height = None,
                 forbidden_cb = 0):
        """
        Constructs a chooser window.
        @param title: The chooser title
        @param cols: a list of colums; each list item is a list of two items
            example: [ ["Address", 10 | Choose.CHCOL_HEX],
                       ["Name",    30 | Choose.CHCOL_PLAIN] ]
        @param flags: One of CH_XXXX constants
        @param deflt: The index of the default item (0-based) for single
            selection choosers or the list of indexes for multi selection
            chooser
        @param popup_names: List of new captions to replace this list
            ["Insert", "Delete", "Edit", "Refresh"]
        @param icon: Icon index (the icon should exist in ida resources or
            an index to a custom loaded icon)
        @param x1, y1, x2, y2: The default location (for txt-version)
        @param embedded: Create as embedded chooser
        @param width: Embedded chooser width
        @param height: Embedded chooser height
        @param forbidden_cb: Explicitly forbidden callbacks
        """
        self.title = title
        self.flags = flags
        self.cols = cols
        if deflt == None:
          deflt = 0 if (flags & Choose.CH_MULTI) == 0 else [0]
        self.deflt = deflt
        self.popup_names = popup_names
        self.icon = icon
        self.x1 = x1
        self.y1 = y1
        self.x2 = x2
        self.y2 = y2
        self.embedded = embedded
        self.width = width
        self.height = height
        self.forbidden_cb = forbidden_cb
        self.ui_hooks_trampoline = None # set on Show
        def _qccb(ctx, cmd_id):
            for idx in ctx.chooser_selection:
                self.OnCommand(idx, cmd_id)
        self._quick_commands = quick_widget_commands_t(_qccb)


    def Embedded(self, create_chobj=False):
        """
        Creates an embedded chooser (as opposed to Show())
        @return: Returns 0 on success or NO_ATTR
        """
        if not self.embedded:
          return Choose.NO_ATTR
        if create_chobj:
            return _ida_kernwin.choose_create_embedded_chobj(self)
        else:
            return _ida_kernwin.choose_choose(self)


    def GetEmbSelection(self):
        """
        Deprecated. For embedded choosers, the selection is
        available through 'Form.EmbeddedChooserControl.selection'
        """
        return None


    def Show(self, modal=False):
        """
        Activates or creates a chooser window
        @param modal: Display as modal dialog
        @return: For all choosers it will return NO_ATTR if some mandatory
                 attribute is missing. The mandatory attributes are: flags,
                 title, cols, OnGetSize(), OnGetLine();
                 For modal choosers it will return the selected item index (0-based),
                 or NO_SELECTION if no selection,
                 or EMPTY_CHOOSER if the OnRefresh() callback returns EMPTY_CHOOSER;
                 For non-modal choosers it will return 0
                 or ALREADY_EXISTS if the chooser was already open and is active now;
        """
        if self.embedded:
          return Choose.NO_ATTR
# it will be deleted and unhooked in py_choose_t::closed()
        self.ui_hooks_trampoline = self.UI_Hooks_Trampoline(self)
        if modal:
            self.flags |= Choose.CH_MODAL

# Disable the timeout
            with disabled_script_timeout_t():
                n = _ida_kernwin.choose_choose(self)

# Delete the modal chooser instance
            self.Close()

            return n
        else:
            self.flags &= ~Choose.CH_MODAL
            return _ida_kernwin.choose_choose(self)


    def Activate(self):
        """
        Activates a visible chooser
        """
        return _ida_kernwin.choose_activate(self)


    def Refresh(self):
        """
        Causes the refresh callback to trigger
        """
        return _ida_kernwin.choose_refresh(self)


    def Close(self):
        """
        Closes the chooser
        """
        if not self.embedded:
            _ida_kernwin.choose_close(self)

    def GetWidget(self):
        """
        Return the TWidget underlying this view.

        @return: The TWidget underlying this view, or None.
        """
        return _ida_kernwin.choose_get_widget(self)

    def adjust_last_item(self, n):
        """
        Helper for OnDeleteLine() and OnRefresh() callbacks.
        They can be finished by the following line:
        return [Choose.ALL_CHANGED] + self.adjust_last_item(n)
        @param: line number of the remaining select item
        @return: list of selected lines numbers (one element or empty)
        """
        cnt = self.OnGetSize();
        if cnt == 0:
            return []
# take in account deleting of the last item(s)
        if n >= cnt:
            n = cnt - 1
        return [n]

    def AddCommand(self,
                   caption,
                   flags = _ida_kernwin.CHOOSER_POPUP_MENU,
                   menu_index = -1,
                   icon = -1,
                   emb=None,
                   shortcut=None):
        return self._quick_commands.add(
            caption=caption,
            flags=flags,
            menu_index=menu_index,
            icon=icon,
            emb=emb,
            shortcut=shortcut)

    def OnPopup(self, widget, popup_handle):
        self._quick_commands.populate_popup(widget, popup_handle)

#</pycode(py_kernwin_choose)>


def textctrl_info_t_assign(*args) -> "bool":
    r"""


    textctrl_info_t_assign(_self, other) -> bool
        self: PyObject *
        other: PyObject *
    """
    return _ida_kernwin.textctrl_info_t_assign(*args)

def textctrl_info_t_set_text(*args) -> "bool":
    r"""


    textctrl_info_t_set_text(_self, s) -> bool
        self: PyObject *
        s: char const *
    """
    return _ida_kernwin.textctrl_info_t_set_text(*args)

def textctrl_info_t_get_text(*args) -> "char const *":
    r"""


    textctrl_info_t_get_text(_self) -> char const *
        self: PyObject *
    """
    return _ida_kernwin.textctrl_info_t_get_text(*args)

def textctrl_info_t_set_flags(*args) -> "bool":
    r"""


    textctrl_info_t_set_flags(_self, flags) -> bool
        self: PyObject *
        flags: unsigned int
    """
    return _ida_kernwin.textctrl_info_t_set_flags(*args)

def textctrl_info_t_get_flags(*args) -> "unsigned int":
    r"""


    textctrl_info_t_get_flags(_self) -> unsigned int
        self: PyObject *
    """
    return _ida_kernwin.textctrl_info_t_get_flags(*args)

def textctrl_info_t_set_tabsize(*args) -> "bool":
    r"""


    textctrl_info_t_set_tabsize(_self, tabsize) -> bool
        self: PyObject *
        tabsize: unsigned int
    """
    return _ida_kernwin.textctrl_info_t_set_tabsize(*args)

def textctrl_info_t_get_tabsize(*args) -> "unsigned int":
    r"""


    textctrl_info_t_get_tabsize(_self) -> unsigned int
        self: PyObject *
    """
    return _ida_kernwin.textctrl_info_t_get_tabsize(*args)

def formchgcbfa_enable_field(*args) -> "bool":
    r"""


    formchgcbfa_enable_field(p_fa, fid, enable) -> bool
        p_fa: size_t
        fid: int
        enable: bool
    """
    return _ida_kernwin.formchgcbfa_enable_field(*args)

def formchgcbfa_show_field(*args) -> "bool":
    r"""


    formchgcbfa_show_field(p_fa, fid, show) -> bool
        p_fa: size_t
        fid: int
        show: bool
    """
    return _ida_kernwin.formchgcbfa_show_field(*args)

def formchgcbfa_move_field(*args) -> "bool":
    r"""


    formchgcbfa_move_field(p_fa, fid, x, y, w, h) -> bool
        p_fa: size_t
        fid: int
        x: int
        y: int
        w: int
        h: int
    """
    return _ida_kernwin.formchgcbfa_move_field(*args)

def formchgcbfa_get_focused_field(*args) -> "int":
    r"""


    formchgcbfa_get_focused_field(p_fa) -> int
        p_fa: size_t
    """
    return _ida_kernwin.formchgcbfa_get_focused_field(*args)

def formchgcbfa_set_focused_field(*args) -> "bool":
    r"""


    formchgcbfa_set_focused_field(p_fa, fid) -> bool
        p_fa: size_t
        fid: int
    """
    return _ida_kernwin.formchgcbfa_set_focused_field(*args)

def formchgcbfa_refresh_field(*args) -> "void":
    r"""


    formchgcbfa_refresh_field(p_fa, fid)
        p_fa: size_t
        fid: int
    """
    return _ida_kernwin.formchgcbfa_refresh_field(*args)

def formchgcbfa_close(*args) -> "void":
    r"""


    formchgcbfa_close(p_fa, close_normally)
        p_fa: size_t
        close_normally: int
    """
    return _ida_kernwin.formchgcbfa_close(*args)

def formchgcbfa_get_field_value(*args) -> "PyObject *":
    r"""


    formchgcbfa_get_field_value(p_fa, fid, ft, sz) -> PyObject *
        p_fa: size_t
        fid: int
        ft: int
        sz: size_t
    """
    return _ida_kernwin.formchgcbfa_get_field_value(*args)

def formchgcbfa_set_field_value(*args) -> "bool":
    r"""


    formchgcbfa_set_field_value(p_fa, fid, ft, py_val) -> bool
        p_fa: size_t
        fid: int
        ft: int
        py_val: PyObject *
    """
    return _ida_kernwin.formchgcbfa_set_field_value(*args)

def py_get_ask_form(*args) -> "size_t":
    r"""
    py_get_ask_form() -> size_t
    """
    return _ida_kernwin.py_get_ask_form(*args)

def py_get_open_form(*args) -> "size_t":
    r"""
    py_get_open_form() -> size_t
    """
    return _ida_kernwin.py_get_open_form(*args)

def py_register_compiled_form(*args) -> "void":
    r"""


    py_register_compiled_form(py_form)
        py_form: PyObject *
    """
    return _ida_kernwin.py_register_compiled_form(*args)

def py_unregister_compiled_form(*args) -> "void":
    r"""


    py_unregister_compiled_form(py_form)
        py_form: PyObject *
    """
    return _ida_kernwin.py_unregister_compiled_form(*args)

#<pycode(py_kernwin_askform)>
import sys

import ida_idaapi, _ida_idaapi
import ida_pro

#ICON WARNING|QUESTION|INFO|NONE
#AUTOHIDE NONE|DATABASE|REGISTRY|SESSION
#HIDECANCEL
#BUTTON YES|NO|CANCEL "Value|NONE"
#STARTITEM {id:ItemName}
#HELP / ENDHELP
try:
    import types
    import ctypes
# On Windows, we use stdcall

# Callback for buttons
# typedef int (idaapi *buttoncb_t)(int button_code, form_actions_t &fa);

    _BUTTONCB_T = ctypes.WINFUNCTYPE(ctypes.c_int, ctypes.c_int, ctypes.c_void_p)

# Callback for form change
# typedef int (idaapi *formchgcb_t)(int field_id, form_actions_t &fa);
    _FORMCHGCB_T = ctypes.WINFUNCTYPE(ctypes.c_int, ctypes.c_int, ctypes.c_void_p)
except:
    try:
        _BUTTONCB_T = ctypes.CFUNCTYPE(ctypes.c_int, ctypes.c_int, ctypes.c_void_p)
        _FORMCHGCB_T = ctypes.CFUNCTYPE(ctypes.c_int, ctypes.c_int, ctypes.c_void_p)
    except:
        _BUTTONCB_T = _FORMCHGCB_T = None


# -----------------------------------------------------------------------
# textctrl_info_t clinked object
class textctrl_info_t(ida_idaapi.py_clinked_object_t):
    """
    Class representing textctrl_info_t
    """

# Some constants
    TXTF_AUTOINDENT = 0x0001
    """
    Auto-indent on new line
    """
    TXTF_ACCEPTTABS = 0x0002
    """
    Tab key inserts 'tabsize' spaces
    """
    TXTF_READONLY   = 0x0004
    """
    Text cannot be edited (but can be selected and copied)
    """
    TXTF_SELECTED   = 0x0008
    """
    Shows the field with its text selected
    """
    TXTF_MODIFIED   = 0x0010
    """
    Gets/sets the modified status
    """
    TXTF_FIXEDFONT  = 0x0020
    """
    The control uses IDA's fixed font
    """

    def __init__(self, text="", flags=0, tabsize=0):
        ida_idaapi.py_clinked_object_t.__init__(self)
        if text:
            self.text = text
        if flags:
            self.flags = flags
        if tabsize:
            self.tabsize = tabsize

    def _create_clink(self):
        return _ida_kernwin.textctrl_info_t_create()

    def _del_clink(self, lnk):
        return _ida_kernwin.textctrl_info_t_destroy(lnk)

    def _get_clink_ptr(self):
        return _ida_kernwin.textctrl_info_t_get_clink_ptr(self)

    def assign(self, other):
        """
        Copies the contents of 'other' to 'self'
        """
        return _ida_kernwin.textctrl_info_t_assign(self, other)

    def __set_text(self, s):
        """
        Sets the text value
        """
        return _ida_kernwin.textctrl_info_t_set_text(self, s)

    def __get_text(self):
        """
        Sets the text value
        """
        return _ida_kernwin.textctrl_info_t_get_text(self)

    def __set_flags__(self, flags):
        """
        Sets the flags value
        """
        return _ida_kernwin.textctrl_info_t_set_flags(self, flags)

    def __get_flags__(self):
        """
        Returns the flags value
        """
        return _ida_kernwin.textctrl_info_t_get_flags(self)

    def __set_tabsize__(self, tabsize):
        """
        Sets the tabsize value
        """
        return _ida_kernwin.textctrl_info_t_set_tabsize(self, tabsize)

    def __get_tabsize__(self):
        """
        Returns the tabsize value
        """
        return _ida_kernwin.textctrl_info_t_get_tabsize(self)

    value   = property(__get_text, __set_text)
    """
    Alias for the text property
    """
    text    = property(__get_text, __set_text)
    """
    Text value
    """
    flags   = property(__get_flags__, __set_flags__)
    """
    Flags value
    """
    tabsize = property(__get_tabsize__, __set_tabsize__)

# -----------------------------------------------------------------------
class Form(object):

    FT_ASCII = 'A'
    """
    Ascii string - char *
    """
    FT_SEG = 'S'
    """
    Segment - sel_t *
    """
    FT_HEX = 'N'
    """
    Hex number - uval_t *
    """
    FT_SHEX = 'n'
    """
    Signed hex number - sval_t *
    """
    FT_COLOR = 'K'
    """
    Color button - bgcolor_t *
    """
    FT_ADDR = '$'
    """
    Address - ea_t *
    """
    FT_UINT64 = 'L'
    """
    default base uint64 - uint64
    """
    FT_INT64 = 'l'
    """
    default base int64 - int64
    """
    FT_RAWHEX = 'M'
    """
    Hex number, no 0x prefix - uval_t *
    """
    FT_FILE = 'f'
    """
    File browse - char * at least QMAXPATH
    """
    FT_DEC = 'D'
    """
    Decimal number - sval_t *
    """
    FT_OCT = 'O'
    """
    Octal number, C notation - sval_t *
    """
    FT_BIN = 'Y'
    """
    Binary number, 0b prefix - sval_t *
    """
    FT_CHAR = 'H'
    """
    Char value -- sval_t *
    """
    FT_IDENT = 'I'
    """
    Identifier - char * at least MAXNAMELEN
    """
    FT_BUTTON = 'B'
    """
    Button - def handler(code)
    """
    FT_DIR = 'F'
    """
    Path to directory - char * at least QMAXPATH
    """
    FT_TYPE = 'T'
    """
    Type declaration - char * at least MAXSTR
    """
    _FT_USHORT = '_US'
    """
    Unsigned short
    """
    FT_FORMCHG = '%/'
    """
    Form change callback - formchgcb_t
    """
    FT_ECHOOSER = 'E'
    """
    Embedded chooser - idaapi.Choose
    """
    FT_MULTI_LINE_TEXT = 't'
    """
    Multi text control - textctrl_info_t
    """
    FT_DROPDOWN_LIST   = 'b'
    """
    Dropdown list control - Form.DropdownControl
    """
    FT_HTML_LABEL = 'h'
    """
    HTML label to display (only for GUI version, and for dynamic labels; no input)
    """

    FT_CHKGRP = 'C'
    FT_CHKGRP2= 'c'
    FT_RADGRP = 'R'
    FT_RADGRP2= 'r'

    @staticmethod
    def create_string_buffer(value, size=None):
        if value is None:
            assert(size is not None)
            return ctypes.create_string_buffer(size)
        else:
            if sys.version_info.major >= 3:
                return ctypes.create_string_buffer(value.encode("UTF-8"), size)
            else:
                return ctypes.create_string_buffer(value, size)

    @staticmethod
    def fieldtype_to_ctype(tp, i64 = False):
        """
        Factory method returning a ctype class corresponding to the field type string
        """
        if tp in (Form.FT_SEG, Form.FT_HEX, Form.FT_RAWHEX, Form.FT_ADDR):
            return ctypes.c_ulonglong if i64 else ctypes.c_ulong
        elif tp in (Form.FT_SHEX, Form.FT_DEC, Form.FT_OCT, Form.FT_BIN, Form.FT_CHAR):
            return ctypes.c_longlong if i64 else ctypes.c_long
        elif tp == Form.FT_UINT64:
            return ctypes.c_ulonglong
        elif tp == Form.FT_INT64:
            return ctypes.c_longlong
        elif tp == Form.FT_COLOR:
            return ctypes.c_ulong
        elif tp == Form._FT_USHORT:
            return ctypes.c_ushort
        elif tp in (Form.FT_FORMCHG, Form.FT_ECHOOSER):
            return ctypes.c_void_p
        else:
            return None


#
# Generic argument helper classes
#
    class NumericArgument(object):
        """
        Argument representing various integer arguments (ushort, uint32, uint64, etc...)
        @param tp: One of Form.FT_XXX
        """
        DefI64 = False
        def __init__(self, tp, value):
            cls = Form.fieldtype_to_ctype(tp, self.DefI64)
            if cls is None:
                raise TypeError("Invalid numeric field type: %s" % tp)
# Get a pointer type to the ctype type
            self.arg = ctypes.pointer(cls(value))

        def __set_value(self, v):
            self.arg.contents.value = v
        value = property(lambda self: self.arg.contents.value, __set_value)


    class StringArgument(object):
        """
        Argument representing a character buffer
        """
        def __init__(self, size=None, value=None):
            if size is None:
                raise SyntaxError("The string size must be passed")
            if isinstance(size, str):
                value, size = size, None
            self.size = size
            self.arg = Form.create_string_buffer(value, size)

        def __get_value(self):
            return self.arg.value.decode("UTF-8")

        def __set_value(self, v):
            self.arg.value = v.encode("UTF-8")
        value = property(__get_value, __set_value)


#
# Base control class
#
    class Control(object):
        def __init__(self):
            self.id = 0
            """
            Automatically assigned control ID
            """

            self.input_field_index = None
            """
            If this control is an input field, once Compile() returns this will hold its index. This is used only to compute the possible STARTITEM index
            """

            self.arg = None
            """
            Control argument value. This could be one element or a list/tuple (for multiple args per control)
            """

            self.form = None
            """
            Reference to the parent form. It is filled by Form.Add()
            """

            self.form_hasattr = False

        def get_tag(self):
            """
            Control tag character. One of Form.FT_XXXX.
            The form class will expand the {} notation and replace them with the tags
            """
            pass

        def get_arg(self):
            """
            Control returns the parameter to be pushed on the stack
            (Of ask_form())
            """
            return self.arg

        def free(self):
            """
            Free the control
            """
# Release the parent form reference
            self.form = None

        def is_input_field(self):
            """
            Return True if this field acts as an input
            """
            return False

#
# Label controls
#
    class LabelControl(Control):
        """
        Base class for static label control
        """
        def __init__(self, tp):
            Form.Control.__init__(self)
            self.tp = tp

        def get_tag(self):
            return '%%%d%s' % (self.id, self.tp)


    class StringLabel(LabelControl):
        """
        String label control
        """
        def __init__(self, value, tp=None, size=ida_pro.MAXSTR):
            """
            Type field can be one of:
            A - ascii string
            T - type declaration
            I - ident
            F - folder
            f - file
            X - command
            """
            if tp is None:
                tp = Form.FT_ASCII
            Form.LabelControl.__init__(self, tp)
            self.size = size
            self.arg = Form.create_string_buffer(value, size)


    class NumericLabel(LabelControl, NumericArgument):
        """
        Numeric label control
        """
        def __init__(self, value, tp=None):
            if tp is None:
                tp = Form.FT_HEX
            Form.LabelControl.__init__(self, tp)
            Form.NumericArgument.__init__(self, tp, value)


#
# Group controls
#
    class GroupItemControl(Control):
        """
        Base class for group control items
        """
        def __init__(self, tag, parent):
            Form.Control.__init__(self)
            self.tag = tag
            self.parent = parent
# Item position (filled when form is compiled)
            self.pos = 0

        def assign_pos(self):
            self.pos = self.parent.next_child_pos()

        def get_tag(self):
            return "%s%d" % (self.tag, self.id)

        def is_input_field(self):
            return True


    class ChkGroupItemControl(GroupItemControl):
        """
        Checkbox group item control
        """
        def __init__(self, tag, parent):
            Form.GroupItemControl.__init__(self, tag, parent)

        def __get_value(self):
            return (self.parent.value & (1 << self.pos)) != 0

        def __set_value(self, v):
            pv = self.parent.value
            if v:
                pv = pv | (1 << self.pos)
            else:
                pv = pv & ~(1 << self.pos)

            self.parent.value = pv

        checked = property(__get_value, __set_value)
        """
        Get/Sets checkbox item check status
        """


    class RadGroupItemControl(GroupItemControl):
        """
        Radiobox group item control
        """
        def __init__(self, tag, parent):
            Form.GroupItemControl.__init__(self, tag, parent)

        def __get_value(self):
            return self.parent.value == self.pos

        def __set_value(self, v):
            self.parent.value = self.pos

        selected = property(__get_value, __set_value)
        """
        Get/Sets radiobox item selection status
        """


    class GroupControl(Control, NumericArgument):
        """
        Base class for group controls
        """
        def __init__(self, children_names, tag, value=0):
            Form.Control.__init__(self)
            self.children_names = children_names
            self.tag = tag
            self._reset()
            Form.NumericArgument.__init__(self, Form._FT_USHORT, value)

        def _reset(self):
            self.childpos = 0

        def next_child_pos(self):
            v = self.childpos
            self.childpos += 1
            return v

        def get_tag(self):
            return "%d" % self.id


    class ChkGroupControl(GroupControl):
        """
        Checkbox group control class.
        It holds a set of checkbox controls
        """
        ItemClass = None
        """
        Group control item factory class instance
        We need this because later we won't be treating ChkGroupControl or RadGroupControl
        individually, instead we will be working with GroupControl in general.
        """
        def __init__(self, children_names, value=0, secondary=False):
# Assign group item factory class
            if Form.ChkGroupControl.ItemClass is None:
                Form.ChkGroupControl.ItemClass = Form.ChkGroupItemControl

            Form.GroupControl.__init__(
                self,
                children_names,
                Form.FT_CHKGRP2 if secondary else Form.FT_CHKGRP,
                value)


    class RadGroupControl(GroupControl):
        """
        Radiobox group control class.
        It holds a set of radiobox controls
        """
        ItemClass = None
        def __init__(self, children_names, value=0, secondary=False):
            """
            Creates a radiogroup control.
            @param children_names: A tuple containing group item names
            @param value: Initial selected radio item
            @param secondory: Allows rendering one the same line as the previous group control.
                              Use this if you have another group control on the same line.
            """
# Assign group item factory class
            if Form.RadGroupControl.ItemClass is None:
                Form.RadGroupControl.ItemClass = Form.RadGroupItemControl

            Form.GroupControl.__init__(
                self,
                children_names,
                Form.FT_RADGRP2 if secondary else Form.FT_RADGRP,
                value)


#
# Input controls
#
    class InputControl(Control):
        """
        Generic form input control.
        It could be numeric control, string control, directory/file browsing, etc...
        """
        def __init__(self, tp, width, swidth, hlp = None):
            """
            @param width: Display width
            @param swidth: String width
            """
            Form.Control.__init__(self)
            self.tp = tp
            self.width = width
            self.switdh = swidth
            self.hlp = hlp

        def get_tag(self):
            return "%s%d:%s:%s:%s" % (
                self.tp, self.id,
                self.width,
                self.switdh,
                ":" if self.hlp is None else self.hlp)

        def is_input_field(self):
            return True


    class NumericInput(InputControl, NumericArgument):
        """
        A composite class serving as a base numeric input control class
        """
        def __init__(self, tp=None, value=0, width=50, swidth=10, hlp=None):
            if tp is None:
                tp = Form.FT_HEX
            Form.InputControl.__init__(self, tp, width, swidth, hlp)
            Form.NumericArgument.__init__(self, self.tp, value)


    class ColorInput(NumericInput):
        """
        Color button input control
        """
        def __init__(self, value = 0):
            """
            @param value: Initial color value in RGB
            """
            Form.NumericInput.__init__(self, tp=Form.FT_COLOR, value=value)


    class StringInput(InputControl, StringArgument):
        """
        Base string input control class.
        This class also constructs a StringArgument
        """
        def __init__(self,
                     tp=None,
                     width=ida_pro.MAXSTR,
                     swidth=40,
                     hlp=None,
                     value=None,
                     size=None):
            """
            @param width: String size. But in some cases it has special meaning. For example in FileInput control.
                          If you want to define the string buffer size then pass the 'size' argument
            @param swidth: Control width
            @param value: Initial value
            @param size: String size
            """
            if tp is None:
                tp = Form.FT_ASCII
            if not size:
                size = width
            Form.InputControl.__init__(self, tp, width, swidth, hlp)
            Form.StringArgument.__init__(self, size=size, value=value)


    class FileInput(StringInput):
        """
        File Open/Save input control
        """
        def __init__(self,
                     width=512,
                     swidth=80,
                     save=False, open=False,
                     hlp=None, value=None):

            if save == open:
                raise ValueError("Invalid mode. Choose either open or save")
            if width < 512:
                raise ValueError("Invalid width. Must be greater than 512.")

# The width field is overloaded in this control and is used
# to denote the type of the FileInput dialog (save or load)
# On the other hand it is passed as is to the StringArgument part
            Form.StringInput.__init__(
                self,
                tp=Form.FT_FILE,
                width="1" if save else "0",
                swidth=swidth,
                hlp=hlp,
                size=width,
                value=value)


    class DirInput(StringInput):
        """
        Directory browsing control
        """
        def __init__(self,
                     width=512,
                     swidth=80,
                     hlp=None,
                     value=None):

            if width < 512:
                raise ValueError("Invalid width. Must be greater than 512.")

            Form.StringInput.__init__(
                self,
                tp=Form.FT_DIR,
                width=width,
                swidth=swidth,
                hlp=hlp,
                size=width,
                value=value)


    class ButtonInput(InputControl):
        """
        Button control.
        A handler along with a 'code' (numeric value) can be associated with the button.
        This way one handler can handle many buttons based on the button code (or in other terms id or tag)
        """
        def __init__(self, handler, code="", swidth="", hlp=None):
            """
            @param handler: Button handler. A callback taking one argument which is the code.
            @param code: A code associated with the button and that is later passed to the handler.
            """
            Form.InputControl.__init__(
                self,
                Form.FT_BUTTON,
                code,
                swidth,
                hlp)
            self.handler = handler
            self.arg = _BUTTONCB_T(self.helper_cb)

        def helper_cb(self, button_code, p_fa):
# Remember the pointer to the forms_action in the parent form
            self.form.p_fa = p_fa

# Call user's handler
            r = self.handler(button_code)
            return 0 if r is None else r

        def is_input_field(self):
            return False


    class FormChangeCb(Control):
        """
        Form change handler.
        This can be thought of like a dialog procedure.
        Everytime a form action occurs, this handler will be called along with the control id.
        The programmer can then call various form actions accordingly:
          - EnableField
          - ShowField
          - MoveField
          - GetFieldValue
          - etc...

        Special control IDs: -1 (The form is initialized) and -2 (Ok has been clicked)

        """
        def __init__(self, handler):
            """
            Constructs the handler.
            @param handler: The handler (preferrably a member function of a class derived from the Form class).
            """
            Form.Control.__init__(self)

# Save the handler
            self.handler = handler

# Create a callback stub
# We use this mechanism to create an intermediate step
# where we can create an 'fa' adapter for use by Python
            self.arg = _FORMCHGCB_T(self.helper_cb)

        def helper_cb(self, fid, p_fa):
# Remember the pointer to the forms_action in the parent form
            self.form.p_fa = p_fa

# Call user's handler
            r = self.handler(fid)
            return 0 if r is None else r

        def get_tag(self):
            return Form.FT_FORMCHG

        def free(self):
            Form.Control.free(self)
# Remove reference to the handler
# (Normally the handler is a member function in the parent form)
            self.handler = None


    class EmbeddedChooserControl(InputControl):
        """
        Embedded chooser control.
        This control links to a Chooser2 control created with the 'embedded=True'
        """
        def __init__(self,
                     chooser=None,
                     swidth=40,
                     hlp=None):
            """
            Embedded chooser control

            @param chooser: A chooser2 instance (must be constructed with 'embedded=True')
            """

# !! Make sure a chooser instance is passed !!
            if chooser is None or not isinstance(chooser, Choose):
                raise ValueError("Invalid chooser passed.")

# Create an embedded chooser structure from the Choose instance,
# and retrieve the pointer to the chooser_base_t.
            emb = chooser.Embedded(create_chobj=True)
# if chooser.Embedded() != 0:
            if emb is None:
                raise ValueError("Failed to create embedded chooser instance.")

# Construct input control
            Form.InputControl.__init__(self, Form.FT_ECHOOSER, "", swidth)

            self.selobj = ida_pro.sizevec_t()

# Get a pointer to the selection vector
            if sys.version_info.major >= 3:
                sel = self.selobj.this.__int__()
            else:
                sel = self.selobj.this.__long__()

# Get a pointer to a c_void_p constructed from an address
            p_embedded = ctypes.pointer(ctypes.c_void_p.from_address(emb))
            p_sel      = ctypes.pointer(ctypes.c_void_p.from_address(sel))

# - Create the embedded chooser info on control creation
# - Do not free the embeded chooser because after we get the args
#   via Compile() the user can still call Execute() which relies
#   on the already computed args
            self.arg   = (p_embedded, p_sel)

# Save chooser instance
            self.chooser = chooser

# Add a bogus 'size' attribute
            self.size = 0


        value = property(lambda self: self.chooser)
        """
        Returns the embedded chooser instance
        """

        def __get_selection__(self):
            if len(self.selobj):
                out = []
                for item in self.selobj:
                    out.append(int(item))
                return out
        selection = property(__get_selection__)
        """
        Returns the selection
        """

        def free(self):
            """
            Frees the embedded chooser data
            """
            self.chooser.Close()
            self.chooser = None
            Form.Control.free(self)


    class DropdownListControl(InputControl, ida_pro._qstrvec_t):
        """
        Dropdown control
        This control allows manipulating a dropdown control
        """
        def __init__(self, items=[], readonly=True, selval=0, width=50, swidth=50, hlp = None):
            """
            @param items: A string list of items used to prepopulate the control
            @param readonly: Specifies whether the dropdown list is editable or not
            @param selval: The preselected item index (when readonly) or text value (when editable)
            @param width: the control width (n/a if the dropdown list is readonly)
            @param swidth: string width
            """

# Ignore the width if readonly was set
            if readonly:
                width = 0

# Init the input control base class
            Form.InputControl.__init__(
                self,
                Form.FT_DROPDOWN_LIST,
                width,
                swidth,
                hlp)

# Init the associated qstrvec
            ida_pro._qstrvec_t.__init__(self, items)

# Remember if readonly or not
            self.readonly = readonly

            if readonly:
# Create a C integer and remember it
                self.__selval = ctypes.c_int(selval)
                val_addr      = ctypes.addressof(self.__selval)
            else:
# Create an strvec with one qstring
                self.__selval = ida_pro._qstrvec_t([selval])
# Get address of the first element
                val_addr      = self.__selval.addressof(0)

# Two arguments:
# - argument #1: a pointer to the qstrvec containing the items
# - argument #2: an integer to hold the selection
#         or
#            #2: a qstring to hold the dropdown text control value
            self.arg = (
                ctypes.pointer(ctypes.c_void_p.from_address(self.clink_ptr)),
                ctypes.pointer(ctypes.c_void_p.from_address(val_addr))
            )


        def __set_selval(self, val):
            if self.readonly:
                self.__selval.value = val
            else:
                self.__selval[0] = val

        def __get_selval(self):
# Return the selection index
# or the entered text value
            return self.__selval.value if self.readonly else self.__selval[0]

        value  = property(__get_selval, __set_selval)
        selval = property(__get_selval, __set_selval)
        """
        Read/write the selection value.
        The value is used as an item index in readonly mode or text value in editable mode
        This value can be used only after the form has been closed.
        """

        def free(self):
            self._free()


        def set_items(self, items):
            """
            Sets the dropdown list items
            """
            self.from_list(items)


    class MultiLineTextControl(InputControl, textctrl_info_t):
        """
        Multi line text control.
        This class inherits from textctrl_info_t. Thus the attributes are also inherited
        This control allows manipulating a multilinetext control
        """
        def __init__(self, text="", flags=0, tabsize=0, width=50, swidth=50, hlp = None):
            """
            @param text: Initial text value
            @param flags: One of textctrl_info_t.TXTF_.... values
            @param tabsize: Tab size
            @param width: Display width
            @param swidth: String width
            """
# Init the input control base class
            Form.InputControl.__init__(self, Form.FT_MULTI_LINE_TEXT, width, swidth, hlp)

# Init the associated textctrl_info base class
            textctrl_info_t.__init__(self, text=text, flags=flags, tabsize=tabsize)

# Get the argument as a pointer from the embedded ti
            self.arg = ctypes.pointer(ctypes.c_void_p.from_address(self.clink_ptr))


        def free(self):
            self._free()


#
# Form class
#
    def __init__(self, form, controls):
        """
        Contruct a Form class.
        This class wraps around ask_form() or open_form() and provides an easier / alternative syntax for describing forms.
        The form control names are wrapped inside the opening and closing curly braces and the control themselves are
        defined and instantiated via various form controls (subclasses of Form).

        @param form: The form string
        @param controls: A dictionary containing the control name as a _key_ and control object as _value_
        """
        self._reset()
        self.form = form
        """
        Form string
        """
        self.controls = controls
        """
        Dictionary of controls
        """
        self.__args = None

        self.title = None
        """
        The Form title. It will be filled when the form is compiled
        """

        self.modal = True
        """
        By default, forms are modal
        """

        self.openform_flags = 0
        """
        If non-modal, these flags will be passed to open_form.
        This is an OR'ed combination of the PluginForm.FORM_* values.
        """


    def Free(self):
        """
        Frees all resources associated with a compiled form.
        Make sure you call this function when you finish using the form.
        """

# Free all the controls
        for name, ctrl in self.__controls.items():
            if ctrl.parent_hasattr:
                delattr(self, name)
                ctrl.parent_hasattr = False
            ctrl.free()

# Reset the controls
# (Note that we are not removing the form control attributes, no need)
        self._reset()

# Unregister, so we don't try and free it again at closing-time.
        _ida_kernwin.py_unregister_compiled_form(self)


    def _reset(self):
        """
        Resets the Form class state variables
        """
        self.__controls = {}
        self.__ctrl_id = 1


    def __getitem__(self, name):
        """
        Returns a control object by name
        """
        return self.__controls[name]


    def Add(self, name, ctrl, mkattr = True):
        """
        Low level function. Prefer AddControls() to this function.
        This function adds one control to the form.

        @param name: Control name
        @param ctrl: Control object
        @param mkattr: Create control name / control object as a form attribute
        """
# Assign a unique ID
        ctrl.id = self.__ctrl_id
        self.__ctrl_id += 1

# Create attribute with control name
        if mkattr:
            setattr(self, name, ctrl)
            ctrl.parent_hasattr = True

# Remember the control
        self.__controls[name] = ctrl

# Link the form to the control via its form attribute
        ctrl.form = self

# Is it a group? Add each child
        if isinstance(ctrl, Form.GroupControl):
            self._AddGroup(ctrl, mkattr)


    def FindControlById(self, id):
        """
        Finds a control instance given its id
        """
        for ctrl in self.__controls.values():
            if ctrl.id == id:
                return ctrl
        return None


    @staticmethod
    def _ParseFormTitle(form):
        """
        Parses the form's title from the form text
        """
        help_state = 0
        for i, line in enumerate(form.split("\n")):
            if line.startswith("STARTITEM ") or line.startswith("BUTTON "):
                continue
# Skip "HELP" and remember state
            elif help_state == 0 and line == "HELP":
                help_state = 1 # Mark inside HELP
                continue
            elif help_state == 1 and line == "ENDHELP":
                help_state = 2 # Mark end of HELP
                continue
            return line.strip()

        return None


    def _AddGroup(self, Group, mkattr=True):
        """
        Internal function.
        This function expands the group item names and creates individual group item controls

        @param Group: The group class (checkbox or radio group class)
        """

# Create group item controls for each child
        for child_name in sorted(Group.children_names):
            self.Add(
                child_name,
# Use the class factory
                Group.ItemClass(Group.tag, Group),
                mkattr)


    def AddControls(self, controls, mkattr=True):
        """
        Adds controls from a dictionary.
        The dictionary key is the control name and the value is a Form.Control object
        @param controls: The control dictionary
        """
        for name in sorted(controls.keys()):
# Add the control
            self.Add(name, controls[name], mkattr)


    def CompileEx(self, form):
        """
        Low level function.
        Compiles (parses the form syntax and adds the control) the form string and
        returns the argument list to be passed the argument list to ask_form().

        The form controls are wrapped inside curly braces: {ControlName}.

        A special operator can be used to return the index of a given control by its name: {id:ControlName}.
        This is useful when you use the STARTITEM form keyword to set the initially focused control.
        (note that, technically, the index is not the same as the ID; that's because STARTITEM
        uses raw, 0-based indexes rather than control IDs to determine the focused widget.)

        @param form: Compiles the form and returns the arguments needed to be passed to ask_form()
        """
# First argument is the form string
        args = [None]

# Second argument, if form is not modal, is the set of flags
        if not self.modal:
            args.append(self.openform_flags | 0x80) # Add FORM_QWIDGET

        ctrlcnt = 1

# Reset all group control internal flags
        for ctrl in self.__controls.values():
            if isinstance(ctrl, Form.GroupControl):
                ctrl._reset()

        def next_control(form, p, first_pass):
            i1 = form.find("{", p)
            if i1 < 0:
                return form, None, None, None
            if form[i1 - 1] == '\\' and i1 > 0:
                if first_pass:
                    return next_control(form, i1 + 1, first_pass)
                else:
# Remove escape sequence and restart search
                    form = form[:i1 - 1] + form[i1:]
                    return next_control(form, i1, first_pass)
            i2 = form.find("}", i1)
            if i2 < 0:
                raise SyntaxError("No matching closing brace '}'")
            ctrlname = form[i1 + 1:i2]
            if not ctrlname:
                raise ValueError("Control %d has an invalid name!" % ctrlcnt)
            return form, i1, i2, ctrlname


        control_count = 0
        last_input_field_index = 0
# First pass: assign input_field_index values to controls
        p = 0
        while True:
            form, i1, i2, ctrlname = next_control(form, p, first_pass=True)
            if ctrlname is None:
                break
            p = i2

            if ctrlname.startswith("id:"):
                continue

            ctrl = self.__controls.get(ctrlname, None)
            if ctrl is None:
                raise ValueError("No matching control '%s'" % ctrlname)

            if isinstance(ctrl, Form.FormChangeCb) and control_count > 0:
                raise SyntaxError("Control '%s' should be the first control in the form" % ctrlname)

# If this control is an input, assign its index
            if ctrl.is_input_field():
                ctrl.input_field_index = last_input_field_index
                last_input_field_index += 1

            control_count += 1


        p = 0
        while True:
            form, i1, i2, ctrlname = next_control(form, p, first_pass=False)
            if ctrlname is None:
                break

# Is it the IDOF operator?
            if ctrlname.startswith("id:"):
                idfunc = True
# Take actual ctrlname
                ctrlname = ctrlname[3:]
            else:
                idfunc = False

# Find the control
            ctrl = self.__controls.get(ctrlname, None)
            if ctrl is None:
                raise ValueError("No matching control '%s'" % ctrlname)

# Replace control name by tag
            if idfunc:
                tag = str(ctrl.input_field_index if ctrl.input_field_index is not None else ctrl.id)
            else:
                tag = ctrl.get_tag()
            taglen = len(tag)
            form = form[:i1] + tag + form[i2+1:]

# Set new position
            p = i1 + taglen

# Was it an IDOF() ? No need to push parameters
# Just ID substitution is fine
            if idfunc:
                continue


# For GroupItem controls, there are no individual arguments
# The argument is assigned for the group itself
            if isinstance(ctrl, Form.GroupItemControl):
# GroupItem controls will have their position dynamically set
                ctrl.assign_pos()
            else:
# Push argument(s)
# (Some controls need more than one argument)
                arg = ctrl.get_arg()
                if isinstance(arg, (list, tuple)):
# Push all args
                    args.extend(arg)
                else:
# Push one arg
                    args.append(arg)

            ctrlcnt += 1

# If no FormChangeCb instance was passed, and thus there's no '%/'
# in the resulting form string, let's provide a minimal one, so that
# we will retrieve 'p_fa', and thus actions that rely on it will work.
        if form.find(Form.FT_FORMCHG) < 0:
            form = form + Form.FT_FORMCHG
            fccb = Form.FormChangeCb(lambda *args: 1)
            self.Add("___dummyfchgcb", fccb)
# Regardless of the actual position of '%/' in the form
# string, a formchange callback _must_ be right after
# the form string.
            if self.modal:
                inspos = 1
            else:
                inspos = 2
            args.insert(inspos, fccb.get_arg())

# Patch in the final form string

        if sys.version_info.major >= 3:
            args[0] = form.encode("UTF-8")
        else:
            args[0] = form

        self.title = self._ParseFormTitle(form)
        return args


    def Compile(self):
        """
        Compiles a form and returns the form object (self) and the argument list.
        The form object will contain object names corresponding to the form elements

        @return: It will raise an exception on failure. Otherwise the return value is ignored
        """

# Reset controls
        self._reset()

# Insert controls
        self.AddControls(self.controls)

# Compile form and get args
        self.__args = self.CompileEx(self.form)

# Register this form, to make sure it will be freed at closing-time.
        _ida_kernwin.py_register_compiled_form(self)

        return (self, self.__args)


    def Compiled(self):
        """
        Checks if the form has already been compiled

        @return: Boolean
        """
        return self.__args is not None


    def _ChkCompiled(self):
        if not self.Compiled():
            raise SyntaxError("Form is not compiled")


    def Execute(self):
        """
        Displays a modal dialog containing the compiled form.
        @return: 1 - ok ; 0 - cancel
        """
        self._ChkCompiled()
        if not self.modal:
            raise SyntaxError("Form is not modal. Open() should be instead")

        return ask_form(*self.__args)


    def Open(self):
        """
        Opens a widget containing the compiled form.
        """
        self._ChkCompiled()
        if self.modal:
            raise SyntaxError("Form is modal. Execute() should be instead")

        open_form(*self.__args)


    def EnableField(self, ctrl, enable):
        """
        Enable or disable an input field
        @return: False - no such control
        """
        return _ida_kernwin.formchgcbfa_enable_field(self.p_fa, ctrl.id, enable)


    def ShowField(self, ctrl, show):
        """
        Show or hide an input field
        @return: False - no such control
        """
        return _ida_kernwin.formchgcbfa_show_field(self.p_fa, ctrl.id, show)


    def MoveField(self, ctrl, x, y, w, h):
        """
        Move/resize an input field

        @return: False - no such fiel
        """
        return _ida_kernwin.formchgcbfa_move_field(self.p_fa, ctrl.id, x, y, w, h)


    def GetFocusedField(self):
        """
        Get currently focused input field.
        @return: None if no field is selected otherwise the control ID
        """
        id = _ida_kernwin.formchgcbfa_get_focused_field(self.p_fa)
        return self.FindControlById(id)


    def SetFocusedField(self, ctrl):
        """
        Set currently focused input field
        @return: False - no such control
        """
        return _ida_kernwin.formchgcbfa_set_focused_field(self.p_fa, ctrl.id)


    def RefreshField(self, ctrl):
        """
        Refresh a field
        @return: False - no such control
        """
        return _ida_kernwin.formchgcbfa_refresh_field(self.p_fa, ctrl.id)


    def Close(self, close_normally):
        """
        Close the form
        @param close_normally:
                   1: form is closed normally as if the user pressed Enter
                   0: form is closed abnormally as if the user pressed Esc
        @return: None
        """
        return _ida_kernwin.formchgcbfa_close(self.p_fa, close_normally)


    def GetControlValue(self, ctrl):
        """
        Returns the control's value depending on its type
        @param ctrl: Form control instance
        @return:
            - color button, radio controls: integer
            - file/dir input, string input and string label: string
            - embedded chooser control (0-based indices of selected items): integer list
            - for multilinetext control: textctrl_info_t
            - dropdown list controls: string (when editable) or index (when readonly)
            - None: on failure
        """
        tid, size = self.ControlToFieldTypeIdAndSize(ctrl)
        r = _ida_kernwin.formchgcbfa_get_field_value(
                    self.p_fa,
                    ctrl.id,
                    tid,
                    size)
# Multilinetext? Unpack the tuple into a new textctrl_info_t instance
        if r is not None and tid == 7:
            return textctrl_info_t(text=r[0], flags=r[1], tabsize=r[2])
        else:
            return r


    def SetControlValue(self, ctrl, value):
        """
        Set the control's value depending on its type
        @param ctrl: Form control instance
        @param value:
            - embedded chooser: a 0-base indices list to select embedded chooser items
            - multilinetext: a textctrl_info_t
            - dropdown list: an integer designating the selection index if readonly
                             a string designating the edit control value if not readonly
        @return: Boolean true on success
        """
        tid, _ = self.ControlToFieldTypeIdAndSize(ctrl)
        return _ida_kernwin.formchgcbfa_set_field_value(
                    self.p_fa,
                    ctrl.id,
                    tid,
                    value)


    @staticmethod
    def ControlToFieldTypeIdAndSize(ctrl):
        """
        Converts a control object to a tuple containing the field id
        and the associated buffer size
        """
# Input control depend on the associated buffer size (supplied by the user)

# Make sure you check instances types taking into account inheritance
        if isinstance(ctrl, Form.DropdownListControl):
            return (8, 1 if ctrl.readonly else 0)
        elif isinstance(ctrl, Form.MultiLineTextControl):
            return (7, 0)
        elif isinstance(ctrl, Form.EmbeddedChooserControl):
            return (5, 0)
# Group items or controls
        elif isinstance(ctrl, (Form.GroupItemControl, Form.GroupControl)):
            return (2, 0)
        elif isinstance(ctrl, Form.StringLabel):
            return (3, min(ida_pro.MAXSTR, ctrl.size))
        elif isinstance(ctrl, Form.ColorInput):
            return (4, 0)
        elif isinstance(ctrl, Form.NumericInput):
# Pass the numeric control type
            return (6, ord(ctrl.tp[0]))
        elif isinstance(ctrl, Form.InputControl):
            return (1, ctrl.size)
        else:
            raise NotImplementedError("Not yet implemented")

# --------------------------------------------------------------------------
# Instantiate ask_form function pointer
try:
    import ctypes
# Setup the numeric argument size
    Form.NumericArgument.DefI64 = _ida_idaapi.BADADDR == 0xFFFFFFFFFFFFFFFF
    __ask_form_callable = ctypes.CFUNCTYPE(ctypes.c_long)(_ida_kernwin.py_get_ask_form())
    __open_form_callable = ctypes.CFUNCTYPE(ctypes.c_long)(_ida_kernwin.py_get_open_form())
except:
    def __ask_form_callable(*args):
        warning("ask_form() needs ctypes library in order to work")
        return 0
    def __open_form_callable(*args):
        warning("open_form() needs ctypes library in order to work")

def __call_form_callable(call, *args):
    assert(len(args))
    with disabled_script_timeout_t():
        if sys.version_info.major >= 3 and isinstance(args[0], str):
            largs = list(args)
            largs[0] = largs[0].encode("UTF-8")
            args = tuple(largs)
        r = call(*args)
    return r

def ask_form(*args):
    return __call_form_callable(__ask_form_callable, *args)

def open_form(*args):
    return __call_form_callable(__open_form_callable, *args)

#</pycode(py_kernwin_askform)>


def install_command_interpreter(*args) -> "int":
    r"""


    Install command line interpreter ( 'ui_install_cli' )
    
    install_command_interpreter(py_obj) -> int
        py_obj: PyObject *
    """
    return _ida_kernwin.install_command_interpreter(*args)

def remove_command_interpreter(*args) -> "void":
    r"""


    Remove command line interpreter ( 'ui_install_cli' )
    
    remove_command_interpreter(cli_idx)
        cli_idx: int
    """
    return _ida_kernwin.remove_command_interpreter(*args)

#<pycode(py_kernwin_cli)>
import ida_idaapi

class cli_t(ida_idaapi.pyidc_opaque_object_t):
    """
    cli_t wrapper class.

    This class allows you to implement your own command line interface handlers.
    """

    def __init__(self):
        self.__cli_idx = -1
        self.__clink__ = None

    def __del__(self):
        self.unregister()

    def register(self, flags = 0, sname = None, lname = None, hint = None):
        """


                Registers the CLI.
        
                @param flags: Feature bits. No bits are defined yet, must be 0
                @param sname: Short name (displayed on the button)
                @param lname: Long name (displayed in the menu)
                @param hint:  Hint for the input line
        
                @return Boolean: True-Success, False-Failed
        """

# Already registered?
        if self.__cli_idx >= 0:
            return True

        if sname is not None: self.sname = sname
        if lname is not None: self.lname = lname
        if hint is not None:  self.hint  = hint

# Register
        self.__cli_idx = _ida_kernwin.install_command_interpreter(self)
        return False if self.__cli_idx < 0 else True

    def unregister(self):
        """
        Unregisters the CLI (if it was registered)
        """
        if self.__cli_idx < 0:
            return False

        _ida_kernwin.remove_command_interpreter(self.__cli_idx)
        self.__cli_idx = -1
        return True

    def OnExecuteLine(self, line):
        """
        The user pressed Enter. The CLI is free to execute the line immediately or ask for more lines.

        This callback is mandatory.

        @param line: typed line(s)
        @return Boolean: True-executed line, False-ask for more lines
        """
        return True

    def OnKeydown(self, line, x, sellen, vkey, shift):
        """
        A keyboard key has been pressed
        This is a generic callback and the CLI is free to do whatever it wants.

        This callback is optional.

        @param line: current input line
        @param x: current x coordinate of the cursor
        @param sellen: current selection length (usually 0)
        @param vkey: virtual key code. if the key has been handled, it should be returned as zero
        @param shift: shift state

        @return:
            None - Nothing was changed
            tuple(line, x, sellen, vkey): if either of the input line or the x coordinate or the selection length has been modified.
            It is possible to return a tuple with None elements to preserve old values. Example: tuple(new_line, None, None, None) or tuple(new_line)
        """
        return None

    def OnCompleteLine(self, prefix, n, line, prefix_start):
        """
        The user pressed Tab. Find a completion number N for prefix PREFIX

        This callback is optional.

        @param prefix: Line prefix at prefix_start (string)
        @param n: completion number (int)
        @param line: the current line (string)
        @param prefix_start: the index where PREFIX starts in LINE (int)

        @return: None if no completion could be generated otherwise a String with the completion suggestion
        """
        return None

#</pycode(py_kernwin_cli)>

class View_Hooks(object):
    r"""
    Proxy of C++ View_Hooks class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        __init__(self, _flags=0) -> View_Hooks
            _flags: uint32
        """
        if self.__class__ == View_Hooks:
            _self = None
        else:
            _self = self
        _ida_kernwin.View_Hooks_swiginit(self, _ida_kernwin.new_View_Hooks(_self, *args))

    def hook(self, *args) -> "bool":
        r"""
        hook(self) -> bool
        """
        return _ida_kernwin.View_Hooks_hook(self, *args)

    def unhook(self, *args) -> "bool":
        r"""
        unhook(self) -> bool
        """
        return _ida_kernwin.View_Hooks_unhook(self, *args)

    def view_activated(self, *args) -> "void":
        r"""


        A view is activated
        
        view_activated(self, view)
            @param view (C++: TWidget *)
        """
        return _ida_kernwin.View_Hooks_view_activated(self, *args)

    def view_deactivated(self, *args) -> "void":
        r"""


        A view is deactivated
        
        view_deactivated(self, view)
            @param view (C++: TWidget *)
        """
        return _ida_kernwin.View_Hooks_view_deactivated(self, *args)

    def view_keydown(self, *args) -> "void":
        r"""


        Key down event
        
        view_keydown(self, view, key, state)
            @param view (C++: TWidget *)
            @param key (C++: int)
            @param state (C++: view_event_state_t)
        """
        return _ida_kernwin.View_Hooks_view_keydown(self, *args)

    def view_click(self, *args) -> "void":
        r"""


        Click event
        
        view_click(self, view, event)
            @param view (C++: TWidget *)
            @param event (C++: const view_mouse_event_t *)
        """
        return _ida_kernwin.View_Hooks_view_click(self, *args)

    def view_dblclick(self, *args) -> "void":
        r"""


        Double click event
        
        view_dblclick(self, view, event)
            @param view (C++: TWidget *)
            @param event (C++: const view_mouse_event_t *)
        """
        return _ida_kernwin.View_Hooks_view_dblclick(self, *args)

    def view_curpos(self, *args) -> "void":
        r"""


        Cursor position changed
        
        view_curpos(self, view)
            @param view (C++: TWidget *)
        """
        return _ida_kernwin.View_Hooks_view_curpos(self, *args)

    def view_created(self, *args) -> "void":
        r"""


        A view is being created.
        
        view_created(self, view)
            @param view (C++: TWidget *)
        """
        return _ida_kernwin.View_Hooks_view_created(self, *args)

    def view_close(self, *args) -> "void":
        r"""


        View closed
        
        view_close(self, view)
            @param view (C++: TWidget *)
        """
        return _ida_kernwin.View_Hooks_view_close(self, *args)

    def view_switched(self, *args) -> "void":
        r"""


        A view's renderer has changed.
        
        view_switched(self, view, rt)
            @param view (C++: TWidget *)
            @param rt (C++: tcc_renderer_type_t)
        """
        return _ida_kernwin.View_Hooks_view_switched(self, *args)

    def view_mouse_over(self, *args) -> "void":
        r"""


        The user moved the mouse over (or out of) a node or an edge. This is
        only relevant in a graph view.
        
        view_mouse_over(self, view, event)
            @param view (C++: TWidget *)
            @param event (C++: const view_mouse_event_t *)
        """
        return _ida_kernwin.View_Hooks_view_mouse_over(self, *args)

    def view_loc_changed(self, *args) -> "void":
        r"""


        The location for the view has changed (can be either the 'place_t' ,
        the 'renderer_info_t' , or both.)
        
        view_loc_changed(self, view, now, was)
            @param view (C++: TWidget *)
            @param now (C++: const lochist_entry_t *)
            @param was (C++: const lochist_entry_t *)
        """
        return _ida_kernwin.View_Hooks_view_loc_changed(self, *args)

    def view_mouse_moved(self, *args) -> "void":
        r"""


        The mouse moved on the view
        
        view_mouse_moved(self, view, event)
            @param view (C++: TWidget *)
            @param event (C++: const view_mouse_event_t *)
        """
        return _ida_kernwin.View_Hooks_view_mouse_moved(self, *args)
    __swig_destroy__ = _ida_kernwin.delete_View_Hooks
    def __disown__(self):
        self.this.disown()
        _ida_kernwin.disown_View_Hooks(self)
        return weakref.proxy(self)

# Register View_Hooks in _ida_kernwin:
_ida_kernwin.View_Hooks_swigregister(View_Hooks)


#<pycode(py_kernwin_viewhooks)>
# -----------------------------------------------------------------------
#                           CustomIDAMemo
# -----------------------------------------------------------------------
class CustomIDAMemo(View_Hooks):
    def __init__(self):
        View_Hooks.__init__(self)

    def _graph_item_tuple(self, ve):
        item = None
        if ve.rtype in [TCCRT_GRAPH, TCCRT_PROXIMITY]:
            item = ve.location.item
        if item is not None:
            if item.is_node:
                return (item.node,)
            else:
                return (item.elp.e.src, item.elp.e.dst)
        else:
            return ()

    @staticmethod
    def _dummy_cb(*args):
        pass

    def _get_cb(self, view, cb_name):
        cb = CustomIDAMemo._dummy_cb
        if view == self.GetWidget():
            cb = getattr(self, cb_name, cb)
        return cb

    def _get_cb_arity(self, cb):
        import sys
        import inspect
        if sys.version_info.major >= 3:
            return len(inspect.getfullargspec(cb).args)
        else:
            return len(inspect.getargspec(cb).args)

    def view_activated(self, view):
        return self._get_cb(view, "OnViewActivated")()

    def view_deactivated(self, view):
        return self._get_cb(view, "OnViewDeactivated")()

    def view_keydown(self, view, key, state):
        return self._get_cb(view, "OnViewKeydown")(key, state)

    def view_click(self, view, ve):
        cb = self._get_cb(view, "OnViewClick")
        if cb != CustomIDAMemo._dummy_cb:
            arity = self._get_cb_arity(cb)
            args = [ve.x, ve.y, ve.state]
            if arity >= 5:
                args.append(ve.button)
                if arity >= 6:
                    args.append(ve.renderer_pos)
            return cb(*tuple(args))

    def view_dblclick(self, view, ve):
        cb = self._get_cb(view, "OnViewDblclick")
        if cb != CustomIDAMemo._dummy_cb:
            arity = self._get_cb_arity(cb)
            args = [ve.x, ve.y, ve.state]
            if arity >= 5:
                args.append(ve.renderer_pos)
            return cb(*tuple(args))

    def view_curpos(self, view, *args):
        return self._get_cb(view, "OnViewCurpos")()

    def view_close(self, view, *args):
        rc = self._get_cb(view, "OnClose")()
        if view == self.GetWidget():
            ida_idaapi.pycim_view_close(self)
        return rc

    def view_switched(self, view, rt):
        return self._get_cb(view, "OnViewSwitched")(rt)

    def view_mouse_over(self, view, ve):
        cb = self._get_cb(view, "OnViewMouseOver")
        if cb != CustomIDAMemo._dummy_cb:
            arity = self._get_cb_arity(cb)
            gitpl = self._graph_item_tuple(ve)
            args = [ve.x, ve.y, ve.state, len(gitpl), gitpl]
            if arity >= 7:
                args.append(ve.renderer_pos)
            return cb(*tuple(args))

    def view_loc_changed(self, view, now, was):
        return self._get_cb(view, "OnViewLocationChanged")(now, was)

    def view_mouse_moved(self, view, ve):
        cb = self._get_cb(view, "OnViewMouseMoved")
        if cb != CustomIDAMemo._dummy_cb:
            gitpl = self._graph_item_tuple(ve)
            return cb(ve.x, ve.y, ve.state, len(gitpl), gitpl, ve.renderer_pos)

# End of hooks->wrapper trampolines


    def Refresh(self):
        """
        Refreshes the view. This causes the OnRefresh() to be called
        """
        ida_idaapi.pygc_refresh(self)

    def GetCurrentRendererType(self):
        return get_view_renderer_type(self.GetWidget())

    def SetCurrentRendererType(self, rtype):
        """
        Set the current view's renderer.

        @param rtype: The renderer type. Should be one of the idaapi.TCCRT_* values.
        """
        return set_view_renderer_type(self.GetWidget(), rtype)

    def SetNodeInfo(self, node_index, node_info, flags):
        """
        Set the properties for the given node.

        Example usage (set second nodes's bg color to red):
          inst = ...
          p = idaapi.node_info_t()
          p.bg_color = 0x00ff0000
          inst.SetNodeInfo(1, p, idaapi.NIF_BG_COLOR)

        @param node_index: The node index.
        @param node_info: An idaapi.node_info_t instance.
        @param flags: An OR'ed value of NIF_* values.
        """
        import ida_graph
        return ida_graph.viewer_set_node_info(self.GetWidget(), node_index, node_info, flags)

    def SetNodesInfos(self, values):
        """
        Set the properties for the given nodes.

        Example usage (set first three nodes's bg color to purple):
          inst = ...
          p = idaapi.node_info_t()
          p.bg_color = 0x00ff00ff
          inst.SetNodesInfos({0 : p, 1 : p, 2 : p})

        @param values: A dictionary of 'int -> node_info_t' objects.
        """
        import ida_graph
        for node_index, node_info in values.items():
            ida_graph.viewer_set_node_info(self.GetWidget(), node_index, node_info, ida_graph.NIF_ALL)

    def GetNodeInfo(self, *args):
        """
        Get the properties for the given node.

        @param ni: A node_info_t instance
        @param node: The index of the node.
        @return: success
        """
        import ida_graph
        if len(args) < 2:
# bw-compat
            ni, node = ida_graph.node_info_t(), args[0]
            if ida_graph.viewer_get_node_info(self.GetWidget(), ni, node):
                return (ni.bg_color, ni.frame_color, ni.ea, ni.text)
            else:
                return None
        else:
            ni, node = args[0], args[1]
            return ida_graph.viewer_get_node_info(self.GetWidget(), ni, node)

    def DelNodesInfos(self, *nodes):
        """
        Delete the properties for the given node(s).

        @param nodes: A list of node IDs
        """
        import ida_graph
        for n in nodes:
            ida_graph.viewer_del_node_info(self.GetWidget(), n)

    def CreateGroups(self, groups_infos):
        """
        Send a request to modify the graph by creating a
        (set of) group(s), and perform an animation.

        Each object in the 'groups_infos' list must be of the format:
        {
          "nodes" : [<int>, <int>, <int>, ...] # The list of nodes to group
          "text" : <string>                    # The synthetic text for that group
        }

        @param groups_infos: A list of objects that describe those groups.
        @return: A [<int>, <int>, ...] list of group nodes, or None (failure).
        """
        return ida_idaapi.pygc_create_groups(self, groups_infos)

    def DeleteGroups(self, groups, new_current = -1):
        """
        Send a request to delete the specified groups in the graph,
        and perform an animation.

        @param groups: A list of group node numbers.
        @param new_current: A node to focus on after the groups have been deleted
        @return: True on success, False otherwise.
        """
        return ida_idaapi.pygc_delete_groups(self, groups, new_current)

    def SetGroupsVisibility(self, groups, expand, new_current = -1):
        """
        Send a request to expand/collapse the specified groups in the graph,
        and perform an animation.

        @param groups: A list of group node numbers.
        @param expand: True to expand the group, False otherwise.
        @param new_current: A node to focus on after the groups have been expanded/collapsed.
        @return: True on success, False otherwise.
        """
        return ida_idaapi.pygc_set_groups_visibility(self, groups, expand, new_current)

    def GetWidget(self):
        """
        Return the TWidget underlying this view.

        @return: The TWidget underlying this view, or None.
        """
        return ida_idaapi.pycim_get_widget(self)

    def GetWidgetAsGraphViewer(self):
        """
        Return the graph_viewer_t underlying this view.

        @return: The graph_viewer_t underlying this view, or None.
        """
        return ida_idaapi.pycim_get_widget_as_graph_viewer(self)

# ----------------------------------------------------------------------
# bw-compat/deprecated. You shouldn't rely on this in new code
import ida_idaapi
ida_idaapi.CustomIDAMemo = CustomIDAMemo

#</pycode(py_kernwin_viewhooks)>


def pyidag_bind(*args) -> "bool":
    r"""


    pyidag_bind(_self) -> bool
        self: PyObject *
    """
    return _ida_kernwin.pyidag_bind(*args)

def pyidag_unbind(*args) -> "bool":
    r"""


    pyidag_unbind(_self) -> bool
        self: PyObject *
    """
    return _ida_kernwin.pyidag_unbind(*args)

#<pycode(py_kernwin_idaview)>
#-------------------------------------------------------------------------
#                             IDAViewWrapper
#-------------------------------------------------------------------------
import _ida_kernwin
class IDAViewWrapper(CustomIDAMemo):
    """
    Deprecated. Use View_Hooks instead.

    Because the lifecycle of an IDAView is not trivial to track (e.g., a user
    might close, then re-open the same disassembly view), this wrapper doesn't
    bring anything superior to the View_Hooks: quite the contrary, as the
    latter is much more generic (and better maps IDA's internal model.)
    """
    def __init__(self, title):
        CustomIDAMemo.__init__(self)
        self._title = title

    def Bind(self):
        rc = _ida_kernwin.pyidag_bind(self)
        if rc:
            self.hook()
        return rc

    def Unbind(self):
        rc = _ida_kernwin.pyidag_unbind(self)
        if rc:
            self.unhook()
        return rc

#</pycode(py_kernwin_idaview)>


def pyscv_init(*args) -> "PyObject *":
    r"""


    pyscv_init(py_link, title) -> PyObject *
        py_link: PyObject *
        title: char const *
    """
    return _ida_kernwin.pyscv_init(*args)

def pyscv_refresh(*args) -> "bool":
    r"""


    pyscv_refresh(py_this) -> bool
        py_this: PyObject *
    """
    return _ida_kernwin.pyscv_refresh(*args)

def pyscv_get_current_line(*args) -> "PyObject *":
    r"""


    pyscv_get_current_line(py_this, mouse, notags) -> PyObject *
        py_this: PyObject *
        mouse: bool
        notags: bool
    """
    return _ida_kernwin.pyscv_get_current_line(*args)

def pyscv_is_focused(*args) -> "bool":
    r"""


    pyscv_is_focused(py_this) -> bool
        py_this: PyObject *
    """
    return _ida_kernwin.pyscv_is_focused(*args)

def pyscv_count(*args) -> "size_t":
    r"""


    pyscv_count(py_this) -> size_t
        py_this: PyObject *
    """
    return _ida_kernwin.pyscv_count(*args)

def pyscv_show(*args) -> "bool":
    r"""


    pyscv_show(py_this) -> bool
        py_this: PyObject *
    """
    return _ida_kernwin.pyscv_show(*args)

def pyscv_close(*args) -> "void":
    r"""


    pyscv_close(py_this)
        py_this: PyObject *
    """
    return _ida_kernwin.pyscv_close(*args)

def pyscv_jumpto(*args) -> "bool":
    r"""


    pyscv_jumpto(py_this, ln, x, y) -> bool
        py_this: PyObject *
        ln: size_t
        x: int
        y: int
    """
    return _ida_kernwin.pyscv_jumpto(*args)

def pyscv_get_line(*args) -> "PyObject *":
    r"""


    pyscv_get_line(py_this, nline) -> PyObject *
        py_this: PyObject *
        nline: size_t
    """
    return _ida_kernwin.pyscv_get_line(*args)

def pyscv_get_pos(*args) -> "PyObject *":
    r"""


    pyscv_get_pos(py_this, mouse) -> PyObject *
        py_this: PyObject *
        mouse: bool
    """
    return _ida_kernwin.pyscv_get_pos(*args)

def pyscv_clear_lines(*args) -> "PyObject *":
    r"""


    pyscv_clear_lines(py_this) -> PyObject *
        py_this: PyObject *
    """
    return _ida_kernwin.pyscv_clear_lines(*args)

def pyscv_add_line(*args) -> "bool":
    r"""


    pyscv_add_line(py_this, py_sl) -> bool
        py_this: PyObject *
        py_sl: PyObject *
    """
    return _ida_kernwin.pyscv_add_line(*args)

def pyscv_insert_line(*args) -> "bool":
    r"""


    pyscv_insert_line(py_this, nline, py_sl) -> bool
        py_this: PyObject *
        nline: size_t
        py_sl: PyObject *
    """
    return _ida_kernwin.pyscv_insert_line(*args)

def pyscv_patch_line(*args) -> "bool":
    r"""


    pyscv_patch_line(py_this, nline, offs, value) -> bool
        py_this: PyObject *
        nline: size_t
        offs: size_t
        value: int
    """
    return _ida_kernwin.pyscv_patch_line(*args)

def pyscv_del_line(*args) -> "bool":
    r"""


    pyscv_del_line(py_this, nline) -> bool
        py_this: PyObject *
        nline: size_t
    """
    return _ida_kernwin.pyscv_del_line(*args)

def pyscv_get_selection(*args) -> "PyObject *":
    r"""


    pyscv_get_selection(py_this) -> PyObject *
        py_this: PyObject *
    """
    return _ida_kernwin.pyscv_get_selection(*args)

def pyscv_get_current_word(*args) -> "PyObject *":
    r"""


    pyscv_get_current_word(py_this, mouse) -> PyObject *
        py_this: PyObject *
        mouse: bool
    """
    return _ida_kernwin.pyscv_get_current_word(*args)

def pyscv_edit_line(*args) -> "bool":
    r"""


    pyscv_edit_line(py_this, nline, py_sl) -> bool
        py_this: PyObject *
        nline: size_t
        py_sl: PyObject *
    """
    return _ida_kernwin.pyscv_edit_line(*args)

def pyscv_get_widget(*args) -> "TWidget *":
    r"""


    pyscv_get_widget(py_this) -> TWidget *
        py_this: PyObject *
    """
    return _ida_kernwin.pyscv_get_widget(*args)

#<pycode(py_kernwin_custview)>
class simplecustviewer_t(object):
    """
    The base class for implementing simple custom viewers
    """

    class UI_Hooks_Trampoline(UI_Hooks):
        def __init__(self, v):
            UI_Hooks.__init__(self)
            self.hook()
            import weakref
            self.v = weakref.ref(v)

        def populating_widget_popup(self, form, popup_handle):
            my_form = self.v().GetWidget()
            if form == my_form:
                cb = self.v().OnPopup
                import sys
                import inspect
                handled = False
                if sys.version_info.major >= 3:
                    if len(inspect.getfullargspec(cb).args) == 3:
                        cb(my_form, popup_handle)
                        handled = True
                else:
                    if len(inspect.getargspec(cb).args) == 3:
                        cb(my_form, popup_handle)
                        handled = True
                if not handled:
                    cb() # bw-compat

    def __init__(self):
        self.__this = None
        self.ui_hooks_trampoline = self.UI_Hooks_Trampoline(self)

    @staticmethod
    def __make_sl_arg(line, fgcolor=None, bgcolor=None):
        return line if (fgcolor is None and bgcolor is None) else (line, fgcolor, bgcolor)

    def OnPopup(self, form, popup_handle):
        """


                Context menu popup is about to be shown. Create items dynamically if you wish
                @return: Boolean. True if you handled the event
        """
        pass

    def Create(self, title):
        """


                Creates the custom view. This should be the first method called after instantiation
        
                @param title: The title of the view
                @return: Boolean whether it succeeds or fails. It may fail if a window with the same title is already open.
                         In this case better close existing windows
        """
        self.title = title
        self.__this = _ida_kernwin.pyscv_init(self, title)
        return True if self.__this else False

    def Close(self):
        """


                Destroys the view.
                One has to call Create() afterwards.
                Show() can be called and it will call Create() internally.
                @return: Boolean
        """
        return _ida_kernwin.pyscv_close(self.__this)

    def Show(self):
        """


                Shows an already created view. It the view was close, then it will call Create() for you
                @return: Boolean
        """
        return _ida_kernwin.pyscv_show(self.__this)

    def Refresh(self):
        return _ida_kernwin.pyscv_refresh(self.__this)

    def RefreshCurrent(self):
        """
        Refreshes the current line only
        """
        return _ida_kernwin.pyscv_refresh(self.__this)

    def Count(self):
        """
        Returns the number of lines in the view
        """
        return _ida_kernwin.pyscv_count(self.__this)

    def GetSelection(self):
        """


                Returns the selected range or None
                @return:
                    - tuple(x1, y1, x2, y2)
                    - None if no selection
        """
        return _ida_kernwin.pyscv_get_selection(self.__this)

    def ClearLines(self):
        """
        Clears all the lines
        """
        _ida_kernwin.pyscv_clear_lines(self.__this)

    def AddLine(self, line, fgcolor=None, bgcolor=None):
        """


                Adds a colored line to the view
                @return: Boolean
        """
        return _ida_kernwin.pyscv_add_line(self.__this, self.__make_sl_arg(line, fgcolor, bgcolor))

    def InsertLine(self, lineno, line, fgcolor=None, bgcolor=None):
        """


                Inserts a line in the given position
                @return: Boolean
        """
        return _ida_kernwin.pyscv_insert_line(self.__this, lineno, self.__make_sl_arg(line, fgcolor, bgcolor))

    def EditLine(self, lineno, line, fgcolor=None, bgcolor=None):
        """


                Edits an existing line.
                @return: Boolean
        """
        return _ida_kernwin.pyscv_edit_line(self.__this, lineno, self.__make_sl_arg(line, fgcolor, bgcolor))

    def PatchLine(self, lineno, offs, value):
        """
        Patches an existing line character at the given offset. This is a low level function. You must know what you're doing
        """
        return _ida_kernwin.pyscv_patch_line(self.__this, lineno, offs, value)

    def DelLine(self, lineno):
        """


                Deletes an existing line
                @return: Boolean
        """
        return _ida_kernwin.pyscv_del_line(self.__this, lineno)

    def GetLine(self, lineno):
        """


                Returns a line
                @param lineno: The line number
                @return:
                    Returns a tuple (colored_line, fgcolor, bgcolor) or None
        """
        return _ida_kernwin.pyscv_get_line(self.__this, lineno)

    def GetCurrentWord(self, mouse = 0):
        """


                Returns the current word
                @param mouse: Use mouse position or cursor position
                @return: None if failed or a String containing the current word at mouse or cursor
        """
        return _ida_kernwin.pyscv_get_current_word(self.__this, mouse)

    def GetCurrentLine(self, mouse = 0, notags = 0):
        """


                Returns the current line.
                @param mouse: Current line at mouse pos
                @param notags: If True then tag_remove() will be called before returning the line
                @return: Returns the current line (colored or uncolored) or None on failure
        """
        return _ida_kernwin.pyscv_get_current_line(self.__this, mouse, notags)

    def GetPos(self, mouse = 0):
        """


                Returns the current cursor or mouse position.
                @param mouse: return mouse position
                @return: Returns a tuple (lineno, x, y)
        """
        return _ida_kernwin.pyscv_get_pos(self.__this, mouse)

    def GetLineNo(self, mouse = 0):
        """
        Calls GetPos() and returns the current line number or -1 on failure
        """
        r = self.GetPos(mouse)
        return -1 if not r else r[0]

    def Jump(self, lineno, x=0, y=0):
        return _ida_kernwin.pyscv_jumpto(self.__this, lineno, x, y)

    def IsFocused(self):
        """
        Returns True if the current view is the focused view
        """
        return _ida_kernwin.pyscv_is_focused(self.__this)

    def GetWidget(self):
        """


                Return the TWidget underlying this view.
        
                @return: The TWidget underlying this view, or None.
        """
        return _ida_kernwin.pyscv_get_widget(self.__this)



# Here are all the supported events
#<pydoc>
#    def OnClick(self, shift):
#        """
#        User clicked in the view
#        @param shift: Shift flag
#        @return: Boolean. True if you handled the event
#        """
#        print("OnClick, shift=%d" % shift)
#        return True
#
#    def OnDblClick(self, shift):
#        """
#        User dbl-clicked in the view
#        @param shift: Shift flag
#        @return: Boolean. True if you handled the event
#        """
#        print("OnDblClick, shift=%d" % shift)
#        return True
#
#    def OnCursorPosChanged(self):
#        """
#        Cursor position changed.
#        @return: Nothing
#        """
#        print("OnCurposChanged")
#
#    def OnClose(self):
#        """
#        The view is closing. Use this event to cleanup.
#        @return: Nothing
#        """
#        print("OnClose")
#
#    def OnKeydown(self, vkey, shift):
#        """
#        User pressed a key
#        @param vkey: Virtual key code
#        @param shift: Shift flag
#        @return: Boolean. True if you handled the event
#        """
#        print("OnKeydown, vk=%d shift=%d" % (vkey, shift))
#        return False
#
#    def OnHint(self, lineno):
#        """
#        Hint requested for the given line number.
#        @param lineno: The line number (zero based)
#        @return:
#            - tuple(number of important lines, hint string)
#            - None: if no hint available
#        """
#        return (1, "OnHint, line=%d" % lineno)
#
#    def OnPopupMenu(self, menu_id):
#        """
#        A context (or popup) menu item was executed.
#        @param menu_id: ID previously registered with add_popup_menu()
#        @return: Boolean
#        """
#        print("OnPopupMenu, menu_id=" % menu_id)
#        return True
#</pydoc>
#</pycode(py_kernwin_custview)>


def plgform_new(*args) -> "PyObject *":
    r"""
    plgform_new() -> PyObject *
    """
    return _ida_kernwin.plgform_new(*args)

def plgform_show(*args) -> "bool":
    r"""


    plgform_show(py_link, py_obj, caption, options=WOPN_DP_TAB|WOPN_RESTORE) -> bool
        py_link: PyObject *
        py_obj: PyObject *
        caption: char const *
        options: int
    """
    return _ida_kernwin.plgform_show(*args)

def plgform_close(*args) -> "void":
    r"""


    plgform_close(py_link, options)
        py_link: PyObject *
        options: int
    """
    return _ida_kernwin.plgform_close(*args)

def plgform_get_widget(*args) -> "TWidget *":
    r"""


    plgform_get_widget(py_link) -> TWidget *
        py_link: PyObject *
    """
    return _ida_kernwin.plgform_get_widget(*args)

#<pycode(py_kernwin_plgform)>
import sys

import ida_idaapi

class PluginForm(object):
    """
    PluginForm class.

    This form can be used to host additional controls. Please check the PyQt example.
    """

    WOPN_MDI      = 0x01 # no-op
    WOPN_TAB      = 0x02 # no-op
    WOPN_RESTORE  = 0x04
    """
    if the widget is the only widget in a floating area when
    it is closed, remember that area's geometry. The next
    time that widget is created as floating (i.e., WOPN_DP_FLOATING)
    its geometry will be restored (e.g., "Execute script"
    """
    WOPN_ONTOP    = 0x08 # no-op
    WOPN_MENU     = 0x10 # no-op
    WOPN_CENTERED = 0x20 # no-op
    WOPN_PERSIST  = 0x40
    """
    form will persist until explicitly closed with Close()
    """
    WOPN_DP_LEFT    = 0x00010000
    """
     Dock widget to the left of dest_ctrl
    """
    WOPN_DP_TOP     = 0x00020000
    """
     Dock widget above dest_ctrl
    """
    WOPN_DP_RIGHT   = 0x00040000
    """
     Dock widget to the right of dest_ctrl
    """
    WOPN_DP_BOTTOM  = 0x00080000
    """
     Dock widget below dest_ctrl
    """
    WOPN_DP_INSIDE  = 0x00100000
    """
     Create a new tab bar with both widget and dest_ctrl
    """
    WOPN_DP_TAB     = 0x00400000
    """
    Place widget into a tab next to dest_ctrl,
    if dest_ctrl is in a tab bar
    (otherwise the same as #WOPN_DP_INSIDE)
    """
    WOPN_DP_BEFORE  = 0x00200000
    """
    place widget before dst_form in the tab bar instead of after
    used with #WOPN_DP_INSIDE and #WOPN_DP_TAB
    """
    WOPN_DP_FLOATING=0x00800000
    """
     Make widget floating
    """
    WOPN_DP_INSIDE_BEFORE = WOPN_DP_INSIDE | WOPN_DP_BEFORE
    WOPN_DP_TAB_BEFORE = WOPN_DP_TAB | WOPN_DP_BEFORE


    WOPN_CREATE_ONLY = {}


    def __init__(self):
        """
        """
        self.__clink__ = _ida_kernwin.plgform_new()


    def Show(self, caption, options=0):
        """


                Creates the form if not was not created or brings to front if it was already created
        
                @param caption: The form caption
                @param options: One of PluginForm.WOPN_ constants
        """
        if options == self.WOPN_CREATE_ONLY:
            options = -1
        else:
            options |= PluginForm.WOPN_DP_TAB|PluginForm.WOPN_RESTORE
        return _ida_kernwin.plgform_show(self.__clink__, self, caption, options)


    @staticmethod
    def _ensure_widget_deps(ctx):
        for modname in ["sip", "QtWidgets"]:
            if not hasattr(ctx, modname):
                import importlib
                setattr(ctx, modname, importlib.import_module("PyQt5." + modname))


    VALID_CAPSULE_NAME = b"$valid$"

    @staticmethod
    def TWidgetToPyQtWidget(tw, ctx = sys.modules['__main__']):
        """


                Convert a TWidget* to a QWidget to be used by PyQt
        
                @param ctx: Context. Reference to a module that already imported SIP and QtWidgets modules
        """
        if type(tw).__name__ == "SwigPyObject":
            ptr_l = ida_idaapi.long_type(tw)
        else:
            import ctypes
            ctypes.pythonapi.PyCapsule_GetPointer.restype = ctypes.c_void_p
            ctypes.pythonapi.PyCapsule_GetPointer.argtypes = [ctypes.py_object, ctypes.c_char_p]
            ptr_l = ctypes.pythonapi.PyCapsule_GetPointer(tw, PluginForm.VALID_CAPSULE_NAME)
        PluginForm._ensure_widget_deps(ctx)
        vptr = ctx.sip.voidptr(ptr_l)
        return ctx.sip.wrapinstance(vptr.__int__(), ctx.QtWidgets.QWidget)
    FormToPyQtWidget = TWidgetToPyQtWidget


    @staticmethod
    def QtWidgetToTWidget(w, ctx = sys.modules['__main__']):
        """


                Convert a QWidget to a TWidget* to be used by IDA
        
                @param ctx: Context. Reference to a module that already imported SIP and QtWidgets modules
        """
        PluginForm._ensure_widget_deps(ctx)
        as_long = ida_idaapi.long_type(ctx.sip.unwrapinstance(w))
        return TWidget__from_ptrval__(as_long)


    @staticmethod
    def TWidgetToPySideWidget(tw, ctx = sys.modules['__main__']):
        """


                Use this method to convert a TWidget* to a QWidget to be used by PySide
        
                @param ctx: Context. Reference to a module that already imported QtWidgets module
        """
        if tw is None:
            return None
        if type(tw).__name__ == "SwigPyObject":
# Since 'tw' is a SwigPyObject, we first need to convert it to a PyCapsule.
# However, there's no easy way of doing it, so we'll use a rather brutal approach:
# converting the SwigPyObject to a 'long' (will go through 'SwigPyObject_long',
# that will return the pointer's value as a long), and then convert that value
# back to a pointer into a PyCapsule.
            ptr_l = ida_idaapi.long_type(tw)
# Warning: this is untested
            import ctypes
            ctypes.pythonapi.PyCapsule_New.restype = ctypes.py_object
            ctypes.pythonapi.PyCapsule_New.argtypes = [ctypes.c_void_p, ctypes.c_char_p, ctypes.c_void_p]
            tw = ctypes.pythonapi.PyCapsule_New(ptr_l, PluginForm.VALID_CAPSULE_NAME, 0)
        return ctx.QtGui.QWidget.FromCapsule(tw)
    FormToPySideWidget = TWidgetToPySideWidget

    def OnCreate(self, form):
        """
        This event is called when the plugin form is created.
        The programmer should populate the form when this event is triggered.

        @return: None
        """
        pass


    def OnClose(self, form):
        """
        Called when the plugin form is closed

        @return: None
        """
        pass


    def Close(self, options):
        """
        Closes the form.

        @param options: Close options (WCLS_SAVE, WCLS_NO_CONTEXT, ...)

        @return: None
        """
        return _ida_kernwin.plgform_close(self.__clink__, options)


    def GetWidget(self):
        """
        Return the TWidget underlying this view.

        @return: The TWidget underlying this view, or None.
        """
        return _ida_kernwin.plgform_get_widget(self.__clink__)


    WCLS_SAVE           = 0x1
    """
    Save state in desktop config
    """

    WCLS_NO_CONTEXT     = 0x2
    """
    Don't change the current context (useful for toolbars)
    """

    WCLS_DONT_SAVE_SIZE = 0x4
    """
    Don't save size of the window
    """

    WCLS_CLOSE_LATER    = 0x8
    """
    This flag should be used when Close() is called from an event handler
    """
#</pycode(py_kernwin_plgform)>


if _BC695:
    AST_DISABLE_FOR_FORM=AST_DISABLE_FOR_WIDGET
    AST_ENABLE_FOR_FORM=AST_ENABLE_FOR_WIDGET
    CB_CLOSE_IDB=CB_INVISIBLE
    chtype_generic2=chtype_generic
    chtype_segreg=chtype_srcp
    close_tform=close_widget
    find_tform=find_widget
    get_current_tform=get_current_widget
    def get_highlighted_identifier():
        thing = get_highlight(get_current_viewer())
        if thing and thing[1]:
            return thing[0]
    get_tform_title=get_widget_title
    get_tform_type=get_widget_type
    is_chooser_tform=is_chooser_widget
    open_tform=display_widget
    pyscv_get_tcustom_control=pyscv_get_widget
    pyscv_get_tform=pyscv_get_widget
    __read_selection70 = read_selection
    def read_selection(*args):
        if len(args) == 0:
# bw-compat
            t0, t1, view = twinpos_t(), twinpos_t(), get_current_viewer()
            sel = __read_selection70(view, t0, t1)
            import ida_idaapi
            a0, a1 = ida_idaapi.BADADDR, ida_idaapi.BADADDR
            if sel:
                a0, a1 = t0.place(view).toea(), t1.place(view).toea()
            return sel, a0, a1
        else:
            return __read_selection70(*args)
    readsel2=read_selection
    switchto_tform=activate_widget
    umsg=msg
    def __wrap_uihooks_callback(name, do_call):
        return ida_ida.__wrap_695_hooks_callback(UI_Hooks, name, name.replace("widget", "tform"), do_call)
    __wrap_uihooks_callback("widget_visible", lambda cb, *args: cb(args[0], args[0]))
    __wrap_uihooks_callback("widget_invisible", lambda cb, *args: cb(args[0], args[0]))
    __wrap_uihooks_callback("populating_widget_popup", lambda cb, *args: cb(*args))
    __wrap_uihooks_callback("finish_populating_widget_popup", lambda cb, *args: cb(*args))
    __wrap_uihooks_callback("current_widget_changed", lambda cb, *args: cb(*args))
    AskUsingForm=ask_form
    HIST_ADDR=0
    HIST_NUM=0
    KERNEL_VERSION_MAGIC1=0
    KERNEL_VERSION_MAGIC2=0
    OpenForm=open_form
    _askaddr=_ida_kernwin._ask_addr
    _asklong=_ida_kernwin._ask_long
    _askseg=_ida_kernwin._ask_seg
    askaddr=ask_addr
    askbuttons_c=ask_buttons
    askfile_c=ask_file
    def askfile2_c(forsave, defdir, filters, fmt):
        if filters:
            fmt = "FILTER %s\n%s" % (filters, fmt)
        return ask_file(forsave, defdir, fmt)
    askident=ask_ident
    asklong=ask_long
    def askqstr(defval, fmt):
        return ask_str(defval, 0, fmt)
    askseg=ask_seg
    def askstr(hist, defval, fmt):
        return ask_str(defval, hist, fmt)
    asktext=ask_text
    askyn_c=ask_yn
    choose2_activate=choose_activate
    choose2_close=choose_close
#choose2_create=choose_create
    choose2_find=choose_find
#choose2_get_embedded=_choose_get_embedded_chobj_pointer
    choose2_get_embedded_selection=lambda *args: None
    choose2_refresh=choose_refresh
    clearBreak=clr_cancelled
    py_get_AskUsingForm=py_get_ask_form
    py_get_OpenForm=py_get_open_form
    setBreak=set_cancelled
    wasBreak=user_cancelled
    refresh_lists=refresh_choosers
# -------------------------------------------------------
    class Choose2(object):
        """
        v.6.95 compatible chooser wrapper class.
        """
        CH_MODAL        = 0x01
        CH_MULTI        = 0x04
        CH_MULTI_EDIT   = 0x08
        """
        The OnEditLine() callback will be called for all
        selected items using the START_SEL/END_SEL
        protocol.
        This bit implies #CH_MULTI.
        """
        CH_NOBTNS       = 0x10
        CH_ATTRS        = 0x20
        CH_NOIDB        = 0x40
        CH_BUILTIN_SHIFT = 19
        CH_BUILTIN_MASK = 0x1F << CH_BUILTIN_SHIFT
# column flags (are specified in the widths array)
        CHCOL_PLAIN  =  0x00000000
        CHCOL_PATH   =  0x00010000
        CHCOL_HEX    =  0x00020000
        CHCOL_DEC    =  0x00030000
        CHCOL_FORMAT =  0x00070000
# special values of the chooser index
        NO_SELECTION   = -1
        """
        there is no selected item
        """
        START_SEL      = -2
        """
        before calling the first selected item
        """
        END_SEL        = -3
        """
        after calling the last selected item
        """
# the v.7.0 chooser object implementing the v.6.95 chooser
        class ChooseWrapper(Choose):
            def __init__(self, v695_chooser):
                self.link = v695_chooser
# check what non-base callbacks we have
                forbidden_cb = 0
                for cb in [("OnInsertLine", Choose.CHOOSE_HAVE_INS    ),
                           ("OnDeleteLine", Choose.CHOOSE_HAVE_DEL    ),
                           ("OnEditLine",   Choose.CHOOSE_HAVE_EDIT   ),
                           ("OnSelectLine", Choose.CHOOSE_HAVE_ENTER  ),
                           ("OnRefresh",    Choose.CHOOSE_HAVE_REFRESH),
                           ("OnSelectionChange", Choose.CHOOSE_HAVE_SELECT)]:
                    if not hasattr(self.link, cb[0]) or \
                       not callable(getattr(self.link, cb[0])):
                        forbidden_cb |= cb[1]
                Choose.__init__(
                        self, self.link.title, self.link.cols,
                        forbidden_cb = forbidden_cb)
# redirect base callbacks to the v.6.95 chooser
            def __getattr__(self, attr):
                if attr in ["OnGetSize",
                            "OnGetLine",
                            "OnGetIcon",
                            "OnGetLineAttr",
                            "OnClose"]:
                    return getattr(self.link, attr)
                return getattr(self.link, attr)
            def Show(self, modal = False):
# set `flags` and `deflt`
                self.flags = self.link.flags
                if self.link.deflt == -1:
                    self.deflt = 0
                else:
                    self.deflt = self.link.deflt - 1
                    self.flags |= Choose.CH_FORCE_DEFAULT
                if (self.flags & Choose.CH_MULTI) != 0:
                    self.deflt = [self.deflt]
# copy simple attributes from v.6.95
                for attr in ["title", "cols", "popup_names", "icon",
                             "x1", "y1", "x2", "y2",
                             "embedded", "width", "height"]:
                    if hasattr(self.link, attr):
                        setattr(self, attr, getattr(self.link, attr))
                    else:
                        delattr(self, attr)
                return Choose.Show(self, modal)
            def OnInsertLine(self, n):
# assert: hasattr(self.link, "OnInsertLine")
                self.link.OnInsertLine()
# we preserve the selection
                return (Choose.ALL_CHANGED, n)
                if (self.link.flags & Choose2.CH_MULTI) == 0:
                    return (Choose.ALL_CHANGED, n)
                else:
                    return [Choose.ALL_CHANGED] + n
            def OnDeleteLine(self, n):
# assert: hasattr(self.link, "OnDeleteLine")
                res = None
                if (self.link.flags & Choose2.CH_MULTI) == 0:
                    res = self.link.OnDeleteLine(n)
                else:
# assert: n is iterable and n
# call the callback multiple times
                  self.link.OnDeleteLine(Choose2.START_SEL)
                  res = None
                  for idx in n:
                      new_idx = self.link.OnDeleteLine(idx)
                      if res == None:
                          res = new_idx
                  self.link.OnDeleteLine(Choose2.END_SEL)
                return [Choose.ALL_CHANGED] + self.adjust_last_item(res)
            def OnEditLine(self, n):
# assert: hasattr(self.link, "OnEditLine")
                if (self.link.flags & Choose2.CH_MULTI) == 0:
                    self.link.OnEditLine(n)
                    return (Choose.ALL_CHANGED, n) # preserve the selection
# assert: n is iterable and n
                if (self.link.flags & Choose2.CH_MULTI_EDIT) == 0:
                    self.link.OnEditLine(n[0])
                    return [Choose.ALL_CHANGED] + n # preserve the selection
# call the callback multiple times
                self.link.OnEditLine(Choose2.START_SEL)
                for idx in n:
                    self.link.OnEditLine(idx)
                self.link.OnEditLine(Choose2.END_SEL)
                return [Choose.ALL_CHANGED] + n # preserve the selection
            def OnSelectLine(self, n):
# assert: hasattr(self.link, "OnSelectLine")
                if (self.link.flags & Choose2.CH_MULTI) == 0:
                    self.link.OnSelectLine(n)
                    return (Choose.ALL_CHANGED, n)
# assert: n is iterable and n
                self.link.OnSelectLine(n[0])
                return [Choose.ALL_CHANGED] + n # preserve the selection
            def OnRefresh(self, n):
# assert: hasattr(self.link, "OnRefresh")
                if (self.link.flags & Choose2.CH_MULTI) != 0:
# ignore all but the first item
                  n = n[0] if n else Choose.NO_SELECTION
                res = self.link.OnRefresh(n)
                return (Choose.ALL_CHANGED, res)
            def OnSelectionChange(self, n):
# assert: hasattr(self.link, "OnSelectionChange")
                if (self.link.flags & Choose2.CH_MULTI) == 0:
                  n = [n] if n != Choose.NO_SELECTION else []
                self.link.OnSelectionChange(n)
            def OnPopup(self, widget, popup_handle):
                self.link._quick_commands.populate_popup(widget, popup_handle)
        def __init__(self, title, cols, flags=0, popup_names=None,
                     icon=-1, x1=-1, y1=-1, x2=-1, y2=-1, deflt=-1,
                     embedded=False, width=None, height=None):
            """
            Constructs a chooser window.
            @param title: The chooser title
            @param cols: a list of colums; each list item is a list of two items
                example: [ ["Address", 10 | Choose2.CHCOL_HEX],
                           ["Name", 30 | Choose2.CHCOL_PLAIN] ]
            @param flags: One of CH_XXXX constants
            @param deflt: Default starting item (1-based).
                0 means that no item is selected,
                -1 means that the first item selected for a new window and
                that the selection is not updated for an existing window
            @param popup_names: list of new captions to replace this list
                ["Insert", "Delete", "Edit", "Refresh"]
            @param icon: Icon index (the icon should exist in ida resources or
                an index to a custom loaded icon)
            @param x1, y1, x2, y2: The default location (for txt-version)
            @param embedded: Create as embedded chooser
            @param width: Embedded chooser width
            @param height: Embedded chooser height
            """
# remember attributes
            self.title = title
            self.flags = flags
            self.cols = cols
            self.deflt = deflt
            self.popup_names = popup_names
            self.icon = icon
            self.x1 = x1
            self.y1 = y1
            self.x2 = x2
            self.y2 = y2
            self.embedded = embedded
            self.width = width
            self.height = height
# construct the v.7.0 chooser object
            self.chobj = Choose2.ChooseWrapper(self)
            def _qccb(ctx, cmd_id):
                for idx in ctx.chooser_selection:
                    self.OnCommand(idx, cmd_id)
            self._quick_commands = quick_widget_commands_t(_qccb)
# redirect methods to the v.7.0 chooser
        def __getattr__(self, attr):
            if attr not in ["GetEmbSelection",
                            "Activate",
                            "Refresh",
                            "Close",
                            "GetWidget"]:
                raise AttributeError(attr)
            return getattr(self.chobj, attr)
        def Embedded(self):
            """
            Creates an embedded chooser (as opposed to Show())
            @return: Returns 1 on success
            """
            return 1 if self.chobj.Embedded() == 0 else 0
        def Show(self, modal=False):
            """
            Activates or creates a chooser window
            @param modal: Display as modal dialog
            @return: For modal choosers it will return the selected item index (0-based)
                     or -1 in the case of error,
                     For non-modal choosers it will return 0
                     or -1 if the chooser was already open and is active now
            """
            ret = self.chobj.Show(modal)
            return -1 if ret < 0 else ret
        def AddCommand(self,
                       caption,
                       flags = _ida_kernwin.CHOOSER_POPUP_MENU,
                       menu_index = -1,
                       icon = -1,
                       emb=None,
                       shortcut=None):
# Use the 'emb' as a sentinel. It will be passed the correct value
# from the EmbeddedChooserControl
            if self.embedded and ((emb is None) or (emb != 2002)):
                raise RuntimeError("Please add a command through "
                                   "EmbeddedChooserControl.AddCommand()")
            return self._quick_commands.add(
                caption=caption,
                flags=flags,
                menu_index=menu_index,
                icon=icon,
                emb=emb,
                shortcut=shortcut)
# callbacks
# def OnGetSize(self):
# def OnGetLine(self, n):
# def OnGetIcon(self, n):
# def OnGetLineAttr(self, n):
# def OnInsertLine(self):
# def OnDeleteLine(self, n):
# def OnEditLine(self, n):
# def OnSelectLine(self, n):
# def OnRefresh(self, n):
# def OnSelectionChange(self, sel_list):
# def OnClose(self):
# def OnCommand(self, n, cmd_id):



if _BC695:
    PluginForm.FORM_MDI = PluginForm.WOPN_MDI
    PluginForm.FORM_TAB = PluginForm.WOPN_TAB
    PluginForm.FORM_RESTORE = PluginForm.WOPN_RESTORE
    PluginForm.FORM_ONTOP = PluginForm.WOPN_ONTOP
    PluginForm.FORM_MENU = PluginForm.WOPN_MENU
    PluginForm.FORM_CENTERED = PluginForm.WOPN_CENTERED
    PluginForm.FORM_PERSIST = PluginForm.WOPN_PERSIST
    PluginForm.FORM_SAVE = PluginForm.WCLS_SAVE
    PluginForm.FORM_NO_CONTEXT = PluginForm.WCLS_NO_CONTEXT
    PluginForm.FORM_DONT_SAVE_SIZE = PluginForm.WCLS_DONT_SAVE_SIZE
    PluginForm.FORM_CLOSE_LATER = PluginForm.WCLS_CLOSE_LATER



