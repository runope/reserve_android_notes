# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.1
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

"""
IDA Plugin SDK API wrapper: idp
"""

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _ida_idp
else:
    import _ida_idp

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """
    Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass
    """
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """
    Meta class to enforce nondynamic attributes (no new attributes) for a class
    """
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import weakref

SWIG_PYTHON_LEGACY_BOOL = _ida_idp.SWIG_PYTHON_LEGACY_BOOL

import ida_idaapi


import sys
_BC695 = sys.modules["__main__"].IDAPYTHON_COMPAT_695_API

if _BC695:






    def bc695redef(func):
        ida_idaapi._BC695.replace_fun(func)
        return func

class reg_access_vec_t(object):
    r"""
    Proxy of C++ qvector< reg_access_t > class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        __init__(self) -> reg_access_vec_t
            x: qvector< reg_access_t > const &
        """
        _ida_idp.reg_access_vec_t_swiginit(self, _ida_idp.new_reg_access_vec_t(*args))
    __swig_destroy__ = _ida_idp.delete_reg_access_vec_t

    def push_back(self, *args) -> "reg_access_t &":
        r"""


        push_back(self, x)
            x: reg_access_t const &
        """
        return _ida_idp.reg_access_vec_t_push_back(self, *args)

    def pop_back(self, *args) -> "void":
        r"""
        pop_back(self)
        """
        return _ida_idp.reg_access_vec_t_pop_back(self, *args)

    def size(self, *args) -> "size_t":
        r"""
        size(self) -> size_t
        """
        return _ida_idp.reg_access_vec_t_size(self, *args)

    def empty(self, *args) -> "bool":
        r"""
        empty(self) -> bool
        """
        return _ida_idp.reg_access_vec_t_empty(self, *args)

    def at(self, *args) -> "reg_access_t const &":
        r"""


        at(self, _idx) -> reg_access_t
            _idx: size_t
        """
        return _ida_idp.reg_access_vec_t_at(self, *args)

    def qclear(self, *args) -> "void":
        r"""
        qclear(self)
        """
        return _ida_idp.reg_access_vec_t_qclear(self, *args)

    def clear(self, *args) -> "void":
        r"""
        clear(self)
        """
        return _ida_idp.reg_access_vec_t_clear(self, *args)

    def resize(self, *args) -> "void":
        r"""


        resize(self, _newsize, x)
            _newsize: size_t
            x: reg_access_t const &
        

        resize(self, _newsize)
            _newsize: size_t
        """
        return _ida_idp.reg_access_vec_t_resize(self, *args)

    def grow(self, *args) -> "void":
        r"""


        grow(self, x=reg_access_t())
            x: reg_access_t const &
        """
        return _ida_idp.reg_access_vec_t_grow(self, *args)

    def capacity(self, *args) -> "size_t":
        r"""
        capacity(self) -> size_t
        """
        return _ida_idp.reg_access_vec_t_capacity(self, *args)

    def reserve(self, *args) -> "void":
        r"""


        reserve(self, cnt)
            cnt: size_t
        """
        return _ida_idp.reg_access_vec_t_reserve(self, *args)

    def truncate(self, *args) -> "void":
        r"""
        truncate(self)
        """
        return _ida_idp.reg_access_vec_t_truncate(self, *args)

    def swap(self, *args) -> "void":
        r"""


        swap(self, r)
            r: qvector< reg_access_t > &
        """
        return _ida_idp.reg_access_vec_t_swap(self, *args)

    def extract(self, *args) -> "reg_access_t *":
        r"""
        extract(self) -> reg_access_t
        """
        return _ida_idp.reg_access_vec_t_extract(self, *args)

    def inject(self, *args) -> "void":
        r"""


        inject(self, s, len)
            s: reg_access_t *
            len: size_t
        """
        return _ida_idp.reg_access_vec_t_inject(self, *args)

    def __eq__(self, *args) -> "bool":
        r"""


        __eq__(self, r) -> bool
            r: qvector< reg_access_t > const &
        """
        return _ida_idp.reg_access_vec_t___eq__(self, *args)

    def __ne__(self, *args) -> "bool":
        r"""


        __ne__(self, r) -> bool
            r: qvector< reg_access_t > const &
        """
        return _ida_idp.reg_access_vec_t___ne__(self, *args)

    def begin(self, *args) -> "qvector< reg_access_t >::const_iterator":
        r"""
        begin(self) -> reg_access_t
        begin(self) -> reg_access_t
        """
        return _ida_idp.reg_access_vec_t_begin(self, *args)

    def end(self, *args) -> "qvector< reg_access_t >::const_iterator":
        r"""
        end(self) -> reg_access_t
        end(self) -> reg_access_t
        """
        return _ida_idp.reg_access_vec_t_end(self, *args)

    def insert(self, *args) -> "qvector< reg_access_t >::iterator":
        r"""


        insert(self, it, x) -> reg_access_t
            it: qvector< reg_access_t >::iterator
            x: reg_access_t const &
        """
        return _ida_idp.reg_access_vec_t_insert(self, *args)

    def erase(self, *args) -> "qvector< reg_access_t >::iterator":
        r"""


        erase(self, it) -> reg_access_t
            it: qvector< reg_access_t >::iterator
        

        erase(self, first, last) -> reg_access_t
            first: qvector< reg_access_t >::iterator
            last: qvector< reg_access_t >::iterator
        """
        return _ida_idp.reg_access_vec_t_erase(self, *args)

    def find(self, *args) -> "qvector< reg_access_t >::const_iterator":
        r"""


        find(self, x) -> reg_access_t
            x: reg_access_t const &
        

        find(self, x) -> reg_access_t
            x: reg_access_t const &
        """
        return _ida_idp.reg_access_vec_t_find(self, *args)

    def has(self, *args) -> "bool":
        r"""


        has(self, x) -> bool
            x: reg_access_t const &
        """
        return _ida_idp.reg_access_vec_t_has(self, *args)

    def add_unique(self, *args) -> "bool":
        r"""


        add_unique(self, x) -> bool
            x: reg_access_t const &
        """
        return _ida_idp.reg_access_vec_t_add_unique(self, *args)

    def _del(self, *args) -> "bool":
        r"""


        _del(self, x) -> bool
            x: reg_access_t const &
        """
        return _ida_idp.reg_access_vec_t__del(self, *args)

    def __len__(self, *args) -> "size_t":
        r"""
        __len__(self) -> size_t
        """
        return _ida_idp.reg_access_vec_t___len__(self, *args)

    def __getitem__(self, *args) -> "reg_access_t const &":
        r"""


        __getitem__(self, i) -> reg_access_t
            i: size_t
        """
        return _ida_idp.reg_access_vec_t___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        r"""


        __setitem__(self, i, v)
            i: size_t
            v: reg_access_t const &
        """
        return _ida_idp.reg_access_vec_t___setitem__(self, *args)

    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator


# Register reg_access_vec_t in _ida_idp:
_ida_idp.reg_access_vec_t_swigregister(reg_access_vec_t)


def AssembleLine(*args) -> "PyObject *":
    r"""


    AssembleLine(ea, cs, ip, use32, nonnul_line) -> PyObject *
    Assemble an instruction to a string (display a warning if an error is found)
    
    @param ea: linear address of instruction
    @param cs:  cs of instruction
    @param ip:  ip of instruction
    @param use32: is 32bit segment
    @param line: line to assemble
    @return:
        - None on failure
        - or a string containing the assembled instruction
    """
    return _ida_idp.AssembleLine(*args)
IDP_INTERFACE_VERSION = _ida_idp.IDP_INTERFACE_VERSION
"""
The interface version number.see also 'IDA_SDK_VERSION' from 'pro.h'
"""


def has_cf_chg(*args) -> "bool":
    r"""


    Does an instruction with the specified feature modify the i-th
    operand?
    
    has_cf_chg(feature, opnum) -> bool
        @param feature (C++: uint32)
        @param opnum (C++: uint)
    """
    return _ida_idp.has_cf_chg(*args)

def has_cf_use(*args) -> "bool":
    r"""


    Does an instruction with the specified feature use a value of the i-th
    operand?
    
    has_cf_use(feature, opnum) -> bool
        @param feature (C++: uint32)
        @param opnum (C++: uint)
    """
    return _ida_idp.has_cf_use(*args)

def has_insn_feature(*args) -> "bool":
    r"""


    Does the specified instruction have the specified feature?
    
    has_insn_feature(icode, bit) -> bool
        @param icode (C++: int)
        @param bit (C++: uint32)
    """
    return _ida_idp.has_insn_feature(*args)

def is_call_insn(*args) -> "bool":
    r"""


    Is the instruction a "call"?
    
    is_call_insn(insn) -> bool
        @param insn  - an ida_ua.insn_t, or an address (C++: const insn_t &)
    """
    return _ida_idp.is_call_insn(*args)

def is_ret_insn(*args) -> "bool":
    r"""


    Is the instruction a "return"?
    
    is_ret_insn(insn, strict=True) -> bool
        @param insn  - an ida_ua.insn_t, or an address (C++: const insn_t &)
        @param strict (C++: bool)
    """
    return _ida_idp.is_ret_insn(*args)

def is_indirect_jump_insn(*args) -> "bool":
    r"""


    Is the instruction an indirect jump?
    
    is_indirect_jump_insn(insn) -> bool
        @param insn  - an ida_ua.insn_t, or an address (C++: const insn_t &)
    """
    return _ida_idp.is_indirect_jump_insn(*args)

def is_basic_block_end(*args) -> "bool":
    r"""


    Is the instruction the end of a basic block?
    
    is_basic_block_end(insn, call_insn_stops_block) -> bool
        @param insn  - an ida_ua.insn_t, or an address (C++: const insn_t &)
        @param call_insn_stops_block (C++: bool)
    """
    return _ida_idp.is_basic_block_end(*args)
class asm_t(object):
    r"""
    Proxy of C++ asm_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    flag = property(_ida_idp.asm_t_flag_get, _ida_idp.asm_t_flag_set)
    uflag = property(_ida_idp.asm_t_uflag_get, _ida_idp.asm_t_uflag_set)
    name = property(_ida_idp.asm_t_name_get, _ida_idp.asm_t_name_set)
    help = property(_ida_idp.asm_t_help_get, _ida_idp.asm_t_help_set)
    header = property(_ida_idp.asm_t_header_get, _ida_idp.asm_t_header_set)
    origin = property(_ida_idp.asm_t_origin_get, _ida_idp.asm_t_origin_set)
    end = property(_ida_idp.asm_t_end_get, _ida_idp.asm_t_end_set)
    cmnt = property(_ida_idp.asm_t_cmnt_get, _ida_idp.asm_t_cmnt_set)
    ascsep = property(_ida_idp.asm_t_ascsep_get, _ida_idp.asm_t_ascsep_set)
    accsep = property(_ida_idp.asm_t_accsep_get, _ida_idp.asm_t_accsep_set)
    esccodes = property(_ida_idp.asm_t_esccodes_get, _ida_idp.asm_t_esccodes_set)
    a_ascii = property(_ida_idp.asm_t_a_ascii_get, _ida_idp.asm_t_a_ascii_set)
    a_byte = property(_ida_idp.asm_t_a_byte_get, _ida_idp.asm_t_a_byte_set)
    a_word = property(_ida_idp.asm_t_a_word_get, _ida_idp.asm_t_a_word_set)
    a_dword = property(_ida_idp.asm_t_a_dword_get, _ida_idp.asm_t_a_dword_set)
    a_qword = property(_ida_idp.asm_t_a_qword_get, _ida_idp.asm_t_a_qword_set)
    a_oword = property(_ida_idp.asm_t_a_oword_get, _ida_idp.asm_t_a_oword_set)
    a_float = property(_ida_idp.asm_t_a_float_get, _ida_idp.asm_t_a_float_set)
    a_double = property(_ida_idp.asm_t_a_double_get, _ida_idp.asm_t_a_double_set)
    a_tbyte = property(_ida_idp.asm_t_a_tbyte_get, _ida_idp.asm_t_a_tbyte_set)
    a_packreal = property(_ida_idp.asm_t_a_packreal_get, _ida_idp.asm_t_a_packreal_set)
    a_dups = property(_ida_idp.asm_t_a_dups_get, _ida_idp.asm_t_a_dups_set)
    a_bss = property(_ida_idp.asm_t_a_bss_get, _ida_idp.asm_t_a_bss_set)
    a_equ = property(_ida_idp.asm_t_a_equ_get, _ida_idp.asm_t_a_equ_set)
    a_seg = property(_ida_idp.asm_t_a_seg_get, _ida_idp.asm_t_a_seg_set)
    a_curip = property(_ida_idp.asm_t_a_curip_get, _ida_idp.asm_t_a_curip_set)
    a_public = property(_ida_idp.asm_t_a_public_get, _ida_idp.asm_t_a_public_set)
    a_weak = property(_ida_idp.asm_t_a_weak_get, _ida_idp.asm_t_a_weak_set)
    a_extrn = property(_ida_idp.asm_t_a_extrn_get, _ida_idp.asm_t_a_extrn_set)
    a_comdef = property(_ida_idp.asm_t_a_comdef_get, _ida_idp.asm_t_a_comdef_set)
    a_align = property(_ida_idp.asm_t_a_align_get, _ida_idp.asm_t_a_align_set)
    lbrace = property(_ida_idp.asm_t_lbrace_get, _ida_idp.asm_t_lbrace_set)
    rbrace = property(_ida_idp.asm_t_rbrace_get, _ida_idp.asm_t_rbrace_set)
    a_mod = property(_ida_idp.asm_t_a_mod_get, _ida_idp.asm_t_a_mod_set)
    a_band = property(_ida_idp.asm_t_a_band_get, _ida_idp.asm_t_a_band_set)
    a_bor = property(_ida_idp.asm_t_a_bor_get, _ida_idp.asm_t_a_bor_set)
    a_xor = property(_ida_idp.asm_t_a_xor_get, _ida_idp.asm_t_a_xor_set)
    a_bnot = property(_ida_idp.asm_t_a_bnot_get, _ida_idp.asm_t_a_bnot_set)
    a_shl = property(_ida_idp.asm_t_a_shl_get, _ida_idp.asm_t_a_shl_set)
    a_shr = property(_ida_idp.asm_t_a_shr_get, _ida_idp.asm_t_a_shr_set)
    a_sizeof_fmt = property(_ida_idp.asm_t_a_sizeof_fmt_get, _ida_idp.asm_t_a_sizeof_fmt_set)
    flag2 = property(_ida_idp.asm_t_flag2_get, _ida_idp.asm_t_flag2_set)
    cmnt2 = property(_ida_idp.asm_t_cmnt2_get, _ida_idp.asm_t_cmnt2_set)
    low8 = property(_ida_idp.asm_t_low8_get, _ida_idp.asm_t_low8_set)
    high8 = property(_ida_idp.asm_t_high8_get, _ida_idp.asm_t_high8_set)
    low16 = property(_ida_idp.asm_t_low16_get, _ida_idp.asm_t_low16_set)
    high16 = property(_ida_idp.asm_t_high16_get, _ida_idp.asm_t_high16_set)
    a_include_fmt = property(_ida_idp.asm_t_a_include_fmt_get, _ida_idp.asm_t_a_include_fmt_set)
    a_vstruc_fmt = property(_ida_idp.asm_t_a_vstruc_fmt_get, _ida_idp.asm_t_a_vstruc_fmt_set)
    a_rva = property(_ida_idp.asm_t_a_rva_get, _ida_idp.asm_t_a_rva_set)
    a_yword = property(_ida_idp.asm_t_a_yword_get, _ida_idp.asm_t_a_yword_set)

    def __init__(self, *args):
        r"""
        __init__(self) -> asm_t
        """
        _ida_idp.asm_t_swiginit(self, _ida_idp.new_asm_t(*args))
    __swig_destroy__ = _ida_idp.delete_asm_t

# Register asm_t in _ida_idp:
_ida_idp.asm_t_swigregister(asm_t)
AS_OFFST = _ida_idp.AS_OFFST
"""
offsets are 'offset xxx' ?
"""

AS_COLON = _ida_idp.AS_COLON
"""
create colons after data names ?
"""

AS_UDATA = _ida_idp.AS_UDATA
"""
can use '?' in data directives
"""

AS_2CHRE = _ida_idp.AS_2CHRE
"""
double char constants are: "xy
"""

AS_NCHRE = _ida_idp.AS_NCHRE
"""
char constants are: 'x
"""

AS_N2CHR = _ida_idp.AS_N2CHR
"""
can't have 2 byte char consts
"""

AS_1TEXT = _ida_idp.AS_1TEXT
"""
1 text per line, no bytes
"""

AS_NHIAS = _ida_idp.AS_NHIAS
"""
no characters with high bit
"""

AS_NCMAS = _ida_idp.AS_NCMAS
"""
no commas in ascii directives
"""

AS_HEXFM = _ida_idp.AS_HEXFM
"""
mask - hex number format
"""

ASH_HEXF0 = _ida_idp.ASH_HEXF0
"""
34h
"""

ASH_HEXF1 = _ida_idp.ASH_HEXF1
"""
h'34
"""

ASH_HEXF2 = _ida_idp.ASH_HEXF2
"""
34
"""

ASH_HEXF3 = _ida_idp.ASH_HEXF3
"""
0x34
"""

ASH_HEXF4 = _ida_idp.ASH_HEXF4
"""
$34
"""

ASH_HEXF5 = _ida_idp.ASH_HEXF5
"""
<^R > (radix)
"""

AS_DECFM = _ida_idp.AS_DECFM
"""
mask - decimal number format
"""

ASD_DECF0 = _ida_idp.ASD_DECF0
"""
34
"""

ASD_DECF1 = _ida_idp.ASD_DECF1
"""
#34
"""

ASD_DECF2 = _ida_idp.ASD_DECF2

ASD_DECF3 = _ida_idp.ASD_DECF3
"""
.34
"""

AS_OCTFM = _ida_idp.AS_OCTFM
"""
mask - octal number format
"""

ASO_OCTF0 = _ida_idp.ASO_OCTF0
"""
123o
"""

ASO_OCTF1 = _ida_idp.ASO_OCTF1
"""
0123
"""

ASO_OCTF2 = _ida_idp.ASO_OCTF2
"""
123
"""

ASO_OCTF3 = _ida_idp.ASO_OCTF3
"""
@123
"""

ASO_OCTF4 = _ida_idp.ASO_OCTF4
"""
o'123
"""

ASO_OCTF5 = _ida_idp.ASO_OCTF5
"""
123q
"""

ASO_OCTF6 = _ida_idp.ASO_OCTF6
"""
~123
"""

ASO_OCTF7 = _ida_idp.ASO_OCTF7
"""
q'123
"""

AS_BINFM = _ida_idp.AS_BINFM
"""
mask - binary number format
"""

ASB_BINF0 = _ida_idp.ASB_BINF0
"""
010101b
"""

ASB_BINF1 = _ida_idp.ASB_BINF1
"""
^B010101
"""

ASB_BINF2 = _ida_idp.ASB_BINF2
"""
%010101
"""

ASB_BINF3 = _ida_idp.ASB_BINF3
"""
0b1010101
"""

ASB_BINF4 = _ida_idp.ASB_BINF4
"""
b'1010101
"""

ASB_BINF5 = _ida_idp.ASB_BINF5
"""
b'1010101'
"""

AS_UNEQU = _ida_idp.AS_UNEQU
"""
replace undefined data items with EQU (for ANTA's A80)
"""

AS_ONEDUP = _ida_idp.AS_ONEDUP
"""
One array definition per line.
"""

AS_NOXRF = _ida_idp.AS_NOXRF
"""
Disable xrefs during the output file generation.
"""

AS_XTRNTYPE = _ida_idp.AS_XTRNTYPE
"""
Assembler understands type of extern symbols as ":type" suffix.
"""

AS_RELSUP = _ida_idp.AS_RELSUP
"""
Checkarg: 'and','or','xor' operations with addresses are possible.
"""

AS_LALIGN = _ida_idp.AS_LALIGN
"""
Labels at "align" keyword are supported.
"""

AS_NOCODECLN = _ida_idp.AS_NOCODECLN
"""
don't create colons after code names
"""

AS_NOSPACE = _ida_idp.AS_NOSPACE
"""
No spaces in expressions.
"""

AS_ALIGN2 = _ida_idp.AS_ALIGN2
"""
(.align 5 means to align at 32byte boundary)

.align directive expects an exponent rather than a power of 2
"""

AS_ASCIIC = _ida_idp.AS_ASCIIC
"""
(\\n,\\x01 and similar)

ascii directive accepts C-like escape sequences
"""

AS_ASCIIZ = _ida_idp.AS_ASCIIZ
"""
ascii directive inserts implicit zero byte at the end
"""

AS2_BRACE = _ida_idp.AS2_BRACE
"""
Use braces for all expressions.
"""

AS2_STRINV = _ida_idp.AS2_STRINV
"""
(For processors with bytes bigger than 8 bits)

Invert meaning of \\inf{wide_high_byte_first} for text strings
"""

AS2_BYTE1CHAR = _ida_idp.AS2_BYTE1CHAR
"""
Meaningful only for wide byte processors.

One symbol per processor byte
"""

AS2_IDEALDSCR = _ida_idp.AS2_IDEALDSCR
"""
Description of struc/union is in the 'reverse' form (keyword before
name) the same as in borland tasm ideal
"""

AS2_TERSESTR = _ida_idp.AS2_TERSESTR
"""
NAME<fld,fld,...> is supported.

'terse' structure initialization form
"""

AS2_COLONSUF = _ida_idp.AS2_COLONSUF
"""
addresses may have ":xx" suffix this suffix must be ignored when
extracting the address under the cursor
"""

AS2_YWORD = _ida_idp.AS2_YWORD
"""
a_yword field is present and valid
"""


HKCB_GLOBAL = _ida_idp.HKCB_GLOBAL
"""
is global event listener? if true, the listener will survive database
closing and opening. it will stay in the memory until explicitly
unhooked. otherwise the kernel will delete it as soon as the owner is
unloaded. should be used only with PLUGIN_FIX plugins.
"""

HKCB_AUTODEL = _ida_idp.HKCB_AUTODEL
"""
automatically delete event listener object after uninstalling it
"""


def get_ph(*args) -> "processor_t *":
    r"""
    get_ph() -> processor_t *
    """
    return _ida_idp.get_ph(*args)

def get_ash(*args) -> "asm_t *":
    r"""
    get_ash() -> asm_t
    """
    return _ida_idp.get_ash(*args)

def str2reg(*args) -> "int":
    r"""


    Get any reg number (-1 on error)
    
    str2reg(p) -> int
        @param p (C++: const char *)
    """
    return _ida_idp.str2reg(*args)

def is_align_insn(*args) -> "int":
    r"""


    If the instruction at 'ea' looks like an alignment instruction, return
    its length in bytes. Otherwise return 0.
    
    is_align_insn(ea) -> int
        @param ea (C++: ea_t)
    """
    return _ida_idp.is_align_insn(*args)

def get_reg_name(*args) -> "qstring *":
    r"""


    Get text representation of a register. For most processors this
    function will just return \ph{reg_names}[reg]. If the processor module
    has implemented processor_t::get_reg_name, it will be used instead
    
    get_reg_name(reg, width, reghi=-1) -> str
        @param reg: internal register number as defined in the processor
                    module (C++: int)
        @param width: register width in bytes (C++: size_t)
        @param reghi: if specified, then this function will return the
                      register pair (C++: int)
        @return: length of register name in bytes or -1 if failure
    """
    return _ida_idp.get_reg_name(*args)
class reg_info_t(object):
    r"""
    Proxy of C++ reg_info_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    reg = property(_ida_idp.reg_info_t_reg_get, _ida_idp.reg_info_t_reg_set)
    size = property(_ida_idp.reg_info_t_size_get, _ida_idp.reg_info_t_size_set)

    def __eq__(self, *args) -> "bool":
        r"""


        __eq__(self, r) -> bool
            r: reg_info_t const &
        """
        return _ida_idp.reg_info_t___eq__(self, *args)

    def __ne__(self, *args) -> "bool":
        r"""


        __ne__(self, r) -> bool
            r: reg_info_t const &
        """
        return _ida_idp.reg_info_t___ne__(self, *args)

    def __lt__(self, *args) -> "bool":
        r"""


        __lt__(self, r) -> bool
            r: reg_info_t const &
        """
        return _ida_idp.reg_info_t___lt__(self, *args)

    def __gt__(self, *args) -> "bool":
        r"""


        __gt__(self, r) -> bool
            r: reg_info_t const &
        """
        return _ida_idp.reg_info_t___gt__(self, *args)

    def __le__(self, *args) -> "bool":
        r"""


        __le__(self, r) -> bool
            r: reg_info_t const &
        """
        return _ida_idp.reg_info_t___le__(self, *args)

    def __ge__(self, *args) -> "bool":
        r"""


        __ge__(self, r) -> bool
            r: reg_info_t const &
        """
        return _ida_idp.reg_info_t___ge__(self, *args)

    def compare(self, *args) -> "int":
        r"""


        compare(self, r) -> int
            r: reg_info_t const &
        """
        return _ida_idp.reg_info_t_compare(self, *args)

    def __init__(self, *args):
        r"""
        __init__(self) -> reg_info_t
        """
        _ida_idp.reg_info_t_swiginit(self, _ida_idp.new_reg_info_t(*args))
    __swig_destroy__ = _ida_idp.delete_reg_info_t

# Register reg_info_t in _ida_idp:
_ida_idp.reg_info_t_swigregister(reg_info_t)


def parse_reg_name(*args) -> "bool":
    r"""


    Get register info by name.
    
    parse_reg_name(ri, regname) -> bool
        @param ri: result (C++: reg_info_t  *)
        @param regname: name of register (C++: const char *)
        @return: success
    """
    return _ida_idp.parse_reg_name(*args)
NO_ACCESS = _ida_idp.NO_ACCESS

WRITE_ACCESS = _ida_idp.WRITE_ACCESS

READ_ACCESS = _ida_idp.READ_ACCESS

RW_ACCESS = _ida_idp.RW_ACCESS

class reg_access_t(object):
    r"""
    Proxy of C++ reg_access_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    regnum = property(_ida_idp.reg_access_t_regnum_get, _ida_idp.reg_access_t_regnum_set)
    range = property(_ida_idp.reg_access_t_range_get, _ida_idp.reg_access_t_range_set)
    access_type = property(_ida_idp.reg_access_t_access_type_get, _ida_idp.reg_access_t_access_type_set)
    opnum = property(_ida_idp.reg_access_t_opnum_get, _ida_idp.reg_access_t_opnum_set)

    def have_common_bits(self, *args) -> "bool":
        r"""


        have_common_bits(self, r) -> bool
            @param r (C++: const  reg_access_t  &)
        """
        return _ida_idp.reg_access_t_have_common_bits(self, *args)

    def __eq__(self, *args) -> "bool":
        r"""


        __eq__(self, r) -> bool
            r: reg_access_t const &
        """
        return _ida_idp.reg_access_t___eq__(self, *args)

    def __ne__(self, *args) -> "bool":
        r"""


        __ne__(self, r) -> bool
            r: reg_access_t const &
        """
        return _ida_idp.reg_access_t___ne__(self, *args)

    def __init__(self, *args):
        r"""
        __init__(self) -> reg_access_t
        """
        _ida_idp.reg_access_t_swiginit(self, _ida_idp.new_reg_access_t(*args))
    __swig_destroy__ = _ida_idp.delete_reg_access_t

# Register reg_access_t in _ida_idp:
_ida_idp.reg_access_t_swigregister(reg_access_t)

class reg_accesses_t(reg_access_vec_t):
    r"""
    Proxy of C++ reg_accesses_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(self) -> reg_accesses_t
        """
        _ida_idp.reg_accesses_t_swiginit(self, _ida_idp.new_reg_accesses_t(*args))
    __swig_destroy__ = _ida_idp.delete_reg_accesses_t

# Register reg_accesses_t in _ida_idp:
_ida_idp.reg_accesses_t_swigregister(reg_accesses_t)

SETPROC_IDB = _ida_idp.SETPROC_IDB

SETPROC_LOADER = _ida_idp.SETPROC_LOADER

SETPROC_LOADER_NON_FATAL = _ida_idp.SETPROC_LOADER_NON_FATAL

SETPROC_USER = _ida_idp.SETPROC_USER


def set_processor_type(*args) -> "bool":
    r"""


    Set target processor type. Once a processor module is loaded, it
    cannot be replaced until we close the idb.
    
    set_processor_type(procname, level) -> bool
        @param procname: name of processor type (one of names present in
                         \ph{psnames}) (C++: const char *)
        @param level: SETPROC_ (C++: setproc_level_t)
        @return: success
    """
    return _ida_idp.set_processor_type(*args)

def get_idp_name(*args) -> "size_t":
    r"""


    Get name of the current processor module. The name is derived from the
    file name. For example, for IBM PC the module is named "pc.w32"
    (windows version), then the module name is "PC" (uppercase). If no
    processor module is loaded, this function will return NULL
    """
    return _ida_idp.get_idp_name(*args)

def set_target_assembler(*args) -> "bool":
    r"""


    Set target assembler.
    
    set_target_assembler(asmnum) -> bool
        @param asmnum: number of assembler in the current processor module
                       (C++: int)
        @return: success
    """
    return _ida_idp.set_target_assembler(*args)
closebase = _ida_idp.closebase

savebase = _ida_idp.savebase

upgraded = _ida_idp.upgraded

auto_empty = _ida_idp.auto_empty

auto_empty_finally = _ida_idp.auto_empty_finally

determined_main = _ida_idp.determined_main

local_types_changed = _ida_idp.local_types_changed

extlang_changed = _ida_idp.extlang_changed

idasgn_loaded = _ida_idp.idasgn_loaded

kernel_config_loaded = _ida_idp.kernel_config_loaded

loader_finished = _ida_idp.loader_finished

flow_chart_created = _ida_idp.flow_chart_created

compiler_changed = _ida_idp.compiler_changed

changing_ti = _ida_idp.changing_ti

ti_changed = _ida_idp.ti_changed

changing_op_ti = _ida_idp.changing_op_ti

op_ti_changed = _ida_idp.op_ti_changed

changing_op_type = _ida_idp.changing_op_type

op_type_changed = _ida_idp.op_type_changed

enum_created = _ida_idp.enum_created

deleting_enum = _ida_idp.deleting_enum

enum_deleted = _ida_idp.enum_deleted

renaming_enum = _ida_idp.renaming_enum

enum_renamed = _ida_idp.enum_renamed

changing_enum_bf = _ida_idp.changing_enum_bf

enum_bf_changed = _ida_idp.enum_bf_changed

changing_enum_cmt = _ida_idp.changing_enum_cmt

enum_cmt_changed = _ida_idp.enum_cmt_changed

enum_member_created = _ida_idp.enum_member_created

deleting_enum_member = _ida_idp.deleting_enum_member

enum_member_deleted = _ida_idp.enum_member_deleted

struc_created = _ida_idp.struc_created

deleting_struc = _ida_idp.deleting_struc

struc_deleted = _ida_idp.struc_deleted

changing_struc_align = _ida_idp.changing_struc_align

struc_align_changed = _ida_idp.struc_align_changed

renaming_struc = _ida_idp.renaming_struc

struc_renamed = _ida_idp.struc_renamed

expanding_struc = _ida_idp.expanding_struc

struc_expanded = _ida_idp.struc_expanded

struc_member_created = _ida_idp.struc_member_created

deleting_struc_member = _ida_idp.deleting_struc_member

struc_member_deleted = _ida_idp.struc_member_deleted

renaming_struc_member = _ida_idp.renaming_struc_member

struc_member_renamed = _ida_idp.struc_member_renamed

changing_struc_member = _ida_idp.changing_struc_member

struc_member_changed = _ida_idp.struc_member_changed

changing_struc_cmt = _ida_idp.changing_struc_cmt

struc_cmt_changed = _ida_idp.struc_cmt_changed

segm_added = _ida_idp.segm_added

deleting_segm = _ida_idp.deleting_segm

segm_deleted = _ida_idp.segm_deleted

changing_segm_start = _ida_idp.changing_segm_start

segm_start_changed = _ida_idp.segm_start_changed

changing_segm_end = _ida_idp.changing_segm_end

segm_end_changed = _ida_idp.segm_end_changed

changing_segm_name = _ida_idp.changing_segm_name

segm_name_changed = _ida_idp.segm_name_changed

changing_segm_class = _ida_idp.changing_segm_class

segm_class_changed = _ida_idp.segm_class_changed

segm_attrs_updated = _ida_idp.segm_attrs_updated

segm_moved = _ida_idp.segm_moved

allsegs_moved = _ida_idp.allsegs_moved

func_added = _ida_idp.func_added

func_updated = _ida_idp.func_updated

set_func_start = _ida_idp.set_func_start

set_func_end = _ida_idp.set_func_end

deleting_func = _ida_idp.deleting_func

frame_deleted = _ida_idp.frame_deleted

thunk_func_created = _ida_idp.thunk_func_created

func_tail_appended = _ida_idp.func_tail_appended

deleting_func_tail = _ida_idp.deleting_func_tail

func_tail_deleted = _ida_idp.func_tail_deleted

tail_owner_changed = _ida_idp.tail_owner_changed

func_noret_changed = _ida_idp.func_noret_changed

stkpnts_changed = _ida_idp.stkpnts_changed

updating_tryblks = _ida_idp.updating_tryblks

tryblks_updated = _ida_idp.tryblks_updated

deleting_tryblks = _ida_idp.deleting_tryblks

sgr_changed = _ida_idp.sgr_changed

make_code = _ida_idp.make_code

make_data = _ida_idp.make_data

destroyed_items = _ida_idp.destroyed_items

renamed = _ida_idp.renamed

byte_patched = _ida_idp.byte_patched

changing_cmt = _ida_idp.changing_cmt

cmt_changed = _ida_idp.cmt_changed

changing_range_cmt = _ida_idp.changing_range_cmt

range_cmt_changed = _ida_idp.range_cmt_changed

extra_cmt_changed = _ida_idp.extra_cmt_changed

item_color_changed = _ida_idp.item_color_changed

callee_addr_changed = _ida_idp.callee_addr_changed

bookmark_changed = _ida_idp.bookmark_changed

sgr_deleted = _ida_idp.sgr_deleted

adding_segm = _ida_idp.adding_segm

func_deleted = _ida_idp.func_deleted

dirtree_mkdir = _ida_idp.dirtree_mkdir

dirtree_rmdir = _ida_idp.dirtree_rmdir

dirtree_link = _ida_idp.dirtree_link

dirtree_move = _ida_idp.dirtree_move

dirtree_rank = _ida_idp.dirtree_rank

dirtree_rminode = _ida_idp.dirtree_rminode

dirtree_segm_moved = _ida_idp.dirtree_segm_moved


def gen_idb_event(*args) -> "void":
    r"""


    the kernel will use this function to generate idb_events
    
    gen_idb_event(code)
        @param code (C++: idb_event::event_code_t)
    """
    return _ida_idp.gen_idb_event(*args)

def set_module_data(*args) -> "void *":
    r"""


    Starting from IDA v7.5 all modules should use the following 3
    functions to handle idb specific static data because now the kernel
    supports opening and working with multiple idbs files simultaneously.
    See the source code of the processor modules in the SDK for the usage
    examples. Register pointer to database specific module data.
    
    set_module_data(data_id, data_ptr) -> void *
        @param data_id: initially the pointed-to value must be 0, the kernel
                        will fill it with a unique id. once assigned, the
                        data_id does not change. (C++: int *)
        @param data_ptr: pointer to the data to register (C++: void *)
        @return: data_ptr. The registered pointer can later be retrieved using
                 get_module_data()
    """
    return _ida_idp.set_module_data(*args)

def clr_module_data(*args) -> "void *":
    r"""


    Unregister pointer to database specific module data.
    
    clr_module_data(data_id) -> void *
        @param data_id: an data_id that was assigned by  set_module_data()
                        (C++: int)
        @return: previously registered pointer for the current database. it
                 can be deallocated now. Multiple calls to this function with
                 the same id are forbidden.
    """
    return _ida_idp.clr_module_data(*args)

def get_module_data(*args) -> "void *":
    r"""


    Get pointer to the database specific module data.
    
    get_module_data(data_id) -> void *
        @param data_id: data id that was initialized by  set_module_data()
                        (C++: int)
        @return: previously registered pointer for the current database
    """
    return _ida_idp.get_module_data(*args)
IDPOPT_CST = _ida_idp.IDPOPT_CST

IDPOPT_PRI_DEFAULT = _ida_idp.IDPOPT_PRI_DEFAULT

IDPOPT_PRI_HIGH = _ida_idp.IDPOPT_PRI_HIGH

IDPOPT_NUM_INT = _ida_idp.IDPOPT_NUM_INT

IDPOPT_NUM_CHAR = _ida_idp.IDPOPT_NUM_CHAR

IDPOPT_NUM_SHORT = _ida_idp.IDPOPT_NUM_SHORT

IDPOPT_NUM_RANGE = _ida_idp.IDPOPT_NUM_RANGE

IDPOPT_NUM_UNS = _ida_idp.IDPOPT_NUM_UNS

IDPOPT_BIT_UINT = _ida_idp.IDPOPT_BIT_UINT

IDPOPT_BIT_UCHAR = _ida_idp.IDPOPT_BIT_UCHAR

IDPOPT_BIT_USHORT = _ida_idp.IDPOPT_BIT_USHORT

IDPOPT_BIT_BOOL = _ida_idp.IDPOPT_BIT_BOOL

IDPOPT_STR_QSTRING = _ida_idp.IDPOPT_STR_QSTRING

IDPOPT_STR_LONG = _ida_idp.IDPOPT_STR_LONG

IDPOPT_I64_RANGES = _ida_idp.IDPOPT_I64_RANGES

IDPOPT_I64_UNS = _ida_idp.IDPOPT_I64_UNS

IDPOPT_CST_PARAMS = _ida_idp.IDPOPT_CST_PARAMS

IDPOPT_MBROFF = _ida_idp.IDPOPT_MBROFF


def process_config_directive(*args) -> "void":
    r"""


    process_config_directive(directive, priority=2)
        directive: char const *
        priority: int
    """
    return _ida_idp.process_config_directive(*args)

def register_cfgopts(*args) -> "bool":
    r"""


    register_cfgopts(opts, nopts, cb=None, obj=None) -> bool
        opts: cfgopt_t const []
        nopts: size_t
        cb: config_changed_cb_t *
        obj: void *
    """
    return _ida_idp.register_cfgopts(*args)

def cfg_get_cc_parm(*args) -> "char const *":
    r"""


    cfg_get_cc_parm(compid, name) -> char const *
        compid: comp_t
        name: char const *
    """
    return _ida_idp.cfg_get_cc_parm(*args)

def cfg_get_cc_header_path(*args) -> "char const *":
    r"""


    cfg_get_cc_header_path(compid) -> char const *
        compid: comp_t
    """
    return _ida_idp.cfg_get_cc_header_path(*args)

def cfg_get_cc_predefined_macros(*args) -> "char const *":
    r"""


    cfg_get_cc_predefined_macros(compid) -> char const *
        compid: comp_t
    """
    return _ida_idp.cfg_get_cc_predefined_macros(*args)

def assemble(*args) -> "bool":
    r"""


    assemble(ea, cs, ip, use32, line) -> bool
    Assemble an instruction into the database (display a warning if an error is found)
    @param ea: linear address of instruction
    @param cs: cs of instruction
    @param ip: ip of instruction
    @param use32: is 32bit segment?
    @param line: line to assemble
    
    @return: Boolean. True on success.
    """
    return _ida_idp.assemble(*args)

def ph_get_id(*args) -> "size_t":
    r"""


    ph_get_id() -> size_t
    Returns the 'ph.id' field
    """
    return _ida_idp.ph_get_id(*args)

def ph_get_version(*args) -> "size_t":
    r"""


    ph_get_version() -> size_t
    Returns the 'ph.version'
    """
    return _ida_idp.ph_get_version(*args)

def ph_get_flag(*args) -> "size_t":
    r"""


    ph_get_flag() -> size_t
    Returns the 'ph.flag'
    """
    return _ida_idp.ph_get_flag(*args)

def ph_get_cnbits(*args) -> "size_t":
    r"""


    ph_get_cnbits() -> size_t
    Returns the 'ph.cnbits'
    """
    return _ida_idp.ph_get_cnbits(*args)

def ph_get_dnbits(*args) -> "size_t":
    r"""


    ph_get_dnbits() -> size_t
    Returns the 'ph.dnbits'
    """
    return _ida_idp.ph_get_dnbits(*args)

def ph_get_reg_first_sreg(*args) -> "size_t":
    r"""


    ph_get_reg_first_sreg() -> size_t
    Returns the 'ph.reg_first_sreg'
    """
    return _ida_idp.ph_get_reg_first_sreg(*args)

def ph_get_reg_last_sreg(*args) -> "size_t":
    r"""


    ph_get_reg_last_sreg() -> size_t
    Returns the 'ph.reg_last_sreg'
    """
    return _ida_idp.ph_get_reg_last_sreg(*args)

def ph_get_segreg_size(*args) -> "size_t":
    r"""


    ph_get_segreg_size() -> size_t
    Returns the 'ph.segreg_size'
    """
    return _ida_idp.ph_get_segreg_size(*args)

def ph_get_reg_code_sreg(*args) -> "size_t":
    r"""


    ph_get_reg_code_sreg() -> size_t
    Returns the 'ph.reg_code_sreg'
    """
    return _ida_idp.ph_get_reg_code_sreg(*args)

def ph_get_reg_data_sreg(*args) -> "size_t":
    r"""


    ph_get_reg_data_sreg() -> size_t
    Returns the 'ph.reg_data_sreg'
    """
    return _ida_idp.ph_get_reg_data_sreg(*args)

def ph_get_icode_return(*args) -> "size_t":
    r"""


    ph_get_icode_return() -> size_t
    Returns the 'ph.icode_return'
    """
    return _ida_idp.ph_get_icode_return(*args)

def ph_get_instruc_start(*args) -> "size_t":
    r"""


    ph_get_instruc_start() -> size_t
    Returns the 'ph.instruc_start'
    """
    return _ida_idp.ph_get_instruc_start(*args)

def ph_get_instruc_end(*args) -> "size_t":
    r"""


    ph_get_instruc_end() -> size_t
    Returns the 'ph.instruc_end'
    """
    return _ida_idp.ph_get_instruc_end(*args)

def ph_get_tbyte_size(*args) -> "size_t":
    r"""


    ph_get_tbyte_size() -> size_t
    Returns the 'ph.tbyte_size' field as defined in he processor module
    """
    return _ida_idp.ph_get_tbyte_size(*args)

def ph_get_instruc(*args) -> "PyObject *":
    r"""


    ph_get_instruc() -> PyObject *
    Returns a list of tuples (instruction_name, instruction_feature) containing the
    instructions list as defined in he processor module
    """
    return _ida_idp.ph_get_instruc(*args)

def ph_get_regnames(*args) -> "PyObject *":
    r"""


    ph_get_regnames() -> PyObject *
    Returns the list of register names as defined in the processor module
    """
    return _ida_idp.ph_get_regnames(*args)

def ph_get_operand_info(*args) -> "PyObject *":
    r"""


    ph_get_operand_info(ea, n) -> PyObject *
    Returns the operand information given an ea and operand number.
    
    @param ea: address
    @param n: operand number
    
    @return: Returns an idd_opinfo_t as a tuple: (modified, ea, reg_ival, regidx, value_size).
             Please refer to idd_opinfo_t structure in the SDK.
    """
    return _ida_idp.ph_get_operand_info(*args)

def ph_calcrel(*args) -> "bytevec_t *, size_t *":
    r"""


    ph_calcrel(ea)
        ea: ea_t
    """
    return _ida_idp.ph_calcrel(*args)

def ph_find_reg_value(*args) -> "uint64 *":
    r"""


    ph_find_reg_value(insn, reg) -> ssize_t
        insn: an ida_ua.insn_t, or an address (C++: const insn_t &)
        reg: int
    """
    return _ida_idp.ph_find_reg_value(*args)

def ph_find_op_value(*args) -> "uint64 *":
    r"""


    ph_find_op_value(insn, op) -> ssize_t
        insn: an ida_ua.insn_t, or an address (C++: const insn_t &)
        op: int
    """
    return _ida_idp.ph_find_op_value(*args)

def ph_get_reg_accesses(*args) -> "ssize_t":
    r"""


    ph_get_reg_accesses(accvec, insn, flags) -> ssize_t
        accvec: reg_accesses_t *
        insn: an ida_ua.insn_t, or an address (C++: const insn_t &)
        flags: int
    """
    return _ida_idp.ph_get_reg_accesses(*args)
class IDP_Hooks(object):
    r"""
    Proxy of C++ IDP_Hooks class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        __init__(self, _flags=0) -> IDP_Hooks
            _flags: uint32
        """
        if self.__class__ == IDP_Hooks:
            _self = None
        else:
            _self = self
        _ida_idp.IDP_Hooks_swiginit(self, _ida_idp.new_IDP_Hooks(_self, *args))

    def hook(self, *args) -> "bool":
        r"""
        hook(self) -> bool
        """
        return _ida_idp.IDP_Hooks_hook(self, *args)

    def unhook(self, *args) -> "bool":
        r"""
        unhook(self) -> bool
        """
        return _ida_idp.IDP_Hooks_unhook(self, *args)

    def ev_init(self, *args) -> "int":
        r"""


        The IDP module is just loaded.
        
        ev_init(self, idp_modname) -> int
            @param idp_modname: processor module name  (C++: const char *)
            @retval: <0 - on failure
        """
        return _ida_idp.IDP_Hooks_ev_init(self, *args)

    def ev_term(self, *args) -> "int":
        r"""


        The IDP module is being unloaded.
        """
        return _ida_idp.IDP_Hooks_ev_term(self, *args)

    def ev_newprc(self, *args) -> "int":
        r"""


        Before changing processor type.
        
        ev_newprc(self, pnum, keep_cfg) -> int
            @param pnum: processor number in the array of processor names  (C++:
                         int)
            @param keep_cfg: true: do not modify kernel configuration  (C++: bool)
            @retval: 1 - ok
            @retval: <0 - prohibit
        """
        return _ida_idp.IDP_Hooks_ev_newprc(self, *args)

    def ev_newasm(self, *args) -> "int":
        r"""


        Before setting a new assembler.
        
        ev_newasm(self, asmnum) -> int
            @param asmnum: See also ev_asm_installed  (C++: int)
        """
        return _ida_idp.IDP_Hooks_ev_newasm(self, *args)

    def ev_newfile(self, *args) -> "int":
        r"""


        A new file has been loaded.
        
        ev_newfile(self, fname) -> int
            @param fname: input file name  (C++: char *)
        """
        return _ida_idp.IDP_Hooks_ev_newfile(self, *args)

    def ev_oldfile(self, *args) -> "int":
        r"""


        An old file has been loaded.
        
        ev_oldfile(self, fname) -> int
            @param fname: input file name  (C++: char *)
        """
        return _ida_idp.IDP_Hooks_ev_oldfile(self, *args)

    def ev_newbinary(self, *args) -> "int":
        r"""


        IDA is about to load a binary file.
        
        ev_newbinary(self, filename, fileoff, basepara, binoff, nbytes) -> int
            @param filename: binary file name  (C++: char *)
            @param fileoff: offset in the file  (C++: qoff64_t)
            @param basepara: base loading paragraph  (C++: ea_t)
            @param binoff: loader offset  (C++: ea_t)
            @param nbytes: number of bytes to load  (C++: uint64)
        """
        return _ida_idp.IDP_Hooks_ev_newbinary(self, *args)

    def ev_endbinary(self, *args) -> "int":
        r"""


        IDA has loaded a binary file.
        
        ev_endbinary(self, ok) -> int
            @param ok: file loaded successfully?  (C++: bool)
        """
        return _ida_idp.IDP_Hooks_ev_endbinary(self, *args)

    def ev_set_idp_options(self, *args) -> "int":
        r"""


        Set IDP-specific configuration option Also see set_options_t in
        'config.hpp'
        
        ev_set_idp_options(self, keyword, value_type, value, idb_loaded) -> int
            @param keyword (C++: const char *)
            @param value_type (C++: int)
            @param value (C++: const void *)
            @param idb_loaded: true if the ev_oldfile/ev_newfile events have been
                               generated  (C++: bool)
            @retval: 1 - ok
            @retval: 0 - not implemented
            @retval: -1 - error (and message in errbuf)
        """
        return _ida_idp.IDP_Hooks_ev_set_idp_options(self, *args)

    def ev_set_proc_options(self, *args) -> "int":
        r"""


        Called if the user specified an option string in the command line:
        -p<processor name>:<options>. Can be used for setting a processor
        subtype. Also called if option string is passed to
        'set_processor_type()' and IDC's SetProcessorType().
        
        ev_set_proc_options(self, options, confidence) -> int
            @param options (C++: const char *)
            @param confidence: 0: loader's suggestion 1: user's decision  (C++:
                               int)
            @retval: <0 - if bad option string
        """
        return _ida_idp.IDP_Hooks_ev_set_proc_options(self, *args)

    def ev_ana_insn(self, *args) -> "bool":
        r"""


        Analyze one instruction and fill 'out' structure. This function
        shouldn't change the database, flags or anything else. All these
        actions should be performed only by emu_insn() function. \insn_t{ea}
        contains address of instruction to analyze.
        
        ev_ana_insn(self, out) -> bool
            @param out (C++: insn_t *)
            @retval: 0 - if instruction can't be decoded.
        """
        return _ida_idp.IDP_Hooks_ev_ana_insn(self, *args)

    def ev_emu_insn(self, *args) -> "bool":
        r"""


        Emulate instruction, create cross-references, plan to analyze
        subsequent instructions, modify flags etc. Upon entrance to this
        function, all information about the instruction is in 'insn'
        structure.
        
        ev_emu_insn(self, insn) -> bool
            @param insn (C++: const insn_t *)
            @retval: 1 - ok
            @retval: -1 - the kernel will delete the instruction
        """
        return _ida_idp.IDP_Hooks_ev_emu_insn(self, *args)

    def ev_out_header(self, *args) -> "int":
        r"""


        Function to produce start of disassembled text
        
        ev_out_header(self, outctx) -> int
            @param outctx (C++: outctx_t *)
            @retval: void -
        """
        return _ida_idp.IDP_Hooks_ev_out_header(self, *args)

    def ev_out_footer(self, *args) -> "int":
        r"""


        Function to produce end of disassembled text
        
        ev_out_footer(self, outctx) -> int
            @param outctx (C++: outctx_t *)
            @retval: void -
        """
        return _ida_idp.IDP_Hooks_ev_out_footer(self, *args)

    def ev_out_segstart(self, *args) -> "int":
        r"""


        Function to produce start of segment
        
        ev_out_segstart(self, outctx, seg) -> int
            @param outctx (C++: outctx_t *)
            @param seg (C++: segment_t *)
            @retval: 1 - ok
            @retval: 0 - not implemented
        """
        return _ida_idp.IDP_Hooks_ev_out_segstart(self, *args)

    def ev_out_segend(self, *args) -> "int":
        r"""


        Function to produce end of segment
        
        ev_out_segend(self, outctx, seg) -> int
            @param outctx (C++: outctx_t *)
            @param seg (C++: segment_t *)
            @retval: 1 - ok
            @retval: 0 - not implemented
        """
        return _ida_idp.IDP_Hooks_ev_out_segend(self, *args)

    def ev_out_assumes(self, *args) -> "int":
        r"""


        Function to produce assume directives when segment register value
        changes.
        
        ev_out_assumes(self, outctx) -> int
            @param outctx (C++: outctx_t *)
            @retval: 1 - ok
            @retval: 0 - not implemented
        """
        return _ida_idp.IDP_Hooks_ev_out_assumes(self, *args)

    def ev_out_insn(self, *args) -> "bool":
        r"""


        Generate text representation of an instruction in 'ctx.insn'
        'outctx_t' provides functions to output the generated text. This
        function shouldn't change the database, flags or anything else. All
        these actions should be performed only by emu_insn() function.
        
        ev_out_insn(self, outctx) -> bool
            @param outctx (C++: outctx_t *)
            @retval: void -
        """
        return _ida_idp.IDP_Hooks_ev_out_insn(self, *args)

    def ev_out_mnem(self, *args) -> "int":
        r"""


        Generate instruction mnemonics. This callback should append the
        colored mnemonics to ctx.outbuf Optional notification, if absent,
        out_mnem will be called.
        
        ev_out_mnem(self, outctx) -> int
            @param outctx (C++: outctx_t *)
            @retval: 1 - if appended the mnemonics
            @retval: 0 - not implemented
        """
        return _ida_idp.IDP_Hooks_ev_out_mnem(self, *args)

    def ev_out_operand(self, *args) -> "bool":
        r"""


        Generate text representation of an instruction operand 'outctx_t'
        provides functions to output the generated text. All these actions
        should be performed only by emu_insn() function.
        
        ev_out_operand(self, outctx, op) -> bool
            @param outctx (C++: outctx_t *)
            @param op (C++: const op_t *)
            @retval: 1 - ok
            @retval: -1 - operand is hidden
        """
        return _ida_idp.IDP_Hooks_ev_out_operand(self, *args)

    def ev_out_data(self, *args) -> "int":
        r"""


        Generate text representation of data items This function may change
        the database and create cross-references if analyze_only is set
        
        ev_out_data(self, outctx, analyze_only) -> int
            @param outctx (C++: outctx_t *)
            @param analyze_only (C++: bool)
            @retval: 1 - ok
            @retval: 0 - not implemented
        """
        return _ida_idp.IDP_Hooks_ev_out_data(self, *args)

    def ev_out_label(self, *args) -> "int":
        r"""


        The kernel is going to generate an instruction label line or a
        function header.
        
        ev_out_label(self, outctx, colored_name) -> int
            @param outctx (C++: outctx_t *)
            @param colored_name (C++: const char *)
            @retval: <0 - if the kernel should not generate the label
            @retval: 0 - not implemented or continue
        """
        return _ida_idp.IDP_Hooks_ev_out_label(self, *args)

    def ev_out_special_item(self, *args) -> "int":
        r"""


        Generate text representation of an item in a special segment i.e.
        absolute symbols, externs, communal definitions etc
        
        ev_out_special_item(self, outctx, segtype) -> int
            @param outctx (C++: outctx_t *)
            @param segtype (C++: uchar)
            @retval: 1 - ok
            @retval: 0 - not implemented
            @retval: -1 - overflow
        """
        return _ida_idp.IDP_Hooks_ev_out_special_item(self, *args)

    def ev_gen_stkvar_def(self, *args) -> "int":
        r"""


        Generate stack variable definition line Default line is varname = type
        ptr value, where 'type' is one of byte,word,dword,qword,tbyte
        
        ev_gen_stkvar_def(self, outctx, mptr, v) -> int
            @param outctx (C++: outctx_t *)
            @param mptr (C++: const member_t *)
            @param v (C++: sval_t)
            @retval: 1 - ok
            @retval: 0 - not implemented
        """
        return _ida_idp.IDP_Hooks_ev_gen_stkvar_def(self, *args)

    def ev_gen_regvar_def(self, *args) -> "int":
        r"""


        Generate register variable definition line.
        
        ev_gen_regvar_def(self, outctx, v) -> int
            @param outctx (C++: outctx_t *)
            @param v (C++: regvar_t *)
            @retval: >0 - ok, generated the definition text
            @retval: 0 - not implemented
        """
        return _ida_idp.IDP_Hooks_ev_gen_regvar_def(self, *args)

    def ev_gen_src_file_lnnum(self, *args) -> "int":
        r"""


        Callback: generate analog of:
        
        < #line "file.c" 123
        <
        
        directive.
        
        ev_gen_src_file_lnnum(self, outctx, file, lnnum) -> int
            @param outctx: output context  (C++: outctx_t *)
            @param file: source file (may be NULL)  (C++: const char *)
            @param lnnum: line number  (C++: size_t)
            @retval: 1 - directive has been generated
            @retval: 0 - not implemented
        """
        return _ida_idp.IDP_Hooks_ev_gen_src_file_lnnum(self, *args)

    def ev_creating_segm(self, *args) -> "int":
        r"""


        A new segment is about to be created.
        
        ev_creating_segm(self, seg) -> int
            @param seg (C++: segment_t *)
            @retval: 1 - ok
            @retval: <0 - segment should not be created
        """
        return _ida_idp.IDP_Hooks_ev_creating_segm(self, *args)

    def ev_moving_segm(self, *args) -> "int":
        r"""


        May the kernel move the segment?
        
        ev_moving_segm(self, seg, to, flags) -> int
            @param seg: segment to move  (C++: segment_t *)
            @param to: new segment start address  (C++: ea_t)
            @param flags: combination of Move segment flags  (C++: int)
            @retval: 0 - yes
            @retval: <0 - the kernel should stop
        """
        return _ida_idp.IDP_Hooks_ev_moving_segm(self, *args)

    def ev_coagulate(self, *args) -> "int":
        r"""


        Try to define some unexplored bytes. This notification will be called
        if the kernel tried all possibilities and could not find anything more
        useful than to convert to array of bytes. The module can help the
        kernel and convert the bytes into something more useful.
        
        ev_coagulate(self, start_ea) -> int
            @param start_ea (C++: ea_t)
            @return: number of converted bytes
        """
        return _ida_idp.IDP_Hooks_ev_coagulate(self, *args)

    def ev_undefine(self, *args) -> "int":
        r"""


        An item in the database (insn or data) is being deleted.
        
        ev_undefine(self, ea) -> int
            @param ea (C++: ea_t)
            @retval: 1 - do not delete srranges at the item end
            @retval: 0 - srranges can be deleted
        """
        return _ida_idp.IDP_Hooks_ev_undefine(self, *args)

    def ev_treat_hindering_item(self, *args) -> "int":
        r"""


        An item hinders creation of another item.
        
        ev_treat_hindering_item(self, hindering_item_ea, new_item_flags, new_item_ea, new_item_length) -> int
            @param hindering_item_ea (C++: ea_t)
            @param new_item_flags: (0 for code)  (C++: flags_t)
            @param new_item_ea (C++: ea_t)
            @param new_item_length (C++: asize_t)
            @retval: 0 - no reaction
            @retval: !=0 - the kernel may delete the hindering item
        """
        return _ida_idp.IDP_Hooks_ev_treat_hindering_item(self, *args)

    def ev_rename(self, *args) -> "int":
        r"""


        The kernel is going to rename a byte.
        
        ev_rename(self, ea, new_name) -> int
            @param ea (C++: ea_t)
            @param new_name (C++: const char *)
            @retval: <0 - if the kernel should not rename it.
            @retval: 2 - to inhibit the notification. I.e., the kernel should not
                         rename, but ' set_name() ' should return 'true'. also see
                         \idpcode{renamed} the return value is ignored when kernel
                         is going to delete name
        """
        return _ida_idp.IDP_Hooks_ev_rename(self, *args)

    def ev_is_far_jump(self, *args) -> "int":
        r"""


        is indirect far jump or call instruction? meaningful only if the
        processor has 'near' and 'far' reference types
        
        ev_is_far_jump(self, icode) -> int
            @param icode (C++: int)
            @retval: 0 - not implemented
            @retval: 1 - yes
            @retval: -1 - no
        """
        return _ida_idp.IDP_Hooks_ev_is_far_jump(self, *args)

    def ev_is_sane_insn(self, *args) -> "int":
        r"""


        Is the instruction sane for the current file type?.
        
        ev_is_sane_insn(self, insn, no_crefs) -> int
            @param insn: the instruction  (C++: const insn_t*)
            @param no_crefs: 1: the instruction has no code refs to it. ida just
                             tries to convert unexplored bytes to an instruction
                             (but there is no other reason to convert them into an
                             instruction) 0: the instruction is created because of
                             some coderef, user request or another weighty reason.
                             (C++: int)
            @retval: >=0 - ok
            @retval: <0 - no, the instruction isn't likely to appear in the
                          program
        """
        return _ida_idp.IDP_Hooks_ev_is_sane_insn(self, *args)

    def ev_is_cond_insn(self, *args) -> "int":
        r"""


        Is conditional instruction?
        
        ev_is_cond_insn(self, insn) -> int
            @param insn: instruction address  (C++: const insn_t *)
            @retval: 1 - yes
            @retval: -1 - no
            @retval: 0 - not implemented or not instruction
        """
        return _ida_idp.IDP_Hooks_ev_is_cond_insn(self, *args)

    def ev_is_call_insn(self, *args) -> "int":
        r"""


        Is the instruction a "call"?
        
        ev_is_call_insn(self, insn) -> int
            @param insn: instruction  (C++: const insn_t *)
            @retval: 0 - unknown
            @retval: <0 - no
            @retval: 1 - yes
        """
        return _ida_idp.IDP_Hooks_ev_is_call_insn(self, *args)

    def ev_is_ret_insn(self, *args) -> "int":
        r"""


        Is the instruction a "return"?
        
        ev_is_ret_insn(self, insn, strict) -> int
            @param insn: instruction  (C++: const insn_t *)
            @param strict: 1: report only ret instructions 0: include instructions
                           like "leave" which begins the function epilog  (C++:
                           bool)
            @retval: 0 - unknown
            @retval: <0 - no
            @retval: 1 - yes
        """
        return _ida_idp.IDP_Hooks_ev_is_ret_insn(self, *args)

    def ev_may_be_func(self, *args) -> "int":
        r"""


        Can a function start here?
        
        ev_may_be_func(self, insn, state) -> int
            @param insn: the instruction  (C++: const insn_t*)
            @param state: autoanalysis phase 0: creating functions 1: creating
                          chunks  (C++: int)
            @return: probability 1..100
        """
        return _ida_idp.IDP_Hooks_ev_may_be_func(self, *args)

    def ev_is_basic_block_end(self, *args) -> "int":
        r"""


        Is the current instruction end of a basic block?. This function should
        be defined for processors with delayed jump slots.
        
        ev_is_basic_block_end(self, insn, call_insn_stops_block) -> int
            @param insn: the instruction  (C++: const insn_t*)
            @param call_insn_stops_block (C++: bool)
            @retval: 0 - unknown
            @retval: <0 - no
            @retval: 1 - yes
        """
        return _ida_idp.IDP_Hooks_ev_is_basic_block_end(self, *args)

    def ev_is_indirect_jump(self, *args) -> "int":
        r"""


        Determine if instruction is an indirect jump. If 'CF_JUMP' bit cannot
        describe all jump types jumps, please define this callback.
        
        ev_is_indirect_jump(self, insn) -> int
            @param insn: the instruction  (C++: const insn_t*)
            @retval: 0 - use  CF_JUMP
            @retval: 1 - no
            @retval: 2 - yes
        """
        return _ida_idp.IDP_Hooks_ev_is_indirect_jump(self, *args)

    def ev_is_insn_table_jump(self, *args) -> "int":
        r"""


        Determine if instruction is a table jump or call. If 'CF_JUMP' bit
        cannot describe all kinds of table jumps, please define this callback.
        It will be called for insns with 'CF_JUMP' bit set.
        
        ev_is_insn_table_jump(self, insn) -> int
            @param insn: the instruction  (C++: const insn_t*)
            @retval: 0 - yes
            @retval: <0 - no
        """
        return _ida_idp.IDP_Hooks_ev_is_insn_table_jump(self, *args)

    def ev_is_switch(self, *args) -> "int":
        r"""


        Find 'switch' idiom. It will be called for instructions marked with
        'CF_JUMP' .
        
        ev_is_switch(self, si, insn) -> int
            @param si: , out  (C++: switch_info_t *)
            @param insn: instruction possibly belonging to a switch  (C++: const
                         insn_t *)
            @retval: 1 - switch is found, 'si' is filled
            @retval: 0 - no switch found or not implemented
        """
        return _ida_idp.IDP_Hooks_ev_is_switch(self, *args)

    def ev_calc_switch_cases(self, *args) -> "int":
        r"""


        Calculate case values and targets for a custom jump table.
        
        ev_calc_switch_cases(self, casevec, targets, insn_ea, si) -> int
            @param casevec: vector of case values (may be NULL)  (C++: casevec_t
                            *)
            @param targets: corresponding target addresses (my be NULL)  (C++:
                            eavec_t *)
            @param insn_ea: address of the 'indirect jump' instruction  (C++:
                            ea_t)
            @param si: switch information  (C++: switch_info_t *)
            @retval: 1 - ok
            @retval: <=0 - failed
        """
        return _ida_idp.IDP_Hooks_ev_calc_switch_cases(self, *args)

    def ev_create_switch_xrefs(self, *args) -> "int":
        r"""


        Create xrefs for a custom jump table.
        
        ev_create_switch_xrefs(self, jumpea, si) -> int
            @param jumpea: address of the jump insn  (C++: ea_t)
            @param si: switch information  (C++: const switch_info_t *)
            @return: must return 1 Must be implemented if module uses custom jump
                     tables,
        """
        return _ida_idp.IDP_Hooks_ev_create_switch_xrefs(self, *args)

    def ev_is_align_insn(self, *args) -> "int":
        r"""


        Is the instruction created only for alignment purposes?. Do not
        directly call this function, use 'is_align_insn()'
        
        ev_is_align_insn(self, ea) -> int
            @param ea: - instruction address  (C++: ea_t)
            @retval: number - of bytes in the instruction
        """
        return _ida_idp.IDP_Hooks_ev_is_align_insn(self, *args)

    def ev_is_alloca_probe(self, *args) -> "int":
        r"""


        Does the function at 'ea' behave as __alloca_probe?
        
        ev_is_alloca_probe(self, ea) -> int
            @param ea (C++: ea_t)
            @retval: 1 - yes
            @retval: 0 - no
        """
        return _ida_idp.IDP_Hooks_ev_is_alloca_probe(self, *args)

    def ev_delay_slot_insn(self, *args) -> "PyObject *":
        r"""


        Get delay slot instructionInput EA may point to the instruction with a
        delay slot or to the delay slot instruction itself.
        
        ev_delay_slot_insn(self, ea, bexec, fexec) -> PyObject *
            @param ea: in: instruction address in question, out: (if the answer is
                       positive) if the delay slot contains valid insn: the
                       address of the delay slot insn else: BADADDR (invalid insn,
                       e.g. a branch)  (C++: ea_t *)
            @param bexec: execute slot if jumping, initially set to 'true'  (C++:
                          bool *)
            @param fexec: execute slot if not jumping, initally set to 'true'
                          (C++: bool *)
            @retval: 1 - positive answer
            @retval: <=0 - ordinary insn
        """
        return _ida_idp.IDP_Hooks_ev_delay_slot_insn(self, *args)

    def ev_is_sp_based(self, *args) -> "int":
        r"""


        Check whether the operand is relative to stack pointer or frame
        pointer This event is used to determine how to output a stack variable
        If not implemented, then all operands are sp based by default.
        Implement this event only if some stack references use frame pointer
        instead of stack pointer.
        
        ev_is_sp_based(self, mode, insn, op) -> int
            @param mode: out, combination of SP/FP operand flags  (C++: int *)
            @param insn (C++: const insn_t *)
            @param op (C++: const op_t *)
            @retval: 0 - not implemented
            @retval: 1 - ok
        """
        return _ida_idp.IDP_Hooks_ev_is_sp_based(self, *args)

    def ev_can_have_type(self, *args) -> "int":
        r"""


        Can the operand have a type as offset, segment, decimal, etc? (for
        example, a register AX can't have a type, meaning that the user can't
        change its representation. see 'bytes.hpp' for information about types
        and flags)
        
        ev_can_have_type(self, op) -> int
            @param op (C++: const op_t *)
            @retval: 0 - unknown
            @retval: <0 - no
            @retval: 1 - yes
        """
        return _ida_idp.IDP_Hooks_ev_can_have_type(self, *args)

    def ev_cmp_operands(self, *args) -> "int":
        r"""


        Compare instruction operands
        
        ev_cmp_operands(self, op1, op2) -> int
            @param op1 (C++: const op_t*)
            @param op2 (C++: const op_t*)
            @retval: 1 - equal
            @retval: -1 - not equal
            @retval: 0 - not implemented
        """
        return _ida_idp.IDP_Hooks_ev_cmp_operands(self, *args)

    def ev_adjust_refinfo(self, *args) -> "int":
        r"""


        Called from apply_fixup before converting operand to reference. Can be
        used for changing the reference info. (e.g. the PPC module adds
        REFINFO_NOBASE for some references)
        
        ev_adjust_refinfo(self, ri, ea, n, fd) -> int
            @param ri (C++: refinfo_t *)
            @param ea: instruction address  (C++: ea_t)
            @param n: operand number  (C++: int)
            @param fd (C++: const fixup_data_t *)
            @retval: <0 - do not create an offset
            @retval: 0 - not implemented or refinfo adjusted
        """
        return _ida_idp.IDP_Hooks_ev_adjust_refinfo(self, *args)

    def ev_get_operand_string(self, *args) -> "PyObject *":
        r"""


        Request text string for operand (cli, java, ...).
        
        ev_get_operand_string(self, insn, opnum) -> PyObject *
            @param insn: the instruction  (C++: const insn_t*)
            @param opnum: operand number, -1 means any string operand  (C++: int)
            @retval: 0 - no string (or empty string)
            @retval: >0 - original string length without terminating zero
        """
        return _ida_idp.IDP_Hooks_ev_get_operand_string(self, *args)

    def ev_get_reg_name(self, *args) -> "PyObject *":
        r"""


        Generate text representation of a register. Most processor modules do
        not need to implement this callback. It is useful only if
        \ph{reg_names}[reg] does not provide the correct register name.
        
        ev_get_reg_name(self, reg, width, reghi) -> PyObject *
            @param reg: internal register number as defined in the processor
                        module  (C++: int)
            @param width: register width in bytes  (C++: size_t)
            @param reghi: if not -1 then this function will return the register
                          pair  (C++: int)
            @retval: -1 - if error
            @retval: strlen(buf) - if success
        """
        return _ida_idp.IDP_Hooks_ev_get_reg_name(self, *args)

    def ev_str2reg(self, *args) -> "int":
        r"""


        Convert a register name to a register number. The register number is
        the register index in the \ph{reg_names} array Most processor modules
        do not need to implement this callback It is useful only if
        \ph{reg_names}[reg] does not provide the correct register names
        
        ev_str2reg(self, regname) -> int
            @param regname (C++: const char *)
            @retval: register - number + 1
            @retval: 0 - not implemented or could not be decoded
        """
        return _ida_idp.IDP_Hooks_ev_str2reg(self, *args)

    def ev_get_autocmt(self, *args) -> "PyObject *":
        r"""


        Callback: get dynamic auto comment. Will be called if the autocomments
        are enabled and the comment retrieved from ida.int starts with '$!'.
        'insn' contains valid info.
        
        ev_get_autocmt(self, insn) -> PyObject *
            @param insn: the instruction  (C++: const insn_t*)
            @retval: 1 - new comment has been generated
            @retval: 0 - callback has not been handled. the buffer must not be
                         changed in this case
        """
        return _ida_idp.IDP_Hooks_ev_get_autocmt(self, *args)

    def ev_get_bg_color(self, *args) -> "int":
        r"""


        Get item background color. Plugins can hook this callback to color
        disassembly lines dynamically
        
        ev_get_bg_color(self, ea) -> int or None
            @param color: , out  (C++: bgcolor_t *)
            @param ea (C++: ea_t)
            @retval: 0 - not implemented
            @retval: 1 - color set
        """
        return _ida_idp.IDP_Hooks_ev_get_bg_color(self, *args)

    def ev_is_jump_func(self, *args) -> "int":
        r"""


        Is the function a trivial "jump" function?.
        
        ev_is_jump_func(self, pfn, jump_target, func_pointer) -> int
            @param pfn (C++: func_t *)
            @param jump_target (C++: ea_t *)
            @param func_pointer (C++: ea_t *)
            @retval: <0 - no
            @retval: 0 - don't know
            @retval: 1 - yes, see 'jump_target' and 'func_pointer'
        """
        return _ida_idp.IDP_Hooks_ev_is_jump_func(self, *args)

    def ev_func_bounds(self, *args) -> "int":
        r"""


        'find_func_bounds()' finished its work. The module may fine tune the
        function bounds
        
        ev_func_bounds(self, possible_return_code, pfn, max_func_end_ea) -> int
            @param possible_return_code: , in/out  (C++: int *)
            @param pfn (C++: func_t *)
            @param max_func_end_ea: (from the kernel's point of view)  (C++: ea_t)
            @retval: void -
        """
        return _ida_idp.IDP_Hooks_ev_func_bounds(self, *args)

    def ev_verify_sp(self, *args) -> "int":
        r"""


        All function instructions have been analyzed. Now the processor module
        can analyze the stack pointer for the whole function
        
        ev_verify_sp(self, pfn) -> int
            @param pfn (C++: func_t *)
            @retval: 0 - ok
            @retval: <0 - bad stack pointer
        """
        return _ida_idp.IDP_Hooks_ev_verify_sp(self, *args)

    def ev_verify_noreturn(self, *args) -> "int":
        r"""


        The kernel wants to set 'noreturn' flags for a function.
        
        ev_verify_noreturn(self, pfn) -> int
            @param pfn (C++: func_t *)
            @retval: 0 - ok. any other value: do not set 'noreturn' flag
        """
        return _ida_idp.IDP_Hooks_ev_verify_noreturn(self, *args)

    def ev_create_func_frame(self, *args) -> "int":
        r"""


        Create a function frame for a newly created function Set up frame
        size, its attributes etc
        
        ev_create_func_frame(self, pfn) -> int
            @param pfn (C++: func_t *)
            @retval: 1 - ok
            @retval: 0 - not implemented
        """
        return _ida_idp.IDP_Hooks_ev_create_func_frame(self, *args)

    def ev_get_frame_retsize(self, *args) -> "int":
        r"""


        Get size of function return address in bytes If this event is not
        implemented, the kernel will assume8 bytes for 64-bit function4 bytes
        for 32-bit function2 bytes otherwise
        
        ev_get_frame_retsize(self, frsize, pfn) -> int
            @param frsize: frame size (out)  (C++: int *)
            @param pfn: , can't be NULL  (C++: const func_t *)
        """
        return _ida_idp.IDP_Hooks_ev_get_frame_retsize(self, *args)

    def ev_get_stkvar_scale_factor(self, *args) -> "int":
        r"""


        Should stack variable references be multiplied by a coefficient before
        being used in the stack frame?. Currently used by TMS320C55 because
        the references into the stack should be multiplied by 2
        'PR_SCALE_STKVARS' should be set to use this callback
        """
        return _ida_idp.IDP_Hooks_ev_get_stkvar_scale_factor(self, *args)

    def ev_demangle_name(self, *args) -> "PyObject *":
        r"""


        Demangle a C++ (or another language) name into a user-readable string.
        This event is called by 'demangle_name()' if you call
        'demangle_name()' from the handler, protect against recursion!
        
        ev_demangle_name(self, name, disable_mask, demreq) -> PyObject *
            @param name: mangled name  (C++: const char *)
            @param disable_mask: flags to inhibit parts of output or compiler
                                 info/other (see MNG_)  (C++: uint32)
            @param demreq: operation to perform  (C++: demreq_type_t)
            @retval: 1 - if success
            @retval: 0 - not implemented
        """
        return _ida_idp.IDP_Hooks_ev_demangle_name(self, *args)

    def ev_add_cref(self, *args) -> "int":
        r"""


        A code reference is being created.
        
        ev_add_cref(self, _from, to, type) -> int
            @param _from (C++: ea_t)
            @param to (C++: ea_t)
            @param type (C++: cref_t)
            @retval: <0 - cancel cref creation
            @retval: 0 - not implemented or continue
        """
        return _ida_idp.IDP_Hooks_ev_add_cref(self, *args)

    def ev_add_dref(self, *args) -> "int":
        r"""


        A data reference is being created.
        
        ev_add_dref(self, _from, to, type) -> int
            @param _from (C++: ea_t)
            @param to (C++: ea_t)
            @param type (C++: dref_t)
            @retval: <0 - cancel dref creation
            @retval: 0 - not implemented or continue
        """
        return _ida_idp.IDP_Hooks_ev_add_dref(self, *args)

    def ev_del_cref(self, *args) -> "int":
        r"""


        A code reference is being deleted.
        
        ev_del_cref(self, _from, to, expand) -> int
            @param _from (C++: ea_t)
            @param to (C++: ea_t)
            @param expand (C++: bool)
            @retval: <0 - cancel cref deletion
            @retval: 0 - not implemented or continue
        """
        return _ida_idp.IDP_Hooks_ev_del_cref(self, *args)

    def ev_del_dref(self, *args) -> "int":
        r"""


        A data reference is being deleted.
        
        ev_del_dref(self, _from, to) -> int
            @param _from (C++: ea_t)
            @param to (C++: ea_t)
            @retval: <0 - cancel dref deletion
            @retval: 0 - not implemented or continue
        """
        return _ida_idp.IDP_Hooks_ev_del_dref(self, *args)

    def ev_coagulate_dref(self, *args) -> "int":
        r"""


        Data reference is being analyzed. plugin may correct 'code_ea' (e.g.
        for thumb mode refs, we clear the last bit)
        
        ev_coagulate_dref(self, _from, to, may_define, code_ea) -> int
            @param _from (C++: ea_t)
            @param to (C++: ea_t)
            @param may_define (C++: bool)
            @param code_ea (C++: ea_t *)
            @retval: <0 - cancel dref analysis
            @retval: 0 - not implemented or continue
        """
        return _ida_idp.IDP_Hooks_ev_coagulate_dref(self, *args)

    def ev_may_show_sreg(self, *args) -> "int":
        r"""


        The kernel wants to display the segment registers in the messages
        window.
        
        ev_may_show_sreg(self, current_ea) -> int
            @param current_ea (C++: ea_t)
            @retval: <0 - if the kernel should not show the segment registers.
                          (assuming that the module has done it)
            @retval: 0 - not implemented
        """
        return _ida_idp.IDP_Hooks_ev_may_show_sreg(self, *args)

    def ev_auto_queue_empty(self, *args) -> "int":
        r"""


        One analysis queue is empty.
        
        ev_auto_queue_empty(self, type) -> int
            @param type (C++: atype_t)
            @retval: void - see also  idb_event::auto_empty_finally
        """
        return _ida_idp.IDP_Hooks_ev_auto_queue_empty(self, *args)

    def ev_validate_flirt_func(self, *args) -> "int":
        r"""


        Flirt has recognized a library function. This callback can be used by
        a plugin or proc module to intercept it and validate such a function.
        
        ev_validate_flirt_func(self, start_ea, funcname) -> int
            @param start_ea (C++: ea_t)
            @param funcname (C++: const char *)
            @retval: -1 - do not create a function,
            @retval: 0 - function is validated
        """
        return _ida_idp.IDP_Hooks_ev_validate_flirt_func(self, *args)

    def ev_adjust_libfunc_ea(self, *args) -> "int":
        r"""


        Called when a signature module has been matched against bytes in the
        database. This is used to compute the offset at which a particular
        module's libfunc should be applied.'ea' initially contains the ea_t of
        the start of the pattern match
        
        ev_adjust_libfunc_ea(self, sig, libfun, ea) -> int
            @param sig (C++: const idasgn_t *)
            @param libfun (C++: const libfunc_t *)
            @param ea (C++: ea_t *)
            @retval: 1 - the ea_t pointed to by the third argument was modified.
            @retval: <=0 - not modified. use default algorithm.
        """
        return _ida_idp.IDP_Hooks_ev_adjust_libfunc_ea(self, *args)

    def ev_assemble(self, *args) -> "PyObject *":
        r"""


        Assemble an instruction. (display a warning if an error is found).
        
        ev_assemble(self, ea, cs, ip, use32, line) -> PyObject *
            @param ea: linear address of instruction  (C++: ea_t)
            @param cs: cs of instruction  (C++: ea_t)
            @param ip: ip of instruction  (C++: ea_t)
            @param use32: is 32bit segment?  (C++: bool)
            @param line: line to assemble  (C++: const char *)
        """
        return _ida_idp.IDP_Hooks_ev_assemble(self, *args)

    def ev_extract_address(self, *args) -> "int":
        r"""


        Extract address from a string.
        
        ev_extract_address(self, out_ea, screen_ea, string, position) -> int
            @param out_ea: , out  (C++: ea_t *)
            @param screen_ea (C++: ea_t)
            @param string (C++: const char *)
            @param position (C++: size_t)
            @retval: 1 - ok
            @retval: 0 - kernel should use the standard algorithm
            @retval: -1 - error
        """
        return _ida_idp.IDP_Hooks_ev_extract_address(self, *args)

    def ev_realcvt(self, *args) -> "int":
        r"""


        Floating point -> IEEE conversion
        
        ev_realcvt(self, m, e, swt) -> int
            @param m: pointer to data  (C++: void *)
            @param e: internal IEEE format data  (C++: uint16 *)
            @param swt: operation (see realcvt() in ieee.h)  (C++: uint16)
            @retval: 0 - not implemented
            @retval: 1 - ok
        """
        return _ida_idp.IDP_Hooks_ev_realcvt(self, *args)

    def ev_gen_asm_or_lst(self, *args) -> "int":
        r"""


        Callback: generating asm or lst file. The kernel calls this callback
        twice, at the beginning and at the end of listing generation. The
        processor module can intercept this event and adjust its output
        
        ev_gen_asm_or_lst(self, starting, fp, is_asm, flags, outline) -> int
            @param starting: beginning listing generation  (C++: bool)
            @param fp: output file  (C++: FILE *)
            @param is_asm: true:assembler, false:listing  (C++: bool)
            @param flags: flags passed to gen_file()  (C++: int)
            @param outline: ptr to ptr to outline callback. if this callback is
                            defined for this code, it will be used by the kernel
                            to output the generated lines  (C++: html_line_cb_t
                            **)
            @retval: void -
        """
        return _ida_idp.IDP_Hooks_ev_gen_asm_or_lst(self, *args)

    def ev_gen_map_file(self, *args) -> "int":
        r"""


        Generate map file. If not implemented the kernel itself will create
        the map file.
        
        ev_gen_map_file(self, nlines, fp) -> int
            @param nlines: number of lines in map file (-1 means write error)
                           (C++: int *)
            @param fp: output file  (C++: FILE *)
            @retval: 0 - not implemented
            @retval: 1 - ok
            @retval: -1 - write error
        """
        return _ida_idp.IDP_Hooks_ev_gen_map_file(self, *args)

    def ev_create_flat_group(self, *args) -> "int":
        r"""


        Create special segment representing the flat group.
        
        ev_create_flat_group(self, image_base, bitness, dataseg_sel) -> int
            @param image_base (C++: ea_t)
            @param bitness (C++: int)
            @param dataseg_sel: return value is ignored  (C++: sel_t)
        """
        return _ida_idp.IDP_Hooks_ev_create_flat_group(self, *args)

    def ev_getreg(self, *args) -> "int":
        r"""


        IBM PC only internal request, should never be used for other purpose
        Get register value by internal index
        
        ev_getreg(self, regval, regnum) -> int
            @param regval: , out  (C++: uval_t *)
            @param regnum (C++: int)
            @retval: 1 - ok
            @retval: 0 - not implemented
            @retval: -1 - failed (undefined value or bad regnum)
        """
        return _ida_idp.IDP_Hooks_ev_getreg(self, *args)

    def ev_analyze_prolog(self, *args) -> "int":
        r"""


        Analyzes function prolog, epilog, and updates purge, and function
        attributes
        
        ev_analyze_prolog(self, ea) -> int
            @param ea: start of function  (C++: ea_t)
            @retval: 1 - ok
            @retval: 0 - not implemented
        """
        return _ida_idp.IDP_Hooks_ev_analyze_prolog(self, *args)

    def ev_calc_spdelta(self, *args) -> "int":
        r"""


        Calculate amount of change to sp for the given insn. This event is
        required to decompile code snippets.
        
        ev_calc_spdelta(self, spdelta, insn) -> int
            @param spdelta (C++: sval_t *)
            @param insn (C++: const insn_t *)
            @retval: 1 - ok
            @retval: 0 - not implemented
        """
        return _ida_idp.IDP_Hooks_ev_calc_spdelta(self, *args)

    def ev_calcrel(self, *args) -> "int":
        r"""


        Reserved.
        """
        return _ida_idp.IDP_Hooks_ev_calcrel(self, *args)

    def ev_find_reg_value(self, *args) -> "PyObject *":
        r"""


        Find register value via a register tracker. The returned value in
        'out' is valid before executing the instruction.
        
        ev_find_reg_value(self, pinsn, reg) -> PyObject *
            @param pinsn: instruction  (C++: const insn_t *)
            @param reg: register index  (C++: int)
            @retval: 1 - if implemented, and value was found
            @retval: 0 - not implemented, -1 decoding failed, or no value found
        """
        return _ida_idp.IDP_Hooks_ev_find_reg_value(self, *args)

    def ev_find_op_value(self, *args) -> "PyObject *":
        r"""


        Find operand value via a register tracker. The returned value in 'out'
        is valid before executing the instruction.
        
        ev_find_op_value(self, pinsn, opn) -> PyObject *
            @param pinsn: instruction  (C++: const insn_t *)
            @param opn: operand index  (C++: int)
            @retval: 1 - if implemented, and value was found
            @retval: 0 - not implemented, -1 decoding failed, or no value found
        """
        return _ida_idp.IDP_Hooks_ev_find_op_value(self, *args)

    def ev_replaying_undo(self, *args) -> "int":
        r"""


        Replaying an undo/redo buffer
        
        ev_replaying_undo(self, action_name, vec, is_undo) -> int
            @param action_name: action that we perform undo/redo for. may be NULL
                                for intermediary buffers.  (C++: const char *)
            @param vec (C++: const undo_records_t *)
            @param is_undo: true if performing undo, false if performing redo This
                            event may be generated multiple times per undo/redo
                            (C++: bool)
        """
        return _ida_idp.IDP_Hooks_ev_replaying_undo(self, *args)

    def ev_ending_undo(self, *args) -> "int":
        r"""


        Ended undoing/redoing an action
        
        ev_ending_undo(self, action_name, is_undo) -> int
            @param action_name: action that we finished undoing/redoing. is not
                                NULL.  (C++: const char *)
            @param is_undo: true if performing undo, false if performing redo
                            (C++: bool)
        """
        return _ida_idp.IDP_Hooks_ev_ending_undo(self, *args)

    def ev_set_code16_mode(self, *args) -> "int":
        r"""


        Some processors have ISA 16-bit mode e.g. ARM Thumb mode, PPC VLE,
        MIPS16 Set ISA 16-bit mode
        
        ev_set_code16_mode(self, ea, code16) -> int
            @param ea: address to set new ISA mode  (C++: ea_t)
            @param code16: true for 16-bit mode, false for 32-bit mode  (C++:
                           bool)
        """
        return _ida_idp.IDP_Hooks_ev_set_code16_mode(self, *args)

    def ev_get_code16_mode(self, *args) -> "int":
        r"""


        Get ISA 16-bit mode
        
        ev_get_code16_mode(self, ea) -> int
            @param ea: address to get the ISA mode  (C++: ea_t)
            @retval: 1 - 16-bit mode
            @retval: 0 - not implemented or 32-bit mode
        """
        return _ida_idp.IDP_Hooks_ev_get_code16_mode(self, *args)

    def ev_get_procmod(self, *args) -> "int":
        r"""


        Get pointer to the processor module object. All processor modules must
        implement this. The pointer is returned as size_t.
        """
        return _ida_idp.IDP_Hooks_ev_get_procmod(self, *args)

    def ev_asm_installed(self, *args) -> "int":
        r"""


        After setting a new assembler
        
        ev_asm_installed(self, asmnum) -> int
            @param asmnum: See also ev_newasm  (C++: int)
        """
        return _ida_idp.IDP_Hooks_ev_asm_installed(self, *args)

    def ev_get_reg_accesses(self, *args) -> "int":
        r"""


        Get info about the registers that are used/changed by an instruction.
        
        ev_get_reg_accesses(self, accvec, insn, flags) -> int
            @param accvec: out: info about accessed registers  (C++:
                           reg_accesses_t*)
            @param insn: instruction in question  (C++: const insn_t *)
            @param flags: reserved, must be 0  (C++: int)
            @retval: -1 - if accvec is nullptr
            @retval: 1 - found the requested access (and filled accvec)
            @retval: 0 - not implemented
        """
        return _ida_idp.IDP_Hooks_ev_get_reg_accesses(self, *args)

    def ev_next_exec_insn(self, *args) -> "int":
        r"""


        Get next address to be executed This function must return the next
        address to be executed. If the instruction following the current one
        is executed, then it must return 'BADADDR' Usually the instructions to
        consider are: jumps, branches, calls, returns. This function is
        essential if the 'single step' is not supported in hardware.
        
        ev_next_exec_insn(self, target, ea, tid, getreg, regvalues) -> int
            @param target: , out: pointer to the answer  (C++: ea_t *)
            @param ea: instruction address  (C++: ea_t)
            @param tid: current therad id  (C++: int)
            @param getreg: function to get register values  (C++:
                           processor_t::regval_getter_t *)
            @param regvalues: register values array  (C++: const regval_t *)
            @retval: 0 - unimplemented
            @retval: 1 - implemented
        """
        return _ida_idp.IDP_Hooks_ev_next_exec_insn(self, *args)

    def ev_calc_step_over(self, *args) -> "int":
        r"""


        Calculate the address of the instruction which will be executed after
        "step over". The kernel will put a breakpoint there. If the step over
        is equal to step into or we cannot calculate the address, return
        'BADADDR' .
        
        ev_calc_step_over(self, target, ip) -> int
            @param target: pointer to the answer  (C++: ea_t *)
            @param ip: instruction address  (C++: ea_t)
            @retval: 0 - unimplemented
            @retval: 1 - implemented
        """
        return _ida_idp.IDP_Hooks_ev_calc_step_over(self, *args)

    def ev_calc_next_eas(self, *args) -> "int":
        r"""


        Calculate list of addresses the instruction in 'insn' may pass control
        to. This callback is required for source level debugging.
        
        ev_calc_next_eas(self, res, insn, over) -> int
            @param res: , out: array for the results.  (C++: eavec_t *)
            @param insn: the instruction  (C++: const insn_t*)
            @param over: calculate for step over (ignore call targets)  (C++:
                         bool)
            @retval: <0 - incalculable (indirect jumps, for example)
            @retval: >=0 - number of addresses of called functions in the array.
                           They must be put at the beginning of the array (0 if
                           over=true)
        """
        return _ida_idp.IDP_Hooks_ev_calc_next_eas(self, *args)

    def ev_get_macro_insn_head(self, *args) -> "int":
        r"""


        Calculate the start of a macro instruction. This notification is
        called if IP points to the middle of an instruction
        
        ev_get_macro_insn_head(self, head, ip) -> int
            @param head: , out: answer, BADADDR means normal instruction  (C++:
                         ea_t *)
            @param ip: instruction address  (C++: ea_t)
            @retval: 0 - unimplemented
            @retval: 1 - implemented
        """
        return _ida_idp.IDP_Hooks_ev_get_macro_insn_head(self, *args)

    def ev_get_dbr_opnum(self, *args) -> "int":
        r"""


        Get the number of the operand to be displayed in the debugger
        reference view (text mode).
        
        ev_get_dbr_opnum(self, opnum, insn) -> int
            @param opnum: operand number (out, -1 means no such operand)  (C++:
                          int *)
            @param insn: the instruction  (C++: const insn_t*)
            @retval: 0 - unimplemented
            @retval: 1 - implemented
        """
        return _ida_idp.IDP_Hooks_ev_get_dbr_opnum(self, *args)

    def ev_insn_reads_tbit(self, *args) -> "int":
        r"""


        Check if insn will read the TF bit.
        
        ev_insn_reads_tbit(self, insn, getreg, regvalues) -> int
            @param insn: the instruction  (C++: const insn_t*)
            @param getreg: function to get register values  (C++:
                           processor_t::regval_getter_t *)
            @param regvalues: register values array  (C++: const regval_t *)
            @retval: 2 - yes, will generate 'step' exception
            @retval: 1 - yes, will store the TF bit in memory
            @retval: 0 - no
        """
        return _ida_idp.IDP_Hooks_ev_insn_reads_tbit(self, *args)

    def ev_clean_tbit(self, *args) -> "int":
        r"""


        Clear the TF bit after an insn like pushf stored it in memory.
        
        ev_clean_tbit(self, ea, getreg, regvalues) -> int
            @param ea: instruction address  (C++: ea_t)
            @param getreg: function to get register values  (C++:
                           processor_t::regval_getter_t *)
            @param regvalues: register values array  (C++: const regval_t *)
            @retval: 1 - ok
            @retval: 0 - failed
        """
        return _ida_idp.IDP_Hooks_ev_clean_tbit(self, *args)

    def ev_get_reg_info(self, *args) -> "int":
        r"""


        Get register information by its name. example: "ah"
        returns:main_regname="eax" 'bitrange_t' = { offset==8, nbits==8 }This
        callback may be unimplemented if the register names are all present in
        \ph{reg_names} and they all have the same size
        
        ev_get_reg_info(self, main_regname, bitrange, regname) -> int
            @param main_regname: , out  (C++: const char **)
            @param bitrange: , out: position and size of the value within
                             'main_regname' (empty bitrange == whole register)
                             (C++: bitrange_t *)
            @param regname (C++: const char *)
            @retval: 1 - ok
            @retval: -1 - failed (not found)
            @retval: 0 - unimplemented
        """
        return _ida_idp.IDP_Hooks_ev_get_reg_info(self, *args)

    def ev_setup_til(self, *args) -> "int":
        r"""


        Setup default type libraries. (called after loading a new file into
        the database). The processor module may load tils, setup memory model
        and perform other actions required to set up the type system. This is
        an optional callback.
        """
        return _ida_idp.IDP_Hooks_ev_setup_til(self, *args)

    def ev_get_abi_info(self, *args) -> "int":
        r"""


        Get all possible ABI names and optional extensions for given compiler
        abiname/option is a string entirely consisting of letters, digits and
        underscore
        
        ev_get_abi_info(self, abi_names, abi_opts, comp) -> int
            @param abi_names: - all possible ABis each in form abiname-
                              opt1-opt2-...  (C++: qstrvec_t *)
            @param abi_opts: - array of all possible options in form
                             "opt:description" or opt:hint-line#description  (C++:
                             qstrvec_t *)
            @param comp: - compiler ID  (C++: comp_t)
            @retval: 0 - not implemented
            @retval: 1 - ok
        """
        return _ida_idp.IDP_Hooks_ev_get_abi_info(self, *args)

    def ev_max_ptr_size(self, *args) -> "int":
        r"""


        Get maximal size of a pointer in bytes.
        """
        return _ida_idp.IDP_Hooks_ev_max_ptr_size(self, *args)

    def ev_get_default_enum_size(self, *args) -> "int":
        r"""


        Get default enum size. Not generated anymore. inf_get_cc_size_e() is
        used instead
        """
        return _ida_idp.IDP_Hooks_ev_get_default_enum_size(self, *args)

    def ev_get_cc_regs(self, *args) -> "int":
        r"""


        Get register allocation convention for given calling convention
        
        ev_get_cc_regs(self, regs, cc) -> int
            @param regs: , out  (C++: callregs_t *)
            @param cc (C++: cm_t)
            @retval: 1 -
            @retval: 0 - not implemented
        """
        return _ida_idp.IDP_Hooks_ev_get_cc_regs(self, *args)

    def ev_get_stkarg_offset(self, *args) -> "int":
        r"""


        Get offset from SP to the first stack argument. For example: pc: 0,
        hppa: -0x34, ppc: 0x38
        """
        return _ida_idp.IDP_Hooks_ev_get_stkarg_offset(self, *args)

    def ev_shadow_args_size(self, *args) -> "int":
        r"""


        Get size of shadow args in bytes.
        
        ev_shadow_args_size(self, shadow_args_size, pfn) -> int
            @param shadow_args_size (C++: int *)
            @param pfn: (may be NULL)  (C++: func_t *)
            @retval: 1 - if filled *shadow_args_size
            @retval: 0 - not implemented
        """
        return _ida_idp.IDP_Hooks_ev_shadow_args_size(self, *args)

    def ev_get_simd_types(self, *args) -> "int":
        r"""


        Get SIMD-related types according to given attributes ant/or argument
        location
        
        ev_get_simd_types(self, out, simd_attrs, argloc, create_tifs) -> int
            @param out (C++: simd_info_vec_t *)
            @param simd_attrs: , may be NULL  (C++: const simd_info_t *)
            @param argloc: , may be NULL  (C++: const argloc_t *)
            @param create_tifs: return valid tinfo_t objects, create if neccessary
                                (C++: bool)
            @retval: number - of found types
            @retval: -1 - error If name==NULL, initialize all SIMD types
        """
        return _ida_idp.IDP_Hooks_ev_get_simd_types(self, *args)

    def ev_calc_cdecl_purged_bytes(self, *args) -> "int":
        r"""


        Calculate number of purged bytes after call.
        
        ev_calc_cdecl_purged_bytes(self, ea) -> int
            @param ea: address of the call instruction  (C++: ea_t)
            @return: number of purged bytes (usually add sp, N)
        """
        return _ida_idp.IDP_Hooks_ev_calc_cdecl_purged_bytes(self, *args)

    def ev_calc_purged_bytes(self, *args) -> "int":
        r"""


        Calculate number of purged bytes by the given function type.
        
        ev_calc_purged_bytes(self, p_purged_bytes, fti) -> int
            @param p_purged_bytes: ptr to output  (C++: int *)
            @param fti: func type details  (C++: const func_type_data_t *)
            @retval: 1 -
            @retval: 0 - not implemented
        """
        return _ida_idp.IDP_Hooks_ev_calc_purged_bytes(self, *args)

    def ev_calc_retloc(self, *args) -> "int":
        r"""


        Calculate return value location.
        
        ev_calc_retloc(self, retloc, rettype, cc) -> int
            @param retloc (C++: argloc_t *)
            @param rettype (C++: const tinfo_t *)
            @param cc (C++: cm_t)
            @retval: 0 - not implemented
            @retval: 1 - ok,
            @retval: -1 - error
        """
        return _ida_idp.IDP_Hooks_ev_calc_retloc(self, *args)

    def ev_calc_arglocs(self, *args) -> "int":
        r"""


        Calculate function argument locations. This callback should fill
        retloc, all arglocs, and stkargs. This callback is never called for
        'CM_CC_SPECIAL' functions.
        
        ev_calc_arglocs(self, fti) -> int
            @param fti: points to the func type info  (C++: func_type_data_t *)
            @retval: 0 - not implemented
            @retval: 1 - ok
            @retval: -1 - error
        """
        return _ida_idp.IDP_Hooks_ev_calc_arglocs(self, *args)

    def ev_calc_varglocs(self, *args) -> "int":
        r"""


        Calculate locations of the arguments that correspond to '...'.
        
        ev_calc_varglocs(self, ftd, aux_regs, aux_stkargs, nfixed) -> int
            @param ftd: , inout: info about all arguments (including varargs)
                        (C++: func_type_data_t *)
            @param aux_regs: buffer for hidden register arguments, may be NULL
                             (C++: regobjs_t *)
            @param aux_stkargs: buffer for hidden stack arguments, may be NULL
                                (C++: relobj_t *)
            @param nfixed: number of fixed arguments  (C++: int)
            @retval: 0 - not implemented
            @retval: 1 - ok
            @retval: -1 - error On some platforms variadic calls require passing
                          additional information: for example, number of floating
                          variadic arguments must be passed in rax on gcc-x64. The
                          locations and values that constitute this additional
                          information are returned in the buffers pointed by
                          aux_regs and aux_stkargs
        """
        return _ida_idp.IDP_Hooks_ev_calc_varglocs(self, *args)

    def ev_adjust_argloc(self, *args) -> "int":
        r"""


        Adjust argloc according to its type/size and platform endianess
        
        ev_adjust_argloc(self, argloc, optional_type, size) -> int
            @param argloc: , inout  (C++: argloc_t *)
            optional_type: tinfo_t const *
            @param size: 'size' makes no sense if type != NULL (type->get_size()
                         should be used instead)  (C++: int)
            @retval: 0 - not implemented
            @retval: 1 - ok
            @retval: -1 - error
        """
        return _ida_idp.IDP_Hooks_ev_adjust_argloc(self, *args)

    def ev_lower_func_type(self, *args) -> "int":
        r"""


        Get function arguments which should be converted to pointers when
        lowering function prototype. The processor module can also modify
        'fti' in order to make non-standard conversion of some arguments.
        
        ev_lower_func_type(self, argnums, fti) -> int
            @param argnums: , out - numbers of arguments to be converted to
                            pointers in acsending order  (C++: intvec_t *)
            @param fti: , inout func type details (special values -1/-2 for return
                        value - position of hidden 'retstr' argument: -1 - at the
                        beginning, -2 - at the end)  (C++: func_type_data_t *)
            @retval: 0 - not implemented
            @retval: 1 - argnums was filled
            @retval: 2 - argnums was filled and made substantial changes to fti
        """
        return _ida_idp.IDP_Hooks_ev_lower_func_type(self, *args)

    def ev_equal_reglocs(self, *args) -> "int":
        r"""


        Are 2 register arglocs the same?. We need this callback for the pc
        module.
        
        ev_equal_reglocs(self, a1, a2) -> int
            @param a1 (C++: argloc_t *)
            @param a2 (C++: argloc_t *)
            @retval: 1 - yes
            @retval: -1 - no
            @retval: 0 - not implemented
        """
        return _ida_idp.IDP_Hooks_ev_equal_reglocs(self, *args)

    def ev_use_stkarg_type(self, *args) -> "int":
        r"""


        Use information about a stack argument.
        
        ev_use_stkarg_type(self, ea, arg) -> int
            @param ea: address of the push instruction which pushes the function
                       argument into the stack  (C++: ea_t)
            @param arg: argument info  (C++: const funcarg_t *)
            @retval: 1 - ok
            @retval: <=0 - failed, the kernel will create a comment with the
                           argument name or type for the instruction
        """
        return _ida_idp.IDP_Hooks_ev_use_stkarg_type(self, *args)

    def ev_use_regarg_type(self, *args) -> "PyObject *":
        r"""


        Use information about register argument.
        
        ev_use_regarg_type(self, ea, rargs) -> PyObject *
            @param ea: address of the instruction  (C++: ea_t)
            @param rargs: vector of register arguments (including regs extracted
                          from scattered arguments)  (C++: const funcargvec_t *)
            @retval: 1 -
            @retval: 0 - not implemented
        """
        return _ida_idp.IDP_Hooks_ev_use_regarg_type(self, *args)

    def ev_use_arg_types(self, *args) -> "int":
        r"""


        Use information about callee arguments.
        
        ev_use_arg_types(self, ea, fti, rargs) -> int
            @param ea: address of the call instruction  (C++: ea_t)
            @param fti: info about function type  (C++: func_type_data_t *)
            @param rargs: array of register arguments  (C++: funcargvec_t *)
            @retval: 1 - (and removes handled arguments from fti and rargs)
            @retval: 0 - not implemented
        """
        return _ida_idp.IDP_Hooks_ev_use_arg_types(self, *args)

    def ev_arg_addrs_ready(self, *args) -> "int":
        r"""


        Argument address info is ready.
        
        ev_arg_addrs_ready(self, caller, n, tif, addrs) -> int
            @param caller (C++: ea_t)
            @param n: number of formal arguments  (C++: int)
            @param tif: call prototype  (C++: tinfo_t *)
            @param addrs: argument intilization addresses  (C++: ea_t *)
            @retval: <0 - do not save into idb; other values mean "ok to save"
        """
        return _ida_idp.IDP_Hooks_ev_arg_addrs_ready(self, *args)

    def ev_decorate_name(self, *args) -> "PyObject *":
        r"""


        Decorate/undecorate a C symbol name.
        
        ev_decorate_name(self, name, mangle, cc, optional_type) -> PyObject *
            @param name: name of symbol  (C++: const char *)
            @param mangle: true-mangle, false-unmangle  (C++: bool)
            @param cc: calling convention  (C++: cm_t)
            optional_type: tinfo_t const *
            @retval: 1 - if success
            @retval: 0 - not implemented or failed
        """
        return _ida_idp.IDP_Hooks_ev_decorate_name(self, *args)

    def ev_arch_changed(self, *args) -> "int":
        r"""


        The loader is done parsing arch-related information, which the
        processor module might want to use to finish its initialization.
        """
        return _ida_idp.IDP_Hooks_ev_arch_changed(self, *args)

    def ev_last_cb_before_loader(self, *args) -> "int":
        r"""
        ev_last_cb_before_loader(self) -> int
        """
        return _ida_idp.IDP_Hooks_ev_last_cb_before_loader(self, *args)

    def ev_loader(self, *args) -> "int":
        r"""


        This code and higher ones are reserved for the loaders. The arguments
        and the return values are defined by the loaders
        """
        return _ida_idp.IDP_Hooks_ev_loader(self, *args)
    __swig_destroy__ = _ida_idp.delete_IDP_Hooks
    def __disown__(self):
        self.this.disown()
        _ida_idp.disown_IDP_Hooks(self)
        return weakref.proxy(self)

# Register IDP_Hooks in _ida_idp:
_ida_idp.IDP_Hooks_swigregister(IDP_Hooks)


def get_idp_notifier_addr(*args) -> "PyObject *":
    r"""


    get_idp_notifier_addr(arg1) -> PyObject *
        arg1: PyObject *
    """
    return _ida_idp.get_idp_notifier_addr(*args)

def get_idp_notifier_ud_addr(*args) -> "PyObject *":
    r"""


    get_idp_notifier_ud_addr(hooks) -> PyObject *
        hooks: IDP_Hooks *
    """
    return _ida_idp.get_idp_notifier_ud_addr(*args)

def delay_slot_insn(*args) -> "bool":
    r"""


    delay_slot_insn(ea, bexec, fexec) -> bool
        ea: ea_t *
        bexec: bool *
        fexec: bool *
    """
    return _ida_idp.delay_slot_insn(*args)

def get_reg_info(*args) -> "char const *":
    r"""


    get_reg_info(regname, bitrange) -> char const *
        regname: char const *
        bitrange: bitrange_t *
    """
    return _ida_idp.get_reg_info(*args)

def sizeof_ldbl(*args) -> "size_t":
    r"""
    sizeof_ldbl() -> size_t
    """
    return _ida_idp.sizeof_ldbl(*args)

#<pycode(py_idp)>

#----------------------------------------------------------------------------
#               P R O C E S S O R  M O D U L E S  C O N S T A N T S
#----------------------------------------------------------------------------

# ----------------------------------------------------------------------
# processor_t related constants

CUSTOM_INSN_ITYPE   = 0x8000
"""
Custom instruction codes defined by processor extension plugins must
be greater than or equal to this
"""
REG_SPOIL           = 0x80000000
"""
processor_t::use_regarg_type uses this bit in the return value to
indicate that the register value has been spoiled
"""

REAL_ERROR_FORMAT   = -1   #  not supported format for current .idp
REAL_ERROR_RANGE    = -2   #  number too big (small) for store (mem NOT modifyed)
REAL_ERROR_BADDATA  = -3   #  illegal real data for load (IEEE data not filled)

#
#  Check whether the operand is relative to stack pointer or frame pointer.
#  This function is used to determine how to output a stack variable
#  This function may be absent. If it is absent, then all operands
#  are sp based by default.
#  Define this function only if some stack references use frame pointer
#  instead of stack pointer.
#  returns flags:
OP_FP_BASED   = 0x00000000   #  operand is FP based
"""
operand is FP based
"""
OP_SP_BASED   = 0x00000001   #  operand is SP based
"""
operand is SP based
"""
OP_SP_ADD     = 0x00000000   #  operand value is added to the pointer
"""
operand value is added to the pointer
"""
OP_SP_SUB     = 0x00000002   #  operand value is substracted from the pointer
"""
operand value is subtracted from the pointer
"""

# processor_t.id
PLFM_386             = 0        # Intel 80x86
"""
Intel 80x86.
"""
PLFM_Z80             = 1        # 8085, Z80
"""
8085, Z80
"""
PLFM_I860            = 2        # Intel 860
"""
Intel 860.
"""
PLFM_8051            = 3        # 8051
"""
8051
"""
PLFM_TMS             = 4        # Texas Instruments TMS320C5x
"""
Texas Instruments TMS320C5x.
"""
PLFM_6502            = 5        # 6502
"""
6502
"""
PLFM_PDP             = 6        # PDP11
"""
PDP11.
"""
PLFM_68K             = 7        # Motorola 680x0
"""
Motorola 680x0.
"""
PLFM_JAVA            = 8        # Java
"""
Java.
"""
PLFM_6800            = 9        # Motorola 68xx
"""
Motorola 68xx.
"""
PLFM_ST7             = 10       # SGS-Thomson ST7
"""
SGS-Thomson ST7.
"""
PLFM_MC6812          = 11       # Motorola 68HC12
"""
Motorola 68HC12.
"""
PLFM_MIPS            = 12       # MIPS
"""
MIPS.
"""
PLFM_ARM             = 13       # Advanced RISC Machines
"""
Advanced RISC Machines.
"""
PLFM_TMSC6           = 14       # Texas Instruments TMS320C6x
"""
Texas Instruments TMS320C6x.
"""
PLFM_PPC             = 15       # PowerPC
"""
PowerPC.
"""
PLFM_80196           = 16       # Intel 80196
"""
Intel 80196.
"""
PLFM_Z8              = 17       # Z8
"""
Z8.
"""
PLFM_SH              = 18       # Renesas (formerly Hitachi) SuperH
"""
Renesas (formerly Hitachi) SuperH.
"""
PLFM_NET             = 19       # Microsoft Visual Studio.Net
"""
Microsoft Visual Studio.Net.
"""
PLFM_AVR             = 20       # Atmel 8-bit RISC processor(s)
"""
Atmel 8-bit RISC processor(s)
"""
PLFM_H8              = 21       # Hitachi H8/300, H8/2000
"""
Hitachi H8/300, H8/2000.
"""
PLFM_PIC             = 22       # Microchip's PIC
"""
Microchip's PIC.
"""
PLFM_SPARC           = 23       # SPARC
"""
SPARC.
"""
PLFM_ALPHA           = 24       # DEC Alpha
"""
DEC Alpha.
"""
PLFM_HPPA            = 25       # Hewlett-Packard PA-RISC
"""
Hewlett-Packard PA-RISC.
"""
PLFM_H8500           = 26       # Hitachi H8/500
"""
Hitachi H8/500.
"""
PLFM_TRICORE         = 27       # Tasking Tricore
"""
Tasking Tricore.
"""
PLFM_DSP56K          = 28       # Motorola DSP5600x
"""
Motorola DSP5600x.
"""
PLFM_C166            = 29       # Siemens C166 family
"""
Siemens C166 family.
"""
PLFM_ST20            = 30       # SGS-Thomson ST20
"""
SGS-Thomson ST20.
"""
PLFM_IA64            = 31       # Intel Itanium IA64
"""
Intel Itanium IA64.
"""
PLFM_I960            = 32       # Intel 960
"""
Intel 960.
"""
PLFM_F2MC            = 33       # Fujistu F2MC-16
"""
Fujistu F2MC-16.
"""
PLFM_TMS320C54       = 34       # Texas Instruments TMS320C54xx
"""
Texas Instruments TMS320C54xx.
"""
PLFM_TMS320C55       = 35       # Texas Instruments TMS320C55xx
"""
Texas Instruments TMS320C55xx.
"""
PLFM_TRIMEDIA        = 36       # Trimedia
"""
Trimedia.
"""
PLFM_M32R            = 37       # Mitsubishi 32bit RISC
"""
Mitsubishi 32bit RISC.
"""
PLFM_NEC_78K0        = 38       # NEC 78K0
"""
NEC 78K0.
"""
PLFM_NEC_78K0S       = 39       # NEC 78K0S
"""
NEC 78K0S.
"""
PLFM_M740            = 40       # Mitsubishi 8bit
"""
Mitsubishi 8bit.
"""
PLFM_M7700           = 41       # Mitsubishi 16bit
"""
Mitsubishi 16bit.
"""
PLFM_ST9             = 42       # ST9+
"""
ST9+.
"""
PLFM_FR              = 43       # Fujitsu FR Family
"""
Fujitsu FR Family.
"""
PLFM_MC6816          = 44       # Motorola 68HC16
"""
Motorola 68HC16.
"""
PLFM_M7900           = 45       # Mitsubishi 7900
"""
Mitsubishi 7900.
"""
PLFM_TMS320C3        = 46       # Texas Instruments TMS320C3
"""
Texas Instruments TMS320C3.
"""
PLFM_KR1878          = 47       # Angstrem KR1878
"""
Angstrem KR1878.
"""
PLFM_AD218X          = 48       # Analog Devices ADSP 218X
"""
Analog Devices ADSP 218X.
"""
PLFM_OAKDSP          = 49       # Atmel OAK DSP
"""
Atmel OAK DSP.
"""
PLFM_TLCS900         = 50       # Toshiba TLCS-900
"""
Toshiba TLCS-900.
"""
PLFM_C39             = 51       # Rockwell C39
"""
Rockwell C39.
"""
PLFM_CR16            = 52       # NSC CR16
"""
NSC CR16.
"""
PLFM_MN102L00        = 53       # Panasonic MN10200
"""
Panasonic MN10200.
"""
PLFM_TMS320C1X       = 54       # Texas Instruments TMS320C1x
"""
Texas Instruments TMS320C1x.
"""
PLFM_NEC_V850X       = 55       # NEC V850 and V850ES/E1/E2
"""
NEC V850 and V850ES/E1/E2.
"""
PLFM_SCR_ADPT        = 56       # Processor module adapter for processor modules written in scripting languages
"""
Processor module adapter for processor modules written in scripting
languages.
"""
PLFM_EBC             = 57       # EFI Bytecode
"""
EFI Bytecode.
"""
PLFM_MSP430          = 58       # Texas Instruments MSP430
"""
Texas Instruments MSP430.
"""
PLFM_SPU             = 59       # Cell Broadband Engine Synergistic Processor Unit
"""
Cell Broadband Engine Synergistic Processor Unit.
"""
PLFM_DALVIK          = 60       # Android Dalvik Virtual Machine
"""
Android Dalvik Virtual Machine.
"""
PLFM_65C816          = 61       # 65802/65816
"""
65802/65816
"""
PLFM_M16C            = 62       # Renesas M16C
"""
Renesas M16C.
"""
PLFM_ARC             = 63       # Argonaut RISC Core
"""
Argonaut RISC Core.
"""
PLFM_UNSP            = 64       # SunPlus unSP
"""
SunPlus unSP.
"""
PLFM_TMS320C28       = 65       # Texas Instruments TMS320C28x
"""
Texas Instruments TMS320C28x.
"""
PLFM_DSP96K          = 66       # Motorola DSP96000
"""
Motorola DSP96000.
"""
PLFM_SPC700          = 67       # Sony SPC700
"""
Sony SPC700.
"""
PLFM_AD2106X         = 68       # Analog Devices ADSP 2106X
"""
Analog Devices ADSP 2106X.
"""
PLFM_PIC16           = 69       # Microchip's 16-bit PIC
"""
Microchip's 16-bit PIC.
"""
PLFM_S390            = 70       # IBM's S390
"""
IBM's S390.
"""

#
# processor_t.flag
#
PR_SEGS        = 0x000001    #  has segment registers?
"""
has segment registers?
"""
PR_USE32       = 0x000002    #  supports 32-bit addressing?
"""
supports 32-bit addressing?
"""
PR_DEFSEG32    = 0x000004    #  segments are 32-bit by default
"""
segments are 32-bit by default
"""
PR_RNAMESOK    = 0x000008    #  allow to user register names for location names
"""
allow user register names for location names
"""
PR_ADJSEGS     = 0x000020    #  IDA may adjust segments moving their starting/ending addresses.
"""
IDA may adjust segments' starting/ending addresses.
"""
PR_DEFNUM      = 0x0000C0    #  default number representation:
"""
mask - default number representation
"""
PRN_HEX        = 0x000000    #       hex
"""
hex
"""
PRN_OCT        = 0x000040    #       octal
"""
octal
"""
PRN_DEC        = 0x000080    #       decimal
"""
decimal
"""
PRN_BIN        = 0x0000C0    #       binary
"""
binary
"""
PR_WORD_INS    = 0x000100    #  instruction codes are grouped 2bytes in binrary line prefix
"""
instruction codes are grouped 2bytes in binary line prefix
"""
PR_NOCHANGE    = 0x000200    #  The user can't change segments and code/data attributes (display only)
"""
(display only)

The user can't change segments and code/data attributes
"""
PR_ASSEMBLE    = 0x000400    #  Module has a built-in assembler and understands IDP_ASSEMBLE
"""
Module has a built-in assembler and will react to ev_assemble.
"""
PR_ALIGN       = 0x000800    #  All data items should be aligned properly
"""
All data items should be aligned properly.
"""
PR_TYPEINFO    = 0x001000    #  the processor module supports
"""
ALL OF THEM SHOULD BE IMPLEMENTED!

the processor module supports type information callbacks
"""
#     type information callbacks
#     ALL OF THEM SHOULD BE IMPLEMENTED!
PR_USE64       = 0x002000    #  supports 64-bit addressing?
"""
supports 64-bit addressing?
"""
PR_SGROTHER    = 0x004000    #  the segment registers don't contain
"""
the segment registers don't contain the segment selectors.
"""
#     the segment selectors, something else
PR_STACK_UP    = 0x008000    #  the stack grows up
"""
the stack grows up
"""
PR_BINMEM      = 0x010000    #  the processor module provides correct
"""
the processor module provides correct segmentation for binary files
(i.e. it creates additional segments) The kernel will not ask the user
to specify the RAM/ROM sizes
"""
#     segmentation for binary files
#     (i.e. it creates additional segments)
#     The kernel will not ask the user
#     to specify the RAM/ROM sizes
PR_SEGTRANS    = 0x020000    #  the processor module supports
"""
the processor module supports the segment translation feature (meaning
it calculates the code addresses using the 'map_code_ea()' function)
"""
#     the segment translation feature
#     (it means it calculates the code
#     addresses using the map_code_ea() function)
PR_CHK_XREF    = 0x040000    #  don't allow near xrefs between segments
"""
don't allow near xrefs between segments with different bases
"""
#     with different bases
PR_NO_SEGMOVE  = 0x080000    #  the processor module doesn't support move_segm()
"""
(i.e. the user can't move segments)

the processor module doesn't support 'move_segm()'
"""
#     (i.e. the user can't move segments)
PR_USE_ARG_TYPES = 0x200000  #  use ph.use_arg_types callback
"""
use \\ph{use_arg_types} callback
"""
PR_SCALE_STKVARS = 0x400000  #  use ph.get_stkvar_scale callback
"""
use \\ph{get_stkvar_scale} callback
"""
PR_DELAYED     = 0x800000    #  has delayed jumps and calls
"""
has delayed jumps and calls if this flag is set,
\\ph{is_basic_block_end}, \\ph{has_delay_slot} should be implemented
"""
PR_ALIGN_INSN  = 0x1000000   #  allow ida to create alignment instructions
"""
allow ida to create alignment instructions arbitrarily. Since these
instructions might lead to other wrong instructions and spoil the
listing, IDA does not create them by default anymore
"""
#     arbirtrarily. Since these instructions
#     might lead to other wrong instructions
#     and spoil the listing, IDA does not create
#     them by default anymore
PR_PURGING     = 0x2000000   #  there are calling conventions which may
"""
there are calling conventions which may purge bytes from the stack
"""
#     purge bytes from the stack
PR_CNDINSNS    = 0x4000000   #  has conditional instructions
"""
has conditional instructions
"""
PR_USE_TBYTE   = 0x8000000   #  BTMT_SPECFLT means _TBYTE type
"""
'BTMT_SPECFLT' means _TBYTE type
"""
PR_DEFSEG64    = 0x10000000  #  segments are 64-bit by default
"""
segments are 64-bit by default
"""


# ----------------------------------------------------------------------
# instruc_t related constants

#
# instruc_t.feature
#
CF_STOP = 0x00001 #  Instruction doesn't pass execution to the next instruction
"""
next instruction

Instruction doesn't pass execution to the
"""
CF_CALL = 0x00002 #  CALL instruction (should make a procedure here)
"""
CALL instruction (should make a procedure here)
"""
CF_CHG1 = 0x00004 #  The instruction modifies the first operand
"""
The instruction modifies the first operand.
"""
CF_CHG2 = 0x00008 #  The instruction modifies the second operand
"""
The instruction modifies the second operand.
"""
CF_CHG3 = 0x00010 #  The instruction modifies the third operand
"""
The instruction modifies the third operand.
"""
CF_CHG4 = 0x00020 #  The instruction modifies 4 operand
"""
The instruction modifies 4 operand.
"""
CF_CHG5 = 0x00040 #  The instruction modifies 5 operand
"""
The instruction modifies 5 operand.
"""
CF_CHG6 = 0x00080 #  The instruction modifies 6 operand
"""
The instruction modifies 6 operand.
"""
CF_USE1 = 0x00100 #  The instruction uses value of the first operand
"""
The instruction uses value of the first operand.
"""
CF_USE2 = 0x00200 #  The instruction uses value of the second operand
"""
The instruction uses value of the second operand.
"""
CF_USE3 = 0x00400 #  The instruction uses value of the third operand
"""
The instruction uses value of the third operand.
"""
CF_USE4 = 0x00800 #  The instruction uses value of the 4 operand
"""
The instruction uses value of the 4 operand.
"""
CF_USE5 = 0x01000 #  The instruction uses value of the 5 operand
"""
The instruction uses value of the 5 operand.
"""
CF_USE6 = 0x02000 #  The instruction uses value of the 6 operand
"""
The instruction uses value of the 6 operand.
"""
CF_JUMP = 0x04000 #  The instruction passes execution using indirect jump or call (thus needs additional analysis)
"""
jump or call (thus needs additional analysis)

The instruction passes execution using indirect
"""
CF_SHFT = 0x08000 #  Bit-shift instruction (shl,shr...)
"""
Bit-shift instruction (shl,shr...)
"""
CF_HLL  = 0x10000 #  Instruction may be present in a high level language function.
"""
language function.

Instruction may be present in a high level
"""

#
# Set IDP options constants
#
IDPOPT_STR        =  1    # string constant
IDPOPT_NUM        =  2    # number
IDPOPT_BIT        =  3    # bit, yes/no
IDPOPT_FLT        =  4    # float
IDPOPT_I64        =  5    # 64bit number

IDPOPT_OK         =  0    # ok
IDPOPT_BADKEY     =  1    # illegal keyword
IDPOPT_BADTYPE    =  2    # illegal type of value
IDPOPT_BADVALUE   =  3    # illegal value (bad range, for example)

# ----------------------------------------------------------------------
import ida_pro
import ida_funcs
import ida_segment
import ida_ua
class processor_t(IDP_Hooks):
    __idc_cvt_id__ = ida_idaapi.PY_ICID_OPAQUE

    """
    Base class for all processor module scripts

    A processor_t instance is both an ida_idp.IDP_Hooks, and an
    ida_idp.IDB_Hooks at the same time: any method of those two classes
    can be overridden in your processor_t subclass (with the exception of
    'ida_idp.IDP_Hooks.ev_init' (replaced with processor_t.__init__),
    and 'ida_idp.IDP_Hooks.ev_term' (replaced with processor_t.__del__)).
    """
    def __init__(self):
        IDP_Hooks.__init__(self, ida_idaapi.HBF_CALL_WITH_NEW_EXEC)
        self.idb_hooks = _processor_t_Trampoline_IDB_Hooks(self)

    def get_idpdesc(self):
        """
        This function must be present and should return the list of
        short processor names similar to the one in ph.psnames.
        This method can be overridden to return to the kernel a different IDP description.
        """
        return '\x01'.join(map(lambda t: '\x01'.join(t), zip(self.plnames, self.psnames)))

    def get_uFlag(self):
        """
        Use this utility function to retrieve the 'uFlag' global variable
        """
        return ida_ua.cvar.uFlag

    def get_auxpref(self, insn):
        """
        This function returns insn.auxpref value
        """
        return insn.auxpref

    def _get_idp_notifier_addr(self):
        return _ida_idp.get_idp_notifier_addr(self)

    def _get_idp_notifier_ud_addr(self):
        return _ida_idp.get_idp_notifier_ud_addr(self)

    def _get_idb_notifier_addr(self):
        return _ida_idp.get_idb_notifier_addr(self)

    def _get_idb_notifier_ud_addr(self):
        return _ida_idp.get_idb_notifier_ud_addr(self.idb_hooks)

    def _make_forced_value_wrapper(self, val, meth=None):
        def f(*args):
            if meth:
                meth(*args)
            return val
        return f

    def _make_int_returning_wrapper(self, meth, intval=0):
        def f(*args):
            val = meth(*args)
            if val is None:
                val = intval
            return val
        return f

    def _get_notify(self, what, unimp_val=0, imp_forced_val=None, add_prefix=True, mandatory_impl=None):
        """
        This helper is used to implement backward-compatibility
        of pre IDA 7.3 processor_t interfaces.
        """
        if add_prefix:
            what = "notify_%s" % what
        meth = getattr(self, what, None)
        if meth is None:
            if mandatory_impl:
                raise Exception("processor_t.%s() must be implemented" % mandatory_impl)
            meth = self._make_forced_value_wrapper(unimp_val)
        else:
            if imp_forced_val is not None:
                meth = self._make_forced_value_wrapper(imp_forced_val, meth)
            else:
                meth = self._make_int_returning_wrapper(meth)
        return meth

# The default implementations below are what guarantees that
# pre IDA 7.3 processor_t subclasses, will continue working

    def ev_newprc(self, *args):
        return self._get_notify("newprc")(*args)

    def ev_newfile(self, *args):
        return self._get_notify("newfile")(*args)

    def ev_oldfile(self, *args):
        return self._get_notify("oldfile")(*args)

    def ev_newbinary(self, *args):
        return self._get_notify("newbinary")(*args)

    def ev_endbinary(self, *args):
        return self._get_notify("endbinary")(*args)

    def ev_set_idp_options(self, keyword, value_type, value, idb_loaded):
        res = self._get_notify("set_idp_options", unimp_val=None)(keyword, value_type, value)
        if res is None:
            return 0
        return 1 if res == IDPOPT_OK else -1

    def ev_set_proc_options(self, *args):
        return self._get_notify("set_proc_options")(*args)

    def ev_ana_insn(self, *args):
        rc = self._get_notify("ana", mandatory_impl="ev_ana_insn")(*args)
        return rc > 0

    def ev_emu_insn(self, *args):
        rc = self._get_notify("emu", mandatory_impl="ev_emu_insn")(*args)
        return rc > 0

    def ev_out_header(self, *args):
        return self._get_notify("out_header", imp_forced_val=1)(*args)

    def ev_out_footer(self, *args):
        return self._get_notify("out_footer", imp_forced_val=1)(*args)

    def ev_out_segstart(self, ctx, s):
        return self._get_notify("out_segstart", imp_forced_val=1)(ctx, s.start_ea)

    def ev_out_segend(self, ctx, s):
        return self._get_notify("out_segend", imp_forced_val=1)(ctx, s.end_ea)

    def ev_out_assumes(self, *args):
        return self._get_notify("out_assumes", imp_forced_val=1)(*args)

    def ev_out_insn(self, *args):
        return self._get_notify("out_insn", mandatory_impl="ev_out_insn", imp_forced_val=True)(*args)

    def ev_out_mnem(self, *args):
        return self._get_notify("out_mnem", add_prefix=False, imp_forced_val=1)(*args)

    def ev_out_operand(self, *args):
        rc = self._get_notify("out_operand", mandatory_impl="ev_out_operand", imp_forced_val=1)(*args)
        return rc > 0

    def ev_out_data(self, *args):
        return self._get_notify("out_data", imp_forced_val=1)(*args)

    def ev_out_label(self, *args):
        return self._get_notify("out_label")(*args)

    def ev_out_special_item(self, *args):
        return self._get_notify("out_special_item")(*args)

    def ev_gen_regvar_def(self, ctx, v):
        return self._get_notify("gen_regvar_def")(ctx, v.canon, v.user, v.cmt)

    def ev_gen_src_file_lnnum(self, *args):
        return self._get_notify("gen_src_file_lnnum")(*args)

    def ev_creating_segm(self, s):
        sname = ida_segment.get_visible_segm_name(s)
        sclass = ida_segment.get_segm_class(s)
        return self._get_notify("creating_segm")(s.start_ea, sname, sclass)

    def ev_moving_segm(self, s, to_ea, flags):
        sname = ida_segment.get_visible_segm_name(s)
        sclass = ida_segment.get_segm_class(s)
        return self._get_notify("moving_segm")(s.start_ea, sname, sclass, to_ea, flags)

    def ev_coagulate(self, *args):
        return self._get_notify("coagulate")(*args)

    def ev_undefine(self, *args):
        return self._get_notify("undefine")(*args)

    def ev_treat_hindering_item(self, *args):
        return self._get_notify("treat_hindering_item")(*args)

    def ev_rename(self, *args):
        return self._get_notify("rename")(*args)

    def ev_is_far_jump(self, *args):
        rc = self._get_notify("is_far_jump", unimp_val=False)(*args)
        return 1 if rc else -1

    def ev_is_sane_insn(self, *args):
        return self._get_notify("is_sane_insn")(*args)

    def ev_is_call_insn(self, *args):
        return self._get_notify("is_call_insn")(*args)

    def ev_is_ret_insn(self, *args):
        return self._get_notify("is_ret_insn")(*args)

    def ev_may_be_func(self, *args):
        return self._get_notify("may_be_func")(*args)

    def ev_is_basic_block_end(self, *args):
        return self._get_notify("is_basic_block_end")(*args)

    def ev_is_indirect_jump(self, *args):
        return self._get_notify("is_indirect_jump")(*args)

    def ev_is_insn_table_jump(self, *args):
        return self._get_notify("is_insn_table_jump")(*args)

    def ev_is_switch(self, *args):
        rc = self._get_notify("is_switch")(*args)
        return 1 if rc else 0

    def ev_create_switch_xrefs(self, *args):
        return self._get_notify("create_switch_xrefs", imp_forced_val=1)(*args)

    def ev_is_align_insn(self, *args):
        return self._get_notify("is_align_insn")(*args)

    def ev_is_alloca_probe(self, *args):
        return self._get_notify("is_alloca_probe")(*args)

    def ev_is_sp_based(self, mode, insn, op):
        rc = self._get_notify("is_sp_based", unimp_val=None)(insn, op)
        if type(rc) == int:
            ida_pro.int_pointer.frompointer(mode).assign(rc)
            return 1
        return 0

    def ev_can_have_type(self, *args):
        rc = self._get_notify("can_have_type")(*args)
        if rc is True:
            return 1
        elif rc is False:
            return -1
        else:
            return 0

    def ev_cmp_operands(self, *args):
        rc = self._get_notify("cmp_operands")(*args)
        if rc is True:
            return 1
        elif rc is False:
            return -1
        else:
            return 0

    def ev_get_operand_string(self, buf, insn, opnum):
        rc = self._get_notify("get_operand_string")(insn, opnum)
        if rc:
            return 1
        return 0

    def ev_str2reg(self, *args):
        rc = self._get_notify("notify_str2reg", unimp_val=-1)(*args)
        return 0 if rc < 0 else rc + 1

    def ev_get_autocmt(self, *args):
        return self._get_notify("get_autocmt")(*args)

    def ev_func_bounds(self, _possible_return_code, pfn, max_func_end_ea):
        possible_return_code = ida_pro.int_pointer.frompointer(_possible_return_code)
        rc = self._get_notify("func_bounds", unimp_val=None)(
            possible_return_code.value(),
            pfn.start_ea,
            max_func_end_ea)
        if type(rc) == int:
            possible_return_code.assign(rc)
        return 0

    def ev_verify_sp(self, pfn):
        return self._get_notify("verify_sp")(pfn.start_ea)

    def ev_verify_noreturn(self, pfn):
        return self._get_notify("verify_noreturn")(pfn.start_ea)

    def ev_create_func_frame(self, pfn):
        rc = self._get_notify("create_func_frame", imp_forced_val=1)(pfn.start_ea)
        if rc is True:
            return 1
        elif rc is False:
            return -1
        else:
            return rc

    def ev_get_frame_retsize(self, frsize, pfn):
        rc = self._get_notify("get_frame_retsize", unimp_val=None)(pfn.start_ea)
        if type(rc) == int:
            ida_pro.int_pointer.frompointer(frsize).assign(rc)
            return 1
        return 0

    def ev_coagulate_dref(self, from_ea, to_ea, may_define, _code_ea):
        code_ea = ida_pro.ea_pointer.frompointer(_code_ea)
        rc = self._get_notify("coagulate_dref")(from_ea, to_ea, may_define, code_ea.value())
        if rc == -1:
            return -1
        if rc != 0:
            code_ea.assign(rc)
        return 0

    def ev_may_show_sreg(self, *args):
        return self._get_notify("may_show_sreg")(*args)

    def ev_auto_queue_empty(self, *args):
        return self._get_notify("auto_queue_empty")(*args)

    def ev_validate_flirt_func(self, *args):
        return self._get_notify("validate_flirt_func")(*args)

    def ev_assemble(self, *args):
        return self._get_notify("assemble")(*args)

    def ev_gen_map_file(self, nlines, fp):
        import ida_fpro
        qfile = ida_fpro.qfile_t_from_fp(fp)
        rc = self._get_notify("gen_map_file")(qfile)
        if rc > 0:
            ida_pro.int_pointer.frompointer(nlines).assign(rc)
            return 1
        else:
            return 0

    def ev_calc_step_over(self, target, ip):
        rc = self._get_notify("calc_step_over", unimp_val=None)(ip)
        if rc is not None and rc != ida_idaapi.BADADDR:
            ida_pro.ea_pointer.frompointer(target).assign(rc)
            return 1
        return 0

# IDB hooks handling

    def closebase(self, *args):
        self._get_notify("closebase")(*args)

    def savebase(self, *args):
        self._get_notify("savebase")(*args)

    def auto_empty(self, *args):
        self._get_notify("auto_empty")(*args)

    def auto_empty_finally(self, *args):
        self._get_notify("auto_empty_finally")(*args)

    def determined_main(self, *args):
        self._get_notify("determined_main")(*args)

    def idasgn_loaded(self, *args):
        self._get_notify("load_idasgn")(*args)

    def kernel_config_loaded(self, *args):
        self._get_notify("kernel_config_loaded")(*args)

    def compiler_changed(self, *args):
        self._get_notify("set_compiler")(*args)

    def segm_moved(self, from_ea, to_ea, size, changed_netmap):
        s = ida_segment.getseg(to_ea)
        sname = ida_segment.get_visible_segm_name(s)
        sclass = ida_segment.get_segm_class(s)
        self._get_notify("move_segm")(from_ea, to_ea, sname, sclass, changed_netmap)

    def func_added(self, pfn):
        self._get_notify("add_func")(pfn.start_ea)

    def set_func_start(self, *args):
        self._get_notify("set_func_start")(*args)

    def set_func_end(self, *args):
        self._get_notify("set_func_end")(*args)

    def deleting_func(self, pfn):
        self._get_notify("del_func")(pfn.start_ea)

    def sgr_changed(self, *args):
        self._get_notify("setsgr")(*args)

    def make_code(self, *args):
        self._get_notify("make_code")(*args)

    def make_data(self, *args):
        self._get_notify("make_data")(*args)

    def renamed(self, *args):
        self._get_notify("renamed")(*args)


# ----------------------------------------------------------------------
class __ph(object):
    id = property(lambda self: ph_get_id())
    cnbits = property(lambda self: ph_get_cnbits())
    dnbits = property(lambda self: ph_get_dnbits())
    flag = property(lambda self: ph_get_flag())
    icode_return = property(lambda self: ph_get_icode_return())
    instruc = property(lambda self: ph_get_instruc())
    instruc_end = property(lambda self: ph_get_instruc_end())
    instruc_start = property(lambda self: ph_get_instruc_start())
    reg_code_sreg = property(lambda self: ph_get_reg_code_sreg())
    reg_data_sreg = property(lambda self: ph_get_reg_data_sreg())
    reg_first_sreg = property(lambda self: ph_get_reg_first_sreg())
    reg_last_sreg = property(lambda self: ph_get_reg_last_sreg())
    regnames = property(lambda self: ph_get_regnames())
    segreg_size = property(lambda self: ph_get_segreg_size())
    tbyte_size = property(lambda self: ph_get_tbyte_size())
    version = property(lambda self: ph_get_version())

ph = __ph()

class _idp_cvar_t:
    ash = property(lambda self: get_ash())
cvar = _idp_cvar_t()

#</pycode(py_idp)>

class IDB_Hooks(object):
    r"""
    Proxy of C++ IDB_Hooks class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        __init__(self, _flags=0) -> IDB_Hooks
            _flags: uint32
        """
        if self.__class__ == IDB_Hooks:
            _self = None
        else:
            _self = self
        _ida_idp.IDB_Hooks_swiginit(self, _ida_idp.new_IDB_Hooks(_self, *args))

    def hook(self, *args) -> "bool":
        r"""
        hook(self) -> bool
        """
        return _ida_idp.IDB_Hooks_hook(self, *args)

    def unhook(self, *args) -> "bool":
        r"""
        unhook(self) -> bool
        """
        return _ida_idp.IDB_Hooks_unhook(self, *args)

    def closebase(self, *args) -> "void":
        r"""


        The database will be closed now.
        """
        return _ida_idp.IDB_Hooks_closebase(self, *args)

    def savebase(self, *args) -> "void":
        r"""


        The database is being saved.
        """
        return _ida_idp.IDB_Hooks_savebase(self, *args)

    def upgraded(self, *args) -> "void":
        r"""


        The database has been upgraded and the receiver can upgrade its info
        as well
        
        upgraded(self, _from)
            @param _from: - old IDB version  (C++: int)
        """
        return _ida_idp.IDB_Hooks_upgraded(self, *args)

    def auto_empty(self, *args) -> "void":
        r"""


        Info: all analysis queues are empty. This callback is called once when
        the initial analysis is finished. If the queue is not empty upon the
        return from this callback, it will be called later again.
        """
        return _ida_idp.IDB_Hooks_auto_empty(self, *args)

    def auto_empty_finally(self, *args) -> "void":
        r"""


        Info: all analysis queues are empty definitively. This callback is
        called only once.
        """
        return _ida_idp.IDB_Hooks_auto_empty_finally(self, *args)

    def determined_main(self, *args) -> "void":
        r"""


        The main() function has been determined.
        
        determined_main(self, main)
            @param main: address of the main() function  (C++: ea_t)
        """
        return _ida_idp.IDB_Hooks_determined_main(self, *args)

    def local_types_changed(self, *args) -> "void":
        r"""


        Local types have been changed.
        """
        return _ida_idp.IDB_Hooks_local_types_changed(self, *args)

    def extlang_changed(self, *args) -> "void":
        r"""


        The list of extlangs or the default extlang was changed.
        
        extlang_changed(self, kind, el, idx)
            @param kind: 0: extlang installed 1: extlang removed 2: default
                         extlang changed  (C++: int)
            @param el: pointer to the extlang affected  (C++: extlang_t *)
            @param idx: extlang index  (C++: int)
        """
        return _ida_idp.IDB_Hooks_extlang_changed(self, *args)

    def idasgn_loaded(self, *args) -> "void":
        r"""


        FLIRT signature has been loaded for normal processing (not for
        recognition of startup sequences).
        
        idasgn_loaded(self, short_sig_name)
            @param short_sig_name (C++: const char *)
        """
        return _ida_idp.IDB_Hooks_idasgn_loaded(self, *args)

    def kernel_config_loaded(self, *args) -> "void":
        r"""


        This event is issued when ida.cfg is parsed.
        
        kernel_config_loaded(self, pass_number)
            @param pass_number (C++: int)
        """
        return _ida_idp.IDB_Hooks_kernel_config_loaded(self, *args)

    def loader_finished(self, *args) -> "void":
        r"""


        External file loader finished its work. Use this event to augment the
        existing loader functionality.
        
        loader_finished(self, li, neflags, filetypename)
            @param li (C++: linput_t *)
            @param neflags: Load file flags  (C++: uint16)
            @param filetypename (C++: const char *)
        """
        return _ida_idp.IDB_Hooks_loader_finished(self, *args)

    def flow_chart_created(self, *args) -> "void":
        r"""


        Gui has retrieved a function flow chart. Plugins may modify the flow
        chart in this callback.
        
        flow_chart_created(self, fc)
            @param fc (C++: qflow_chart_t *)
        """
        return _ida_idp.IDB_Hooks_flow_chart_created(self, *args)

    def compiler_changed(self, *args) -> "void":
        r"""


        The kernel has changed the compiler information. (\inf{cc} structure;
        'get_abi_name' )
        """
        return _ida_idp.IDB_Hooks_compiler_changed(self, *args)

    def changing_ti(self, *args) -> "void":
        r"""


        An item typestring (c/c++ prototype) is to be changed.
        
        changing_ti(self, ea, new_type, new_fnames)
            @param ea (C++: ea_t)
            @param new_type (C++: const type_t *)
            @param new_fnames (C++: const p_list *)
        """
        return _ida_idp.IDB_Hooks_changing_ti(self, *args)

    def ti_changed(self, *args) -> "void":
        r"""


        An item typestring (c/c++ prototype) has been changed.
        
        ti_changed(self, ea, type, fnames)
            @param ea (C++: ea_t)
            @param type (C++: const type_t *)
            @param fnames (C++: const p_list *)
        """
        return _ida_idp.IDB_Hooks_ti_changed(self, *args)

    def changing_op_ti(self, *args) -> "void":
        r"""


        An operand typestring (c/c++ prototype) is to be changed.
        
        changing_op_ti(self, ea, n, new_type, new_fnames)
            @param ea (C++: ea_t)
            @param n (C++: int)
            @param new_type (C++: const type_t *)
            @param new_fnames (C++: const p_list *)
        """
        return _ida_idp.IDB_Hooks_changing_op_ti(self, *args)

    def op_ti_changed(self, *args) -> "void":
        r"""


        An operand typestring (c/c++ prototype) has been changed.
        
        op_ti_changed(self, ea, n, type, fnames)
            @param ea (C++: ea_t)
            @param n (C++: int)
            @param type (C++: const type_t *)
            @param fnames (C++: const p_list *)
        """
        return _ida_idp.IDB_Hooks_op_ti_changed(self, *args)

    def changing_op_type(self, *args) -> "void":
        r"""


        An operand type (offset, hex, etc...) is to be changed.
        
        changing_op_type(self, ea, n, opinfo)
            @param ea (C++: ea_t)
            @param n: eventually or'ed with OPND_OUTER or OPND_ALL  (C++: int)
            @param opinfo: additional operand info  (C++: const opinfo_t *)
        """
        return _ida_idp.IDB_Hooks_changing_op_type(self, *args)

    def op_type_changed(self, *args) -> "void":
        r"""


        An operand type (offset, hex, etc...) has been set or deleted.
        
        op_type_changed(self, ea, n)
            @param ea (C++: ea_t)
            @param n: eventually or'ed with OPND_OUTER or OPND_ALL  (C++: int)
        """
        return _ida_idp.IDB_Hooks_op_type_changed(self, *args)

    def enum_created(self, *args) -> "void":
        r"""


        An enum type has been created.
        
        enum_created(self, id)
            @param id (C++: enum_t)
        """
        return _ida_idp.IDB_Hooks_enum_created(self, *args)

    def deleting_enum(self, *args) -> "void":
        r"""


        An enum type is to be deleted.
        
        deleting_enum(self, id)
            @param id (C++: enum_t)
        """
        return _ida_idp.IDB_Hooks_deleting_enum(self, *args)

    def enum_deleted(self, *args) -> "void":
        r"""


        An enum type has been deleted.
        
        enum_deleted(self, id)
            @param id (C++: enum_t)
        """
        return _ida_idp.IDB_Hooks_enum_deleted(self, *args)

    def renaming_enum(self, *args) -> "void":
        r"""


        An enum or enum member is to be renamed.
        
        renaming_enum(self, id, is_enum, newname)
            @param id (C++: tid_t)
            @param is_enum (C++: bool)
            @param newname (C++: const char *)
        """
        return _ida_idp.IDB_Hooks_renaming_enum(self, *args)

    def enum_renamed(self, *args) -> "void":
        r"""


        An enum or member has been renamed.
        
        enum_renamed(self, id)
            @param id (C++: tid_t)
        """
        return _ida_idp.IDB_Hooks_enum_renamed(self, *args)

    def changing_enum_bf(self, *args) -> "void":
        r"""


        An enum type 'bitfield' attribute is to be changed.
        
        changing_enum_bf(self, id, new_bf)
            @param id (C++: enum_t)
            @param new_bf (C++: bool)
        """
        return _ida_idp.IDB_Hooks_changing_enum_bf(self, *args)

    def enum_bf_changed(self, *args) -> "void":
        r"""


        An enum type 'bitfield' attribute has been changed.
        
        enum_bf_changed(self, id)
            @param id (C++: enum_t)
        """
        return _ida_idp.IDB_Hooks_enum_bf_changed(self, *args)

    def changing_enum_cmt(self, *args) -> "void":
        r"""


        An enum or member type comment is to be changed.
        
        changing_enum_cmt(self, id, repeatable, newcmt)
            @param id (C++: tid_t)
            @param repeatable (C++: bool)
            @param newcmt (C++: const char *)
        """
        return _ida_idp.IDB_Hooks_changing_enum_cmt(self, *args)

    def enum_cmt_changed(self, *args) -> "void":
        r"""


        An enum or member type comment has been changed.
        
        enum_cmt_changed(self, id, repeatable)
            @param id (C++: tid_t)
            @param repeatable (C++: bool)
        """
        return _ida_idp.IDB_Hooks_enum_cmt_changed(self, *args)

    def enum_member_created(self, *args) -> "void":
        r"""


        An enum member has been created.
        
        enum_member_created(self, id, cid)
            @param id (C++: enum_t)
            @param cid (C++: const_t)
        """
        return _ida_idp.IDB_Hooks_enum_member_created(self, *args)

    def deleting_enum_member(self, *args) -> "void":
        r"""


        An enum member is to be deleted.
        
        deleting_enum_member(self, id, cid)
            @param id (C++: enum_t)
            @param cid (C++: const_t)
        """
        return _ida_idp.IDB_Hooks_deleting_enum_member(self, *args)

    def enum_member_deleted(self, *args) -> "void":
        r"""


        An enum member has been deleted.
        
        enum_member_deleted(self, id, cid)
            @param id (C++: enum_t)
            @param cid (C++: const_t)
        """
        return _ida_idp.IDB_Hooks_enum_member_deleted(self, *args)

    def struc_created(self, *args) -> "void":
        r"""


        A new structure type has been created.
        
        struc_created(self, struc_id)
            @param struc_id (C++: tid_t)
        """
        return _ida_idp.IDB_Hooks_struc_created(self, *args)

    def deleting_struc(self, *args) -> "void":
        r"""


        A structure type is to be deleted.
        
        deleting_struc(self, sptr)
            @param sptr (C++: struc_t *)
        """
        return _ida_idp.IDB_Hooks_deleting_struc(self, *args)

    def struc_deleted(self, *args) -> "void":
        r"""


        A structure type has been deleted.
        
        struc_deleted(self, struc_id)
            @param struc_id (C++: tid_t)
        """
        return _ida_idp.IDB_Hooks_struc_deleted(self, *args)

    def changing_struc_align(self, *args) -> "void":
        r"""


        A structure type is being changed (the struct alignment).
        
        changing_struc_align(self, sptr)
            @param sptr (C++: struc_t *)
        """
        return _ida_idp.IDB_Hooks_changing_struc_align(self, *args)

    def struc_align_changed(self, *args) -> "void":
        r"""


        A structure type has been changed (the struct alignment).
        
        struc_align_changed(self, sptr)
            @param sptr (C++: struc_t *)
        """
        return _ida_idp.IDB_Hooks_struc_align_changed(self, *args)

    def renaming_struc(self, *args) -> "void":
        r"""


        A structure type is to be renamed.
        
        renaming_struc(self, id, oldname, newname)
            @param id (C++: tid_t)
            @param oldname (C++: const char *)
            @param newname (C++: const char *)
        """
        return _ida_idp.IDB_Hooks_renaming_struc(self, *args)

    def struc_renamed(self, *args) -> "void":
        r"""


        A structure type has been renamed.
        
        struc_renamed(self, sptr)
            @param sptr (C++: struc_t *)
        """
        return _ida_idp.IDB_Hooks_struc_renamed(self, *args)

    def expanding_struc(self, *args) -> "void":
        r"""


        A structure type is to be expanded/shrunk.
        
        expanding_struc(self, sptr, offset, delta)
            @param sptr (C++: struc_t *)
            @param offset (C++: ea_t)
            @param delta (C++: adiff_t)
        """
        return _ida_idp.IDB_Hooks_expanding_struc(self, *args)

    def struc_expanded(self, *args) -> "void":
        r"""


        A structure type has been expanded/shrank.
        
        struc_expanded(self, sptr)
            @param sptr (C++: struc_t *)
        """
        return _ida_idp.IDB_Hooks_struc_expanded(self, *args)

    def struc_member_created(self, *args) -> "void":
        r"""


        A structure member has been created.
        
        struc_member_created(self, sptr, mptr)
            @param sptr (C++: struc_t *)
            @param mptr (C++: member_t *)
        """
        return _ida_idp.IDB_Hooks_struc_member_created(self, *args)

    def deleting_struc_member(self, *args) -> "void":
        r"""


        A structure member is to be deleted.
        
        deleting_struc_member(self, sptr, mptr)
            @param sptr (C++: struc_t *)
            @param mptr (C++: member_t *)
        """
        return _ida_idp.IDB_Hooks_deleting_struc_member(self, *args)

    def struc_member_deleted(self, *args) -> "void":
        r"""


        A structure member has been deleted.
        
        struc_member_deleted(self, sptr, member_id, offset)
            @param sptr (C++: struc_t *)
            @param member_id (C++: tid_t)
            @param offset (C++: ea_t)
        """
        return _ida_idp.IDB_Hooks_struc_member_deleted(self, *args)

    def renaming_struc_member(self, *args) -> "void":
        r"""


        A structure member is to be renamed.
        
        renaming_struc_member(self, sptr, mptr, newname)
            @param sptr (C++: struc_t *)
            @param mptr (C++: member_t *)
            @param newname (C++: const char *)
        """
        return _ida_idp.IDB_Hooks_renaming_struc_member(self, *args)

    def struc_member_renamed(self, *args) -> "void":
        r"""


        A structure member has been renamed.
        
        struc_member_renamed(self, sptr, mptr)
            @param sptr (C++: struc_t *)
            @param mptr (C++: member_t *)
        """
        return _ida_idp.IDB_Hooks_struc_member_renamed(self, *args)

    def changing_struc_member(self, *args) -> "void":
        r"""


        A structure member is to be changed.
        
        changing_struc_member(self, sptr, mptr, flag, ti, nbytes)
            @param sptr (C++: struc_t *)
            @param mptr (C++: member_t *)
            @param flag (C++: flags_t)
            @param ti (C++: const opinfo_t *)
            @param nbytes (C++: asize_t)
        """
        return _ida_idp.IDB_Hooks_changing_struc_member(self, *args)

    def struc_member_changed(self, *args) -> "void":
        r"""


        A structure member has been changed.
        
        struc_member_changed(self, sptr, mptr)
            @param sptr (C++: struc_t *)
            @param mptr (C++: member_t *)
        """
        return _ida_idp.IDB_Hooks_struc_member_changed(self, *args)

    def changing_struc_cmt(self, *args) -> "void":
        r"""


        A structure type comment is to be changed.
        
        changing_struc_cmt(self, struc_id, repeatable, newcmt)
            @param struc_id (C++: tid_t)
            @param repeatable (C++: bool)
            @param newcmt (C++: const char *)
        """
        return _ida_idp.IDB_Hooks_changing_struc_cmt(self, *args)

    def struc_cmt_changed(self, *args) -> "void":
        r"""


        A structure type comment has been changed.
        
        struc_cmt_changed(self, struc_id, repeatable_cmt)
            @param struc_id (C++: tid_t)
            @param repeatable_cmt (C++: bool)
        """
        return _ida_idp.IDB_Hooks_struc_cmt_changed(self, *args)

    def segm_added(self, *args) -> "void":
        r"""


        A new segment has been created.
        
        segm_added(self, s)
            @param s: See also adding_segm  (C++: segment_t *)
        """
        return _ida_idp.IDB_Hooks_segm_added(self, *args)

    def deleting_segm(self, *args) -> "void":
        r"""


        A segment is to be deleted.
        
        deleting_segm(self, start_ea)
            @param start_ea (C++: ea_t)
        """
        return _ida_idp.IDB_Hooks_deleting_segm(self, *args)

    def segm_deleted(self, *args) -> "void":
        r"""


        A segment has been deleted.
        
        segm_deleted(self, start_ea, end_ea)
            @param start_ea (C++: ea_t)
            @param end_ea (C++: ea_t)
        """
        return _ida_idp.IDB_Hooks_segm_deleted(self, *args)

    def changing_segm_start(self, *args) -> "void":
        r"""


        Segment start address is to be changed.
        
        changing_segm_start(self, s, new_start, segmod_flags)
            @param s (C++: segment_t *)
            @param new_start (C++: ea_t)
            @param segmod_flags (C++: int)
        """
        return _ida_idp.IDB_Hooks_changing_segm_start(self, *args)

    def segm_start_changed(self, *args) -> "void":
        r"""


        Segment start address has been changed.
        
        segm_start_changed(self, s, oldstart)
            @param s (C++: segment_t *)
            @param oldstart (C++: ea_t)
        """
        return _ida_idp.IDB_Hooks_segm_start_changed(self, *args)

    def changing_segm_end(self, *args) -> "void":
        r"""


        Segment end address is to be changed.
        
        changing_segm_end(self, s, new_end, segmod_flags)
            @param s (C++: segment_t *)
            @param new_end (C++: ea_t)
            @param segmod_flags (C++: int)
        """
        return _ida_idp.IDB_Hooks_changing_segm_end(self, *args)

    def segm_end_changed(self, *args) -> "void":
        r"""


        Segment end address has been changed.
        
        segm_end_changed(self, s, oldend)
            @param s (C++: segment_t *)
            @param oldend (C++: ea_t)
        """
        return _ida_idp.IDB_Hooks_segm_end_changed(self, *args)

    def changing_segm_name(self, *args) -> "void":
        r"""


        Segment name is being changed.
        
        changing_segm_name(self, s, oldname)
            @param s (C++: segment_t *)
            @param oldname (C++: const char *)
        """
        return _ida_idp.IDB_Hooks_changing_segm_name(self, *args)

    def segm_name_changed(self, *args) -> "void":
        r"""


        Segment name has been changed.
        
        segm_name_changed(self, s, name)
            @param s (C++: segment_t *)
            @param name (C++: const char *)
        """
        return _ida_idp.IDB_Hooks_segm_name_changed(self, *args)

    def changing_segm_class(self, *args) -> "void":
        r"""


        Segment class is being changed.
        
        changing_segm_class(self, s)
            @param s (C++: segment_t *)
        """
        return _ida_idp.IDB_Hooks_changing_segm_class(self, *args)

    def segm_class_changed(self, *args) -> "void":
        r"""


        Segment class has been changed.
        
        segm_class_changed(self, s, sclass)
            @param s (C++: segment_t *)
            @param sclass (C++: const char *)
        """
        return _ida_idp.IDB_Hooks_segm_class_changed(self, *args)

    def segm_attrs_updated(self, *args) -> "void":
        r"""


        Segment attributes has been changed.
        
        segm_attrs_updated(self, s)
            @param s: This event is generated for secondary segment attributes
                      (examples: color, permissions, etc)  (C++: segment_t *)
        """
        return _ida_idp.IDB_Hooks_segm_attrs_updated(self, *args)

    def segm_moved(self, *args) -> "void":
        r"""


        Segment has been moved.
        
        segm_moved(self, _from, to, size, changed_netmap)
            @param _from (C++: ea_t)
            @param to (C++: ea_t)
            @param size (C++: asize_t)
            @param changed_netmap: See also idb_event::allsegs_moved  (C++: bool)
        """
        return _ida_idp.IDB_Hooks_segm_moved(self, *args)

    def allsegs_moved(self, *args) -> "void":
        r"""


        Program rebasing is complete. This event is generated after series of
        segm_moved events
        
        allsegs_moved(self, info)
            @param info (C++: segm_move_infos_t *)
        """
        return _ida_idp.IDB_Hooks_allsegs_moved(self, *args)

    def func_added(self, *args) -> "void":
        r"""


        The kernel has added a function.
        
        func_added(self, pfn)
            @param pfn (C++: func_t *)
        """
        return _ida_idp.IDB_Hooks_func_added(self, *args)

    def func_updated(self, *args) -> "void":
        r"""


        The kernel has updated a function.
        
        func_updated(self, pfn)
            @param pfn (C++: func_t *)
        """
        return _ida_idp.IDB_Hooks_func_updated(self, *args)

    def set_func_start(self, *args) -> "void":
        r"""


        Function chunk start address will be changed.
        
        set_func_start(self, pfn, new_start)
            @param pfn (C++: func_t *)
            @param new_start (C++: ea_t)
        """
        return _ida_idp.IDB_Hooks_set_func_start(self, *args)

    def set_func_end(self, *args) -> "void":
        r"""


        Function chunk end address will be changed.
        
        set_func_end(self, pfn, new_end)
            @param pfn (C++: func_t *)
            @param new_end (C++: ea_t)
        """
        return _ida_idp.IDB_Hooks_set_func_end(self, *args)

    def deleting_func(self, *args) -> "void":
        r"""


        The kernel is about to delete a function.
        
        deleting_func(self, pfn)
            @param pfn (C++: func_t *)
        """
        return _ida_idp.IDB_Hooks_deleting_func(self, *args)

    def frame_deleted(self, *args) -> "void":
        r"""


        The kernel has deleted a function frame.
        
        frame_deleted(self, pfn)
            @param pfn (C++: func_t *)
        """
        return _ida_idp.IDB_Hooks_frame_deleted(self, *args)

    def thunk_func_created(self, *args) -> "void":
        r"""


        A thunk bit has been set for a function.
        
        thunk_func_created(self, pfn)
            @param pfn (C++: func_t *)
        """
        return _ida_idp.IDB_Hooks_thunk_func_created(self, *args)

    def func_tail_appended(self, *args) -> "void":
        r"""


        A function tail chunk has been appended.
        
        func_tail_appended(self, pfn, tail)
            @param pfn (C++: func_t *)
            @param tail (C++: func_t *)
        """
        return _ida_idp.IDB_Hooks_func_tail_appended(self, *args)

    def deleting_func_tail(self, *args) -> "void":
        r"""


        A function tail chunk is to be removed.
        
        deleting_func_tail(self, pfn, tail)
            @param pfn (C++: func_t *)
            @param tail (C++: const range_t *)
        """
        return _ida_idp.IDB_Hooks_deleting_func_tail(self, *args)

    def func_tail_deleted(self, *args) -> "void":
        r"""


        A function tail chunk has been removed.
        
        func_tail_deleted(self, pfn, tail_ea)
            @param pfn (C++: func_t *)
            @param tail_ea (C++: ea_t)
        """
        return _ida_idp.IDB_Hooks_func_tail_deleted(self, *args)

    def tail_owner_changed(self, *args) -> "void":
        r"""


        A tail chunk owner has been changed.
        
        tail_owner_changed(self, tail, owner_func, old_owner)
            @param tail (C++: func_t *)
            @param owner_func (C++: ea_t)
            @param old_owner (C++: ea_t)
        """
        return _ida_idp.IDB_Hooks_tail_owner_changed(self, *args)

    def func_noret_changed(self, *args) -> "void":
        r"""


        'FUNC_NORET' bit has been changed.
        
        func_noret_changed(self, pfn)
            @param pfn (C++: func_t *)
        """
        return _ida_idp.IDB_Hooks_func_noret_changed(self, *args)

    def stkpnts_changed(self, *args) -> "void":
        r"""


        Stack change points have been modified.
        
        stkpnts_changed(self, pfn)
            @param pfn (C++: func_t *)
        """
        return _ida_idp.IDB_Hooks_stkpnts_changed(self, *args)

    def updating_tryblks(self, *args) -> "void":
        r"""


        About to update tryblk information
        
        updating_tryblks(self, tbv)
            @param tbv (C++: const tryblks_t *)
        """
        return _ida_idp.IDB_Hooks_updating_tryblks(self, *args)

    def tryblks_updated(self, *args) -> "void":
        r"""


        Updated tryblk information
        
        tryblks_updated(self, tbv)
            @param tbv (C++: const tryblks_t *)
        """
        return _ida_idp.IDB_Hooks_tryblks_updated(self, *args)

    def deleting_tryblks(self, *args) -> "void":
        r"""


        About to delete tryblk information in given range
        
        deleting_tryblks(self, range)
            @param range (C++: const range_t *)
        """
        return _ida_idp.IDB_Hooks_deleting_tryblks(self, *args)

    def sgr_changed(self, *args) -> "void":
        r"""


        The kernel has changed a segment register value.
        
        sgr_changed(self, start_ea, end_ea, regnum, value, old_value, tag)
            @param start_ea (C++: ea_t)
            @param end_ea (C++: ea_t)
            @param regnum (C++: int)
            @param value (C++: sel_t)
            @param old_value (C++: sel_t)
            @param tag: Segment register range tags  (C++: uchar)
        """
        return _ida_idp.IDB_Hooks_sgr_changed(self, *args)

    def make_code(self, *args) -> "void":
        r"""


        An instruction is being created.
        
        make_code(self, insn)
            @param insn (C++: const insn_t*)
        """
        return _ida_idp.IDB_Hooks_make_code(self, *args)

    def make_data(self, *args) -> "void":
        r"""


        A data item is being created.
        
        make_data(self, ea, flags, tid, len)
            @param ea (C++: ea_t)
            @param flags (C++: flags_t)
            @param tid (C++: tid_t)
            @param len (C++: asize_t)
        """
        return _ida_idp.IDB_Hooks_make_data(self, *args)

    def destroyed_items(self, *args) -> "void":
        r"""


        Instructions/data have been destroyed in [ea1,ea2).
        
        destroyed_items(self, ea1, ea2, will_disable_range)
            @param ea1 (C++: ea_t)
            @param ea2 (C++: ea_t)
            @param will_disable_range (C++: bool)
        """
        return _ida_idp.IDB_Hooks_destroyed_items(self, *args)

    def renamed(self, *args) -> "void":
        r"""


        The kernel has renamed a byte. See also the \idpcode{rename} event
        
        renamed(self, ea, new_name, local_name)
            @param ea (C++: ea_t)
            @param new_name (C++: const char *)
            @param local_name (C++: bool)
        """
        return _ida_idp.IDB_Hooks_renamed(self, *args)

    def byte_patched(self, *args) -> "void":
        r"""


        A byte has been patched.
        
        byte_patched(self, ea, old_value)
            @param ea (C++: ea_t)
            @param old_value (C++: uint32)
        """
        return _ida_idp.IDB_Hooks_byte_patched(self, *args)

    def changing_cmt(self, *args) -> "void":
        r"""


        An item comment is to be changed.
        
        changing_cmt(self, ea, repeatable_cmt, newcmt)
            @param ea (C++: ea_t)
            @param repeatable_cmt (C++: bool)
            @param newcmt (C++: const char *)
        """
        return _ida_idp.IDB_Hooks_changing_cmt(self, *args)

    def cmt_changed(self, *args) -> "void":
        r"""


        An item comment has been changed.
        
        cmt_changed(self, ea, repeatable_cmt)
            @param ea (C++: ea_t)
            @param repeatable_cmt (C++: bool)
        """
        return _ida_idp.IDB_Hooks_cmt_changed(self, *args)

    def changing_range_cmt(self, *args) -> "void":
        r"""


        Range comment is to be changed.
        
        changing_range_cmt(self, kind, a, cmt, repeatable)
            @param kind (C++: range_kind_t)
            @param a (C++: const range_t *)
            @param cmt (C++: const char *)
            @param repeatable (C++: bool)
        """
        return _ida_idp.IDB_Hooks_changing_range_cmt(self, *args)

    def range_cmt_changed(self, *args) -> "void":
        r"""


        Range comment has been changed.
        
        range_cmt_changed(self, kind, a, cmt, repeatable)
            @param kind (C++: range_kind_t)
            @param a (C++: const range_t *)
            @param cmt (C++: const char *)
            @param repeatable (C++: bool)
        """
        return _ida_idp.IDB_Hooks_range_cmt_changed(self, *args)

    def extra_cmt_changed(self, *args) -> "void":
        r"""


        An extra comment has been changed.
        
        extra_cmt_changed(self, ea, line_idx, cmt)
            @param ea (C++: ea_t)
            @param line_idx (C++: int)
            @param cmt (C++: const char *)
        """
        return _ida_idp.IDB_Hooks_extra_cmt_changed(self, *args)

    def item_color_changed(self, *args) -> "void":
        r"""


        An item color has been changed.
        
        item_color_changed(self, ea, color)
            @param ea (C++: ea_t)
            @param color: if color==DEFCOLOR, the the color is deleted.  (C++:
                          bgcolor_t)
        """
        return _ida_idp.IDB_Hooks_item_color_changed(self, *args)

    def callee_addr_changed(self, *args) -> "void":
        r"""


        Callee address has been updated by the user.
        
        callee_addr_changed(self, ea, callee)
            @param ea (C++: ea_t)
            @param callee (C++: ea_t)
        """
        return _ida_idp.IDB_Hooks_callee_addr_changed(self, *args)

    def bookmark_changed(self, *args) -> "void":
        r"""


        Boomarked position changed.
        
        bookmark_changed(self, index, pos, desc)
            @param index (C++: uint32)
            @param pos (C++: const lochist_entry_t *)
            @param desc: if desc==NULL, then the bookmark was deleted.  (C++:
                         const char *)
        """
        return _ida_idp.IDB_Hooks_bookmark_changed(self, *args)

    def sgr_deleted(self, *args) -> "void":
        r"""


        The kernel has deleted a segment register value.
        
        sgr_deleted(self, start_ea, end_ea, regnum)
            @param start_ea (C++: ea_t)
            @param end_ea (C++: ea_t)
            @param regnum (C++: int)
        """
        return _ida_idp.IDB_Hooks_sgr_deleted(self, *args)

    def adding_segm(self, *args) -> "void":
        r"""


        A segment is being created.
        
        adding_segm(self, s)
            @param s (C++: segment_t *)
        """
        return _ida_idp.IDB_Hooks_adding_segm(self, *args)

    def func_deleted(self, *args) -> "void":
        r"""


        A function has been deleted.
        
        func_deleted(self, func_ea)
            @param func_ea (C++: ea_t)
        """
        return _ida_idp.IDB_Hooks_func_deleted(self, *args)

    def dirtree_mkdir(self, *args) -> "void":
        r"""


        Dirtree: a directory has been created.
        
        dirtree_mkdir(self, dt, path)
            @param dt (C++: dirtree_t *)
            @param path (C++: const char *)
        """
        return _ida_idp.IDB_Hooks_dirtree_mkdir(self, *args)

    def dirtree_rmdir(self, *args) -> "void":
        r"""


        Dirtree: a directory has been deleted.
        
        dirtree_rmdir(self, dt, path)
            @param dt (C++: dirtree_t *)
            @param path (C++: const char *)
        """
        return _ida_idp.IDB_Hooks_dirtree_rmdir(self, *args)

    def dirtree_link(self, *args) -> "void":
        r"""


        Dirtree: an item has been linked/unlinked.
        
        dirtree_link(self, dt, path, link)
            @param dt (C++: dirtree_t *)
            @param path (C++: const char *)
            @param link (C++: bool)
        """
        return _ida_idp.IDB_Hooks_dirtree_link(self, *args)

    def dirtree_move(self, *args) -> "void":
        r"""


        Dirtree: a directory or item has been moved.
        
        dirtree_move(self, dt, _from, to)
            @param dt (C++: dirtree_t *)
            @param _from (C++: const char *)
            @param to (C++: const char *)
        """
        return _ida_idp.IDB_Hooks_dirtree_move(self, *args)

    def dirtree_rank(self, *args) -> "void":
        r"""


        Dirtree: a directory or item rank has been changed.
        
        dirtree_rank(self, dt, path, rank)
            @param dt (C++: dirtree_t *)
            @param path (C++: const char *)
            @param rank (C++: size_t)
        """
        return _ida_idp.IDB_Hooks_dirtree_rank(self, *args)

    def dirtree_rminode(self, *args) -> "void":
        r"""


        Dirtree: an inode became unavailable.
        
        dirtree_rminode(self, dt, inode)
            @param dt (C++: dirtree_t *)
            @param inode (C++: inode_t)
        """
        return _ida_idp.IDB_Hooks_dirtree_rminode(self, *args)
    __swig_destroy__ = _ida_idp.delete_IDB_Hooks
    def __disown__(self):
        self.this.disown()
        _ida_idp.disown_IDB_Hooks(self)
        return weakref.proxy(self)

# Register IDB_Hooks in _ida_idp:
_ida_idp.IDB_Hooks_swigregister(IDB_Hooks)


def get_idb_notifier_addr(*args) -> "PyObject *":
    r"""


    get_idb_notifier_addr(arg1) -> PyObject *
        arg1: PyObject *
    """
    return _ida_idp.get_idb_notifier_addr(*args)

def get_idb_notifier_ud_addr(*args) -> "PyObject *":
    r"""


    get_idb_notifier_ud_addr(hooks) -> PyObject *
        hooks: IDB_Hooks *
    """
    return _ida_idp.get_idb_notifier_ud_addr(*args)

#<pycode(py_idp_idbhooks)>

class _processor_t_Trampoline_IDB_Hooks(IDB_Hooks):
    def __init__(self, proc):
        IDB_Hooks.__init__(self, ida_idaapi.HBF_CALL_WITH_NEW_EXEC | ida_idaapi.HBF_VOLATILE_METHOD_SET)
        import weakref
        self.proc = weakref.ref(proc)
        for key in dir(self):
            if not key.startswith("_") and not key in ["proc"]:
                thing = getattr(self, key)
                if hasattr(thing, "__call__"):
                    setattr(self, key, self.__make_parent_caller(key))

    def __dummy(self, *args):
        return 0

    def __make_parent_caller(self, key):
# we can't get the method at this point, as it'll be bound
# to the processor_t instance, which means it'll increase
# the reference counting
        def call_parent(*args):
            return getattr(self.proc(), key, self.__dummy)(*args)
        return call_parent

#</pycode(py_idp_idbhooks)>


#<pycode(py_idp_notify_when)>
import weakref
class _notify_when_dispatcher_t:

    class _callback_t:
        def __init__(self, fun):
            self.fun = fun
            self.slots = 0

    class _IDP_Hooks(IDP_Hooks):
        def __init__(self, dispatcher):
            IDP_Hooks.__init__(self)
            self.dispatcher = weakref.ref(dispatcher)

        def ev_newfile(self, name):
            return self.dispatcher().dispatch(ida_idaapi.NW_OPENIDB, 0)

        def ev_oldfile(self, name):
            return self.dispatcher().dispatch(ida_idaapi.NW_OPENIDB, 1)

    class _IDB_Hooks(IDB_Hooks):
        def __init__(self, dispatcher):
            IDB_Hooks.__init__(self)
            self.dispatcher = weakref.ref(dispatcher)

        def closebase(self):
            return self.dispatcher().dispatch(ida_idaapi.NW_CLOSEIDB)


    def __init__(self):
        self.idp_hooks = self._IDP_Hooks(self)
        self.idp_hooks.hook()
        self.idb_hooks = self._IDB_Hooks(self)
        self.idb_hooks.hook()
        self.callbacks = []

    def _find(self, fun):
        for idx, cb in enumerate(self.callbacks):
            if cb.fun == fun:
                return idx, cb
        return None, None

    def dispatch(self, slot, *args):
        for cb in self.callbacks[:]: # make a copy, since dispatch() could cause some callbacks to disappear
            if (cb.slots & slot) != 0:
                cb.fun(slot, *args)
        return 0

    def notify_when(self, when, fun):
        _, cb = self._find(fun)
        if cb is None:
            cb = self._callback_t(fun)
            self.callbacks.append(cb)
        if (when & ida_idaapi.NW_REMOVE) != 0:
            cb.slots &= ~(when & ~ida_idaapi.NW_REMOVE)
        else:
            cb.slots |= when
        if cb.slots == 0:
            idx, cb = self._find(cb.fun)
            del self.callbacks[idx]
        return True

#</pycode(py_idp_notify_when)>


if _BC695:
    AS_NOTAB=0
    CUSTOM_CMD_ITYPE=CUSTOM_INSN_ITYPE
    InstrIsSet=has_insn_feature
    NEXTEAS_ANSWER_SIZE=0
    PR_FULL_HIFXP=0
    SETPROC_ALL=SETPROC_LOADER_NON_FATAL
    SETPROC_COMPAT=SETPROC_IDB
    SETPROC_FATAL=SETPROC_LOADER
    area_cmt_changed=range_cmt_changed
    changed_stkpnts=stkpnts_changed
    changed_struc=struc_align_changed
    changing_area_cmt=changing_range_cmt
    changing_struc=changing_struc_align
    func_tail_removed=func_tail_deleted
    get_reg_info2=get_reg_info
    ph_get_regCodeSreg=ph_get_reg_code_sreg
    ph_get_regDataSreg=ph_get_reg_data_sreg
    ph_get_regFirstSreg=ph_get_reg_first_sreg
    ph_get_regLastSreg=ph_get_reg_last_sreg
    removing_func_tail=deleting_func_tail
    segm_attrs_changed=segm_attrs_updated
    str2regf=str2reg
    def parse_reg_name(*args):
        if isinstance(args[1], reg_info_t): # 6.95: regname, reg_info_t
              regname, ri = args
        else:                               # 7.00: reg_info_t, regname
              ri, regname = args
        return _ida_idp.parse_reg_name(ri, regname)
    def __call_IDP_Hooks_auto_queue_empty(cb, qtype):
        old_rc = cb(qtype)
        if old_rc == 0: # 6.95's queue not empty anymore
            rc = -1 # 7.0's queue not empty anymore
        else:
            rc = old_rc
        return rc
    import ida_ida
    ida_ida.__wrap_695_hooks_callback(
        IDP_Hooks,
        "ev_auto_queue_empty",
        "auto_queue_empty",
        __call_IDP_Hooks_auto_queue_empty)



