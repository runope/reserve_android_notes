# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.1
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

"""
IDA Plugin SDK API wrapper: ua
"""

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _ida_ua
else:
    import _ida_ua

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """
    Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass
    """
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """
    Meta class to enforce nondynamic attributes (no new attributes) for a class
    """
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import weakref

SWIG_PYTHON_LEGACY_BOOL = _ida_ua.SWIG_PYTHON_LEGACY_BOOL

import ida_idaapi


import sys
_BC695 = sys.modules["__main__"].IDAPYTHON_COMPAT_695_API

if _BC695:






    def bc695redef(func):
        ida_idaapi._BC695.replace_fun(func)
        return func

class operands_array(object):
    r"""
    Proxy of C++ wrapped_array_t< op_t,8 > class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    data = property(_ida_ua.operands_array_data_get)

    def __init__(self, *args):
        r"""


        __init__(self, data) -> operands_array
            data: op_t (&)[8]
        """
        _ida_ua.operands_array_swiginit(self, _ida_ua.new_operands_array(*args))

    def __len__(self, *args) -> "size_t":
        r"""
        __len__(self) -> size_t
        """
        return _ida_ua.operands_array___len__(self, *args)

    def __getitem__(self, *args) -> "op_t const &":
        r"""


        __getitem__(self, i) -> op_t
            i: size_t
        """
        return _ida_ua.operands_array___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        r"""


        __setitem__(self, i, v)
            i: size_t
            v: op_t const &
        """
        return _ida_ua.operands_array___setitem__(self, *args)

    __iter__ = ida_idaapi._bounded_getitem_iterator

    __swig_destroy__ = _ida_ua.delete_operands_array

# Register operands_array in _ida_ua:
_ida_ua.operands_array_swigregister(operands_array)

class op_t(object):
    r"""
    Proxy of C++ op_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    n = property(_ida_ua.op_t_n_get, _ida_ua.op_t_n_set)
    type = property(_ida_ua.op_t_type_get, _ida_ua.op_t_type_set)
    offb = property(_ida_ua.op_t_offb_get, _ida_ua.op_t_offb_set)
    offo = property(_ida_ua.op_t_offo_get, _ida_ua.op_t_offo_set)
    flags = property(_ida_ua.op_t_flags_get, _ida_ua.op_t_flags_set)

    def set_shown(self, *args) -> "void":
        r"""


        Set operand to be shown.
        """
        return _ida_ua.op_t_set_shown(self, *args)

    def clr_shown(self, *args) -> "void":
        r"""


        Set operand to hidden.
        """
        return _ida_ua.op_t_clr_shown(self, *args)

    def shown(self, *args) -> "bool":
        r"""


        Is operand set to be shown?
        """
        return _ida_ua.op_t_shown(self, *args)
    dtype = property(_ida_ua.op_t_dtype_get, _ida_ua.op_t_dtype_set)

    def is_reg(self, *args) -> "bool":
        r"""


        Is register operand?
        
        is_reg(self, r) -> bool
            @param r (C++: int)
        """
        return _ida_ua.op_t_is_reg(self, *args)

    def is_imm(self, *args) -> "bool":
        r"""


        Is immediate operand?
        
        is_imm(self, v) -> bool
            @param v (C++: uval_t)
        """
        return _ida_ua.op_t_is_imm(self, *args)
    specflag1 = property(_ida_ua.op_t_specflag1_get, _ida_ua.op_t_specflag1_set)
    specflag2 = property(_ida_ua.op_t_specflag2_get, _ida_ua.op_t_specflag2_set)
    specflag3 = property(_ida_ua.op_t_specflag3_get, _ida_ua.op_t_specflag3_set)
    specflag4 = property(_ida_ua.op_t_specflag4_get, _ida_ua.op_t_specflag4_set)

    def __get_reg_phrase__(self, *args) -> "uint16":
        r"""
        __get_reg_phrase__(self) -> uint16
        """
        return _ida_ua.op_t___get_reg_phrase__(self, *args)

    def __set_reg_phrase__(self, *args) -> "void":
        r"""


        __set_reg_phrase__(self, r)
            r: uint16
        """
        return _ida_ua.op_t___set_reg_phrase__(self, *args)

    def __get_value__(self, *args) -> "ea_t":
        r"""
        __get_value__(self) -> ea_t
        """
        return _ida_ua.op_t___get_value__(self, *args)

    def __set_value__(self, *args) -> "void":
        r"""


        __set_value__(self, v)
            v: ea_t
        """
        return _ida_ua.op_t___set_value__(self, *args)

    def __get_addr__(self, *args) -> "ea_t":
        r"""
        __get_addr__(self) -> ea_t
        """
        return _ida_ua.op_t___get_addr__(self, *args)

    def __set_addr__(self, *args) -> "void":
        r"""


        __set_addr__(self, v)
            v: ea_t
        """
        return _ida_ua.op_t___set_addr__(self, *args)

    def __get_specval__(self, *args) -> "ea_t":
        r"""
        __get_specval__(self) -> ea_t
        """
        return _ida_ua.op_t___get_specval__(self, *args)

    def __set_specval__(self, *args) -> "void":
        r"""


        __set_specval__(self, v)
            v: ea_t
        """
        return _ida_ua.op_t___set_specval__(self, *args)

    def assign(self, *args) -> "void":
        r"""


        assign(self, other)
            other: op_t const &
        """
        return _ida_ua.op_t_assign(self, *args)

    def has_reg(self, r):
        """
        Checks if the operand accesses the given processor register
        """
        return self.reg == r.reg

    reg = property(__get_reg_phrase__, __set_reg_phrase__)
    phrase = property(__get_reg_phrase__, __set_reg_phrase__)
    value = property(__get_value__, __set_value__)
    addr = property(__get_addr__, __set_addr__)
    specval = property(__get_specval__, __set_specval__)


    def __init__(self, *args):
        r"""
        __init__(self) -> op_t
        """
        _ida_ua.op_t_swiginit(self, _ida_ua.new_op_t(*args))
    __swig_destroy__ = _ida_ua.delete_op_t

# Register op_t in _ida_ua:
_ida_ua.op_t_swigregister(op_t)
cvar = _ida_ua.cvar
o_void = cvar.o_void
o_reg = cvar.o_reg
o_mem = cvar.o_mem
o_phrase = cvar.o_phrase
o_displ = cvar.o_displ
o_imm = cvar.o_imm
o_far = cvar.o_far
o_near = cvar.o_near
o_idpspec0 = cvar.o_idpspec0
o_idpspec1 = cvar.o_idpspec1
o_idpspec2 = cvar.o_idpspec2
o_idpspec3 = cvar.o_idpspec3
o_idpspec4 = cvar.o_idpspec4
o_idpspec5 = cvar.o_idpspec5
OF_NO_BASE_DISP = _ida_ua.OF_NO_BASE_DISP
"""
base displacement doesn't exist. meaningful only for 'o_displ' type.
if set, base displacement ( 'op_t::addr' ) doesn't exist.
"""

OF_OUTER_DISP = _ida_ua.OF_OUTER_DISP
"""
outer displacement exists. meaningful only for 'o_displ' type. if set,
outer displacement ( 'op_t::value' ) exists.
"""

PACK_FORM_DEF = _ida_ua.PACK_FORM_DEF
"""
(! 'o_reg' + 'dt_packreal' )

packed factor defined.
"""

OF_NUMBER = _ida_ua.OF_NUMBER
"""
the operand can be converted to a number only
"""

OF_SHOW = _ida_ua.OF_SHOW
"""
should the operand be displayed?
"""

dt_byte = _ida_ua.dt_byte
"""
8 bit integer
"""

dt_word = _ida_ua.dt_word
"""
16 bit integer
"""

dt_dword = _ida_ua.dt_dword
"""
32 bit integer
"""

dt_float = _ida_ua.dt_float
"""
4 byte floating point
"""

dt_double = _ida_ua.dt_double
"""
8 byte floating point
"""

dt_tbyte = _ida_ua.dt_tbyte
"""
variable size (\\ph{tbyte_size}) floating point
"""

dt_packreal = _ida_ua.dt_packreal
"""
packed real format for mc68040
"""

dt_qword = _ida_ua.dt_qword
"""
64 bit integer
"""

dt_byte16 = _ida_ua.dt_byte16
"""
128 bit integer
"""

dt_code = _ida_ua.dt_code
"""
ptr to code (not used?)
"""

dt_void = _ida_ua.dt_void
"""
none
"""

dt_fword = _ida_ua.dt_fword
"""
48 bit
"""

dt_bitfild = _ida_ua.dt_bitfild
"""
bit field (mc680x0)
"""

dt_string = _ida_ua.dt_string
"""
pointer to asciiz string
"""

dt_unicode = _ida_ua.dt_unicode
"""
pointer to unicode string
"""

dt_ldbl = _ida_ua.dt_ldbl
"""
long double (which may be different from tbyte)
"""

dt_byte32 = _ida_ua.dt_byte32
"""
256 bit integer
"""

dt_byte64 = _ida_ua.dt_byte64
"""
512 bit integer
"""

dt_half = _ida_ua.dt_half
"""
2-byte floating point
"""



def insn_add_cref(*args) -> "void":
    r"""


    insn_add_cref(insn, to, opoff, type)
        insn: an ida_ua.insn_t, or an address (C++: const insn_t &)
        to: ea_t
        opoff: int
        type: enum cref_t
    """
    return _ida_ua.insn_add_cref(*args)

def insn_add_dref(*args) -> "void":
    r"""


    insn_add_dref(insn, to, opoff, type)
        insn: an ida_ua.insn_t, or an address (C++: const insn_t &)
        to: ea_t
        opoff: int
        type: enum dref_t
    """
    return _ida_ua.insn_add_dref(*args)

def insn_add_off_drefs(*args) -> "ea_t":
    r"""


    insn_add_off_drefs(insn, x, type, outf) -> ea_t
        insn: an ida_ua.insn_t, or an address (C++: const insn_t &)
        x: op_t const &
        type: enum dref_t
        outf: int
    """
    return _ida_ua.insn_add_off_drefs(*args)

def insn_create_stkvar(*args) -> "bool":
    r"""


    insn_create_stkvar(insn, x, v, flags) -> bool
        insn: an ida_ua.insn_t, or an address (C++: const insn_t &)
        x: op_t const &
        v: adiff_t
        flags: int
    """
    return _ida_ua.insn_create_stkvar(*args)
class insn_t(object):
    r"""
    Proxy of C++ insn_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(self) -> insn_t
        """
        _ida_ua.insn_t_swiginit(self, _ida_ua.new_insn_t(*args))
    cs = property(_ida_ua.insn_t_cs_get, _ida_ua.insn_t_cs_set)
    ip = property(_ida_ua.insn_t_ip_get, _ida_ua.insn_t_ip_set)
    ea = property(_ida_ua.insn_t_ea_get, _ida_ua.insn_t_ea_set)
    itype = property(_ida_ua.insn_t_itype_get, _ida_ua.insn_t_itype_set)
    size = property(_ida_ua.insn_t_size_get, _ida_ua.insn_t_size_set)
    segpref = property(_ida_ua.insn_t_segpref_get, _ida_ua.insn_t_segpref_set)
    insnpref = property(_ida_ua.insn_t_insnpref_get, _ida_ua.insn_t_insnpref_set)
    flags = property(_ida_ua.insn_t_flags_get, _ida_ua.insn_t_flags_set)
    ops = property(_ida_ua.insn_t_ops_get, _ida_ua.insn_t_ops_set)

    def is_macro(self, *args) -> "bool":
        r"""


        Is a macro instruction?
        """
        return _ida_ua.insn_t_is_macro(self, *args)

    def is_64bit(self, *args) -> "bool":
        r"""


        Belongs to a 64bit segment?
        """
        return _ida_ua.insn_t_is_64bit(self, *args)

    def get_next_byte(self, *args) -> "uint8":
        r"""
        get_next_byte(self) -> uint8
        """
        return _ida_ua.insn_t_get_next_byte(self, *args)

    def get_next_word(self, *args) -> "uint16":
        r"""
        get_next_word(self) -> uint16
        """
        return _ida_ua.insn_t_get_next_word(self, *args)

    def get_next_dword(self, *args) -> "uint32":
        r"""
        get_next_dword(self) -> uint32
        """
        return _ida_ua.insn_t_get_next_dword(self, *args)

    def get_next_qword(self, *args) -> "uint64":
        r"""
        get_next_qword(self) -> uint64
        """
        return _ida_ua.insn_t_get_next_qword(self, *args)

    def create_op_data(self, *args) -> "bool":
        r"""


        create_op_data(self, ea_, opoff, dtype) -> bool
            ea_: ea_t
            opoff: int
            dtype: op_dtype_t
        

        create_op_data(self, ea_, op) -> bool
            ea_: ea_t
            op: op_t const &
        """
        return _ida_ua.insn_t_create_op_data(self, *args)

    def create_stkvar(self, *args) -> "bool":
        r"""


        create_stkvar(self, x, v, flags_) -> bool
            x: op_t const &
            v: adiff_t
            flags_: int
        """
        return _ida_ua.insn_t_create_stkvar(self, *args)

    def add_cref(self, *args) -> "void":
        r"""


        Add a code cross-reference from the instruction.
        
        add_cref(self, to, opoff, type)
            @param to: target linear address (C++: ea_t)
            @param opoff: offset of the operand from the start of instruction. if
                          the offset is unknown, then 0. (C++: int)
            @param type: type of xref (C++: cref_t)
        """
        return _ida_ua.insn_t_add_cref(self, *args)

    def add_dref(self, *args) -> "void":
        r"""


        Add a data cross-reference from the instruction. See 'add_off_drefs()'
        - usually it can be used in most cases.
        
        add_dref(self, to, opoff, type)
            @param to: target linear address (C++: ea_t)
            @param opoff: offset of the operand from the start of instruction if
                          the offset is unknown, then 0 (C++: int)
            @param type: type of xref (C++: dref_t)
        """
        return _ida_ua.insn_t_add_dref(self, *args)

    def add_off_drefs(self, *args) -> "ea_t":
        r"""


        Add xrefs for an operand of the instruction. This function creates all
        cross references for 'enum', 'offset' and 'structure offset' operands.
        Use 'add_off_drefs()' in the presence of negative offsets.
        
        add_off_drefs(self, x, type, outf) -> ea_t
            @param x: reference to operand (C++: const  op_t  &)
            @param type: type of xref (C++: dref_t)
            @param outf: out_value() flags. These flags should match the flags
                         used to output the operand (C++: int)
            @return: if  is_off() : the reference target address (the same as
                     calc_reference_data). if  is_stroff() :  BADADDR  because for
                     stroffs the target address is unknown else:  BADADDR  because
                     enums do not represent addresses
        """
        return _ida_ua.insn_t_add_off_drefs(self, *args)

    def __get_ops__(self, *args) -> "wrapped_array_t< op_t,8 >":
        r"""
        __get_ops__(self) -> operands_array
        """
        return _ida_ua.insn_t___get_ops__(self, *args)

    def __get_operand__(self, *args) -> "op_t *":
        r"""


        __get_operand__(self, n) -> op_t
            n: int
        """
        return _ida_ua.insn_t___get_operand__(self, *args)

    def __get_auxpref__(self, *args) -> "uint32":
        r"""
        __get_auxpref__(self) -> uint32
        """
        return _ida_ua.insn_t___get_auxpref__(self, *args)

    def __set_auxpref__(self, *args) -> "void":
        r"""


        __set_auxpref__(self, v)
            v: uint32
        """
        return _ida_ua.insn_t___set_auxpref__(self, *args)

    def assign(self, *args) -> "void":
        r"""


        assign(self, other)
            other: an ida_ua.insn_t, or an address (C++: const insn_t &)
        """
        return _ida_ua.insn_t_assign(self, *args)

    def is_canon_insn(self, *args) -> "bool":
        r"""


        see \ph{ 'is_canon_insn()' }
        
        is_canon_insn(self, ph) -> bool
            @param ph (C++: const  processor_t  &)
        """
        return _ida_ua.insn_t_is_canon_insn(self, *args)

    def get_canon_feature(self, *args) -> "uint32":
        r"""


        see 'instruc_t::feature'
        
        get_canon_feature(self, ph) -> uint32
            @param ph (C++: const  processor_t  &)
        """
        return _ida_ua.insn_t_get_canon_feature(self, *args)

    def get_canon_mnem(self, *args) -> "char const *":
        r"""


        see 'instruc_t::name'
        
        get_canon_mnem(self, ph) -> char const
            @param ph (C++: const  processor_t  &)
        """
        return _ida_ua.insn_t_get_canon_mnem(self, *args)

    ops = property(__get_ops__)

    if _BC695:
        Operands = ops

    Op1 = property(lambda self: self.__get_operand__(0))
    Op2 = property(lambda self: self.__get_operand__(1))
    Op3 = property(lambda self: self.__get_operand__(2))
    Op4 = property(lambda self: self.__get_operand__(3))
    Op5 = property(lambda self: self.__get_operand__(4))
    Op6 = property(lambda self: self.__get_operand__(5))

    auxpref = property(__get_auxpref__, __set_auxpref__)

    def __iter__(self):
        return (self.ops[idx] for idx in range(0, 8))

    def __getitem__(self, idx):
        """


                Operands can be accessed directly as indexes
                @return op_t: Returns an operand of type op_t
        """
        if idx >= 8:
            raise KeyError
        else:
            return self.ops[idx]

    __swig_destroy__ = _ida_ua.delete_insn_t

# Register insn_t in _ida_ua:
_ida_ua.insn_t_swigregister(insn_t)
INSN_MACRO = _ida_ua.INSN_MACRO
"""
macro instruction
"""

INSN_MODMAC = _ida_ua.INSN_MODMAC
"""
may modify the database to make room for the macro insn
"""

INSN_64BIT = _ida_ua.INSN_64BIT
"""
belongs to 64bit segment?
"""

STKVAR_VALID_SIZE = _ida_ua.STKVAR_VALID_SIZE



def get_lookback(*args) -> "int":
    r"""


    Number of instructions to look back. This variable is not used by the
    kernel. Its value may be specified in ida.cfg: LOOKBACK = <number>.
    IDP may use it as you like it. (TMS module uses it)
    """
    return _ida_ua.get_lookback(*args)

def calc_dataseg(*args) -> "ea_t":
    r"""


    Get data segment for the instruction operand. 'opnum' and 'rgnum' are
    meaningful only if the processor has segment registers.
    
    calc_dataseg(insn, n=-1, rgnum=-1) -> ea_t
        @param insn  - an ida_ua.insn_t, or an address (C++: const insn_t &)
        @param n (C++: int)
        @param rgnum (C++: int)
    """
    return _ida_ua.calc_dataseg(*args)

def map_data_ea(*args) -> "ea_t":
    r"""


    Map a data address.
    
    map_data_ea(insn, addr, opnum=-1) -> ea_t
        @param insn: the current instruction  - an ida_ua.insn_t, or an
                     address (C++: const insn_t &)
        @param addr: the referenced address to map (C++: ea_t)
        @param opnum: operand number (C++: int)
    

    map_data_ea(insn, op) -> ea_t
        @param insn: the current instruction  - an ida_ua.insn_t, or an
                     address (C++: const insn_t &)
        op: op_t const &
    """
    return _ida_ua.map_data_ea(*args)

def map_code_ea(*args) -> "ea_t":
    r"""


    Map a code address. This function takes into account the segment
    translations.
    
    map_code_ea(insn, addr, opnum) -> ea_t
        @param insn: the current instruction  - an ida_ua.insn_t, or an
                     address (C++: const insn_t &)
        @param addr: the referenced address to map (C++: ea_t)
        @param opnum: operand number (C++: int)
    

    map_code_ea(insn, op) -> ea_t
        @param insn: the current instruction  - an ida_ua.insn_t, or an
                     address (C++: const insn_t &)
        op: op_t const &
    """
    return _ida_ua.map_code_ea(*args)

def map_ea(*args) -> "ea_t":
    r"""


    map_ea(insn, op, iscode) -> ea_t
        @param insn  - an ida_ua.insn_t, or an address (C++: const insn_t &)
        @param op (C++: const  op_t  &)
        @param iscode (C++: bool)
    

    map_ea(insn, addr, opnum, iscode) -> ea_t
        @param insn  - an ida_ua.insn_t, or an address (C++: const insn_t &)
        addr: ea_t
        opnum: int
        @param iscode (C++: bool)
    """
    return _ida_ua.map_ea(*args)
class outctx_base_t(object):
    r"""
    Proxy of C++ outctx_base_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    insn_ea = property(_ida_ua.outctx_base_t_insn_ea_get, _ida_ua.outctx_base_t_insn_ea_set)
    outbuf = property(_ida_ua.outctx_base_t_outbuf_get, _ida_ua.outctx_base_t_outbuf_set)
    default_lnnum = property(_ida_ua.outctx_base_t_default_lnnum_get, _ida_ua.outctx_base_t_default_lnnum_set)

    def only_main_line(self, *args) -> "bool":
        r"""
        only_main_line(self) -> bool
        """
        return _ida_ua.outctx_base_t_only_main_line(self, *args)

    def multiline(self, *args) -> "bool":
        r"""
        multiline(self) -> bool
        """
        return _ida_ua.outctx_base_t_multiline(self, *args)

    def force_code(self, *args) -> "bool":
        r"""
        force_code(self) -> bool
        """
        return _ida_ua.outctx_base_t_force_code(self, *args)

    def stack_view(self, *args) -> "bool":
        r"""
        stack_view(self) -> bool
        """
        return _ida_ua.outctx_base_t_stack_view(self, *args)

    def display_voids(self, *args) -> "bool":
        r"""
        display_voids(self) -> bool
        """
        return _ida_ua.outctx_base_t_display_voids(self, *args)

    def set_gen_xrefs(self, *args) -> "void":
        r"""


        set_gen_xrefs(self, on=True)
            @param on (C++: bool)
        """
        return _ida_ua.outctx_base_t_set_gen_xrefs(self, *args)

    def set_gen_cmt(self, *args) -> "void":
        r"""


        set_gen_cmt(self, on=True)
            @param on (C++: bool)
        """
        return _ida_ua.outctx_base_t_set_gen_cmt(self, *args)

    def clr_gen_label(self, *args) -> "void":
        r"""
        clr_gen_label(self)
        """
        return _ida_ua.outctx_base_t_clr_gen_label(self, *args)

    def set_gen_label(self, *args) -> "void":
        r"""
        set_gen_label(self)
        """
        return _ida_ua.outctx_base_t_set_gen_label(self, *args)

    def set_gen_demangled_label(self, *args) -> "void":
        r"""
        set_gen_demangled_label(self)
        """
        return _ida_ua.outctx_base_t_set_gen_demangled_label(self, *args)

    def set_comment_addr(self, *args) -> "void":
        r"""


        set_comment_addr(self, ea)
            @param ea (C++: ea_t)
        """
        return _ida_ua.outctx_base_t_set_comment_addr(self, *args)

    def set_dlbind_opnd(self, *args) -> "void":
        r"""
        set_dlbind_opnd(self)
        """
        return _ida_ua.outctx_base_t_set_dlbind_opnd(self, *args)

    def print_label_now(self, *args) -> "bool":
        r"""
        print_label_now(self) -> bool
        """
        return _ida_ua.outctx_base_t_print_label_now(self, *args)

    def forbid_annotations(self, *args) -> "int":
        r"""
        forbid_annotations(self) -> int
        """
        return _ida_ua.outctx_base_t_forbid_annotations(self, *args)

    def restore_ctxflags(self, *args) -> "void":
        r"""


        restore_ctxflags(self, saved_flags)
            @param saved_flags (C++: int)
        """
        return _ida_ua.outctx_base_t_restore_ctxflags(self, *args)

    def out_printf(self, *args) -> "void":
        r"""


        Functions to append text to the current output buffer (outbuf) Append
        a formatted string to the output string.
        
        out_printf(self, format)
            @param format (C++: const char *)
            @return: the number of characters appended
        """
        return _ida_ua.outctx_base_t_out_printf(self, *args)

    def out_value(self, *args) -> "flags_t":
        r"""


        Output immediate value. Try to use this function to output all
        constants of instruction operands. This function outputs a number from
        x.addr or x.value in the form determined by ::uFlag. It outputs a
        colored text.-1 is output with 'COLOR_ERROR' 0 is output as a number
        or character or segment
        
        out_value(self, x, outf=0) -> flags_t
            @param x (C++: const  op_t  &)
            @param outf (C++: int)
            @return: flags of the output value
        """
        return _ida_ua.outctx_base_t_out_value(self, *args)

    def out_symbol(self, *args) -> "void":
        r"""


        Output a character with 'COLOR_SYMBOL' color.
        
        out_symbol(self, c)
            @param c (C++: char)
        """
        return _ida_ua.outctx_base_t_out_symbol(self, *args)

    def out_chars(self, *args) -> "void":
        r"""


        Append a character multiple times.
        
        out_chars(self, c, n)
            @param c (C++: char)
            @param n (C++: int)
        """
        return _ida_ua.outctx_base_t_out_chars(self, *args)

    def out_spaces(self, *args) -> "void":
        r"""


        Appends spaces to outbuf until its tag_strlen becomes 'len'.
        
        out_spaces(self, len)
            @param len (C++: ssize_t)
        """
        return _ida_ua.outctx_base_t_out_spaces(self, *args)

    def out_line(self, *args) -> "void":
        r"""


        Output a string with the specified color.
        
        out_line(self, str, color=0)
            @param str (C++: const char *)
            @param color (C++: color_t)
        """
        return _ida_ua.outctx_base_t_out_line(self, *args)

    def out_keyword(self, *args) -> "void":
        r"""


        Output a string with 'COLOR_KEYWORD' color.
        
        out_keyword(self, str)
            @param str (C++: const char *)
        """
        return _ida_ua.outctx_base_t_out_keyword(self, *args)

    def out_register(self, *args) -> "void":
        r"""


        Output a character with 'COLOR_REG' color.
        
        out_register(self, str)
            @param str (C++: const char *)
        """
        return _ida_ua.outctx_base_t_out_register(self, *args)

    def out_tagon(self, *args) -> "void":
        r"""


        Output "turn color on" escape sequence.
        
        out_tagon(self, tag)
            @param tag (C++: color_t)
        """
        return _ida_ua.outctx_base_t_out_tagon(self, *args)

    def out_tagoff(self, *args) -> "void":
        r"""


        Output "turn color off" escape sequence.
        
        out_tagoff(self, tag)
            @param tag (C++: color_t)
        """
        return _ida_ua.outctx_base_t_out_tagoff(self, *args)

    def out_addr_tag(self, *args) -> "void":
        r"""


        Output "address" escape sequence.
        
        out_addr_tag(self, ea)
            @param ea (C++: ea_t)
        """
        return _ida_ua.outctx_base_t_out_addr_tag(self, *args)

    def out_colored_register_line(self, *args) -> "void":
        r"""


        Output a colored line with register names in it. The register names
        will be substituted by user-defined names ( 'regvar_t' ) Please note
        that out_tagoff tries to make substitutions too (when called with
        COLOR_REG)
        
        out_colored_register_line(self, str)
            @param str (C++: const char *)
        """
        return _ida_ua.outctx_base_t_out_colored_register_line(self, *args)

    def out_char(self, *args) -> "void":
        r"""


        Output one character. The character is output without color codes. see
        also 'out_symbol()'
        
        out_char(self, c)
            @param c (C++: char)
        """
        return _ida_ua.outctx_base_t_out_char(self, *args)

    def out_btoa(self, *args) -> "void":
        r"""


        Output a number with the specified base (binary, octal, decimal, hex)
        The number is output without color codes. see also 'out_long()'
        
        out_btoa(self, Word, radix=0)
            @param Word (C++: uval_t)
            @param radix (C++: char)
        """
        return _ida_ua.outctx_base_t_out_btoa(self, *args)

    def out_long(self, *args) -> "void":
        r"""


        Output a number with appropriate color. Low level function. Use
        'out_value()' if you can. if 'suspop' is set then this function uses
        'COLOR_VOIDOP' instead of 'COLOR_NUMBER' . 'suspop' is initialized:in
        out_one_operand()in ..\ida\gl.cpp (before calling \ph{d_out()})
        
        out_long(self, v, radix)
            @param v (C++: sval_t)
            @param radix (C++: char)
        """
        return _ida_ua.outctx_base_t_out_long(self, *args)

    def out_name_expr(self, *args) -> "bool":
        r"""


        Output a name expression.
        
        out_name_expr(self, x, ea, off=BADADDR) -> bool
            @param x: instruction operand referencing the name expression (C++:
                      const  op_t  &)
            @param ea: address to convert to name expression (C++: ea_t)
            @param off: the value of name expression. this parameter is used only
                        to check that the name expression will have the wanted
                        value. You may pass  BADADDR  for this parameter but I
                        discourage it because it prohibits checks. (C++: adiff_t)
            @return: true if the name expression has been produced
        """
        return _ida_ua.outctx_base_t_out_name_expr(self, *args)

    def close_comment(self, *args) -> "void":
        r"""
        close_comment(self)
        """
        return _ida_ua.outctx_base_t_close_comment(self, *args)

    def flush_outbuf(self, *args) -> "bool":
        r"""


        Functions to populate the output line array (lnar) Move the contents
        of the output buffer to the line array (outbuf->lnar) The kernel
        augments the outbuf contents with additional text like the line
        prefix, user-defined comments, xrefs, etc at this call.
        
        flush_outbuf(self, indent=-1) -> bool
            @param indent (C++: int)
        """
        return _ida_ua.outctx_base_t_flush_outbuf(self, *args)

    def flush_buf(self, *args) -> "bool":
        r"""


        Append contents of 'buf' to the line array. Behaves like flush_outbuf
        but accepts an arbitrary buffer
        
        flush_buf(self, buf, indent=-1) -> bool
            @param buf (C++: const char *)
            @param indent (C++: int)
        """
        return _ida_ua.outctx_base_t_flush_buf(self, *args)

    def term_outctx(self, *args) -> "int":
        r"""


        Finalize the output context.
        
        term_outctx(self, prefix=None) -> int
            @param prefix (C++: const char *)
            @return: the number of generated lines.
        """
        return _ida_ua.outctx_base_t_term_outctx(self, *args)

    def gen_printf(self, *args) -> "bool":
        r"""


        printf-like function to add lines to the line array.
        
        gen_printf(self, indent, format) -> bool
            @param indent: indention of the line. if indent == -1, the kernel will
                           indent the line at \inf{indent}. if indent < 0, -indent
                           will be used for indention. The first line printed with
                           indent < 0 is considered as the most important line at
                           the current address. Usually it is the line with the
                           instruction itself. This line will be displayed in the
                           cross-reference lists and other places. If you need to
                           output an additional line before the main line then
                           pass DEFAULT_INDENT instead of -1. The kernel will know
                           that your line is not the most important one. (C++:
                           int)
            @param format: printf style colored line to generate (C++: const char
                           *)
            @return: overflow, lnar_maxsize has been reached
        """
        return _ida_ua.outctx_base_t_gen_printf(self, *args)

    def gen_empty_line(self, *args) -> "bool":
        r"""


        Generate empty line. This function does nothing if generation of empty
        lines is disabled.
        """
        return _ida_ua.outctx_base_t_gen_empty_line(self, *args)

    def gen_border_line(self, *args) -> "bool":
        r"""


        Generate thin border line. This function does nothing if generation of
        border lines is disabled.
        
        gen_border_line(self, solid=False) -> bool
            @param solid: generate solid border line (with =), otherwise with -
                          (C++: bool)
            @return: overflow, lnar_maxsize has been reached
        """
        return _ida_ua.outctx_base_t_gen_border_line(self, *args)

    def gen_cmt_line(self, *args) -> "bool":
        r"""


        Generate one non-indented comment line, colored with 'COLOR_AUTOCMT' .
        
        gen_cmt_line(self, format) -> bool
            @param format: printf() style format line. The resulting comment line
                           should not include comment character (;) (C++: const
                           char *)
            @return: overflow, lnar_maxsize has been reached
        """
        return _ida_ua.outctx_base_t_gen_cmt_line(self, *args)

    def gen_collapsed_line(self, *args) -> "bool":
        r"""


        Generate one non-indented comment line, colored with 'COLOR_COLLAPSED'
        .
        
        gen_collapsed_line(self, format) -> bool
            @param format: printf() style format line. The resulting comment line
                           should not include comment character (;) (C++: const
                           char *)
            @return: overflow, lnar_maxsize has been reached
        """
        return _ida_ua.outctx_base_t_gen_collapsed_line(self, *args)

    def gen_block_cmt(self, *args) -> "bool":
        r"""


        Generate big non-indented comment lines.
        
        gen_block_cmt(self, cmt, color) -> bool
            @param cmt: comment text. may contain \n characters to denote new
                        lines. should not contain comment character (;) (C++:
                        const char *)
            @param color: color of comment text (one of  Color tags ) (C++:
                          color_t)
            @return: overflow, lnar_maxsize has been reached
        """
        return _ida_ua.outctx_base_t_gen_block_cmt(self, *args)

    def setup_outctx(self, *args) -> "void":
        r"""


        Initialization; normally used only by the kernel.
        
        setup_outctx(self, prefix, makeline_flags)
            @param prefix (C++: const char *)
            @param makeline_flags (C++: int)
        """
        return _ida_ua.outctx_base_t_setup_outctx(self, *args)

    def retrieve_cmt(self, *args) -> "ssize_t":
        r"""
        retrieve_cmt(self) -> ssize_t
        """
        return _ida_ua.outctx_base_t_retrieve_cmt(self, *args)

    def retrieve_name(self, *args) -> "ssize_t":
        r"""


        retrieve_name(self, arg2, arg3) -> ssize_t
            arg2: qstring *
            arg3: color_t *
        """
        return _ida_ua.outctx_base_t_retrieve_name(self, *args)

    def gen_xref_lines(self, *args) -> "bool":
        r"""
        gen_xref_lines(self) -> bool
        """
        return _ida_ua.outctx_base_t_gen_xref_lines(self, *args)

    def init_lines_array(self, *args) -> "void":
        r"""


        init_lines_array(self, answers, maxsize)
            @param answers (C++: qstrvec_t  *)
            @param maxsize (C++: int)
        """
        return _ida_ua.outctx_base_t_init_lines_array(self, *args)

    def get_stkvar(self, *args) -> "member_t *":
        r"""


        get_stkvar(self, arg2, arg3, arg4, arg5) -> member_t *
            arg2: op_t const &
            arg3: uval_t
            arg4: sval_t *
            arg5: int *
        """
        return _ida_ua.outctx_base_t_get_stkvar(self, *args)

    def gen_empty_line_without_annotations(self, *args) -> "void":
        r"""
        gen_empty_line_without_annotations(self)
        """
        return _ida_ua.outctx_base_t_gen_empty_line_without_annotations(self, *args)

# Register outctx_base_t in _ida_ua:
_ida_ua.outctx_base_t_swigregister(outctx_base_t)
CTXF_MAIN = _ida_ua.CTXF_MAIN

CTXF_MULTI = _ida_ua.CTXF_MULTI

CTXF_CODE = _ida_ua.CTXF_CODE

CTXF_STACK = _ida_ua.CTXF_STACK

CTXF_GEN_XREFS = _ida_ua.CTXF_GEN_XREFS

CTXF_XREF_STATE = _ida_ua.CTXF_XREF_STATE

XREFSTATE_NONE = _ida_ua.XREFSTATE_NONE

XREFSTATE_GO = _ida_ua.XREFSTATE_GO

XREFSTATE_DONE = _ida_ua.XREFSTATE_DONE

CTXF_GEN_CMT = _ida_ua.CTXF_GEN_CMT

CTXF_CMT_STATE = _ida_ua.CTXF_CMT_STATE

COMMSTATE_NONE = _ida_ua.COMMSTATE_NONE

COMMSTATE_GO = _ida_ua.COMMSTATE_GO

COMMSTATE_DONE = _ida_ua.COMMSTATE_DONE

CTXF_VOIDS = _ida_ua.CTXF_VOIDS

CTXF_NORMAL_LABEL = _ida_ua.CTXF_NORMAL_LABEL

CTXF_DEMANGLED_LABEL = _ida_ua.CTXF_DEMANGLED_LABEL

CTXF_LABEL_OK = _ida_ua.CTXF_LABEL_OK

CTXF_DEMANGLED_OK = _ida_ua.CTXF_DEMANGLED_OK

CTXF_OVSTORE_PRNT = _ida_ua.CTXF_OVSTORE_PRNT

CTXF_OUTCTX_T = _ida_ua.CTXF_OUTCTX_T

CTXF_DBLIND_OPND = _ida_ua.CTXF_DBLIND_OPND

CTXF_BINOP_STATE = _ida_ua.CTXF_BINOP_STATE

BINOPSTATE_NONE = _ida_ua.BINOPSTATE_NONE

BINOPSTATE_GO = _ida_ua.BINOPSTATE_GO

BINOPSTATE_DONE = _ida_ua.BINOPSTATE_DONE

OOF_SIGNMASK = _ida_ua.OOF_SIGNMASK
"""
sign symbol (+/-) output
"""

OOFS_IFSIGN = _ida_ua.OOFS_IFSIGN
"""
output sign if needed
"""

OOFS_NOSIGN = _ida_ua.OOFS_NOSIGN
"""
don't output sign, forbid the user to change the sign
"""

OOFS_NEEDSIGN = _ida_ua.OOFS_NEEDSIGN
"""
always out sign (+-)
"""

OOF_SIGNED = _ida_ua.OOF_SIGNED
"""
output as signed if < 0
"""

OOF_NUMBER = _ida_ua.OOF_NUMBER
"""
always as a number
"""

OOF_WIDTHMASK = _ida_ua.OOF_WIDTHMASK
"""
width of value in bits
"""

OOFW_IMM = _ida_ua.OOFW_IMM
"""
take from x.dtype
"""

OOFW_8 = _ida_ua.OOFW_8
"""
8 bit width
"""

OOFW_16 = _ida_ua.OOFW_16
"""
16 bit width
"""

OOFW_24 = _ida_ua.OOFW_24
"""
24 bit width
"""

OOFW_32 = _ida_ua.OOFW_32
"""
32 bit width
"""

OOFW_64 = _ida_ua.OOFW_64
"""
64 bit width
"""

OOF_ADDR = _ida_ua.OOF_ADDR
"""
output x.addr, otherwise x.value
"""

OOF_OUTER = _ida_ua.OOF_OUTER
"""
output outer operand
"""

OOF_ZSTROFF = _ida_ua.OOF_ZSTROFF
"""
meaningful only if is_stroff(uFlag) append a struct field name if the
field offset is zero? if 'AFL_ZSTROFF' is set, then this flag is
ignored.
"""

OOF_NOBNOT = _ida_ua.OOF_NOBNOT
"""
prohibit use of binary not
"""

OOF_SPACES = _ida_ua.OOF_SPACES
"""
currently works only for floating point numbers

do not suppress leading spaces
"""

OOF_ANYSERIAL = _ida_ua.OOF_ANYSERIAL
"""
if enum: select first available serial
"""

DEFAULT_INDENT = _ida_ua.DEFAULT_INDENT

MAKELINE_NONE = _ida_ua.MAKELINE_NONE

MAKELINE_BINPREF = _ida_ua.MAKELINE_BINPREF

MAKELINE_VOID = _ida_ua.MAKELINE_VOID

MAKELINE_STACK = _ida_ua.MAKELINE_STACK


class outctx_t(outctx_base_t):
    r"""
    Proxy of C++ outctx_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    bin_ea = property(_ida_ua.outctx_t_bin_ea_get, _ida_ua.outctx_t_bin_ea_set)
    bin_state = property(_ida_ua.outctx_t_bin_state_get, _ida_ua.outctx_t_bin_state_set)
    gl_bpsize = property(_ida_ua.outctx_t_gl_bpsize_get, _ida_ua.outctx_t_gl_bpsize_set)
    bin_width = property(_ida_ua.outctx_t_bin_width_get, _ida_ua.outctx_t_bin_width_set)
    insn = property(_ida_ua.outctx_t_insn_get, _ida_ua.outctx_t_insn_set)
    curlabel = property(_ida_ua.outctx_t_curlabel_get, _ida_ua.outctx_t_curlabel_set)
    wif = property(_ida_ua.outctx_t_wif_get, _ida_ua.outctx_t_wif_set)
    procmod = property(_ida_ua.outctx_t_procmod_get, _ida_ua.outctx_t_procmod_set)
    ph = property(_ida_ua.outctx_t_ph_get, _ida_ua.outctx_t_ph_set)
    ash = property(_ida_ua.outctx_t_ash_get, _ida_ua.outctx_t_ash_set)

    def setup_outctx(self, *args) -> "void":
        r"""


        Initialization; normally used only by the kernel.
        
        setup_outctx(self, prefix, flags)
            @param prefix (C++: const char *)
            flags: int
        """
        return _ida_ua.outctx_t_setup_outctx(self, *args)

    def retrieve_cmt(self, *args) -> "ssize_t":
        r"""
        retrieve_cmt(self) -> ssize_t
        """
        return _ida_ua.outctx_t_retrieve_cmt(self, *args)

    def retrieve_name(self, *args) -> "ssize_t":
        r"""


        retrieve_name(self, arg2, arg3) -> ssize_t
            arg2: qstring *
            arg3: color_t *
        """
        return _ida_ua.outctx_t_retrieve_name(self, *args)

    def gen_xref_lines(self, *args) -> "bool":
        r"""
        gen_xref_lines(self) -> bool
        """
        return _ida_ua.outctx_t_gen_xref_lines(self, *args)

    def set_bin_state(self, *args) -> "void":
        r"""


        set_bin_state(self, value)
            @param value (C++: int)
        """
        return _ida_ua.outctx_t_set_bin_state(self, *args)

    def out_mnem(self, *args) -> "void":
        r"""


        Output instruction mnemonic for 'insn' using information in
        'ph.instruc' array. This function outputs a colored text. It should be
        called from \ph{ev_out_insn()} or \ph{ev_out_mnem()} handler. It will
        output at least one space after the instruction. mnemonic even if the
        specified 'width' is not enough.
        
        out_mnem(self, width=8, postfix=None)
            @param width: width of field with mnemonic. if < 0, then 'postfix'
                          will be output before the mnemonic, i.e. as a prefix
                          (C++: int)
            @param postfix: optional postfix added to the instruction mnemonic
                            (C++: const char *)
        """
        return _ida_ua.outctx_t_out_mnem(self, *args)

    def out_custom_mnem(self, *args) -> "void":
        r"""


        Output custom mnemonic for 'insn'. E.g. if it should differ from the
        one in 'ph.instruc'. This function outputs colored text. See
        'out_mnem'
        
        out_custom_mnem(self, mnem, width=8, postfix=None)
            @param mnem: custom mnemonic (C++: const char *)
            @param width: width of field with mnemonic. if < 0, then 'postfix'
                          will be output before the mnemonic, i.e. as a prefix
                          (C++: int)
            @param postfix: optional postfix added to 'mnem' (C++: const char *)
        """
        return _ida_ua.outctx_t_out_custom_mnem(self, *args)

    def out_mnemonic(self, *args) -> "void":
        r"""


        Output instruction mnemonic using information in 'insn'. It should be
        called from \ph{ev_out_insn()} and it will call \ph{ev_out_mnem()} or
        'out_mnem' . This function outputs a colored text.
        """
        return _ida_ua.outctx_t_out_mnemonic(self, *args)

    def out_one_operand(self, *args) -> "bool":
        r"""


        Use this function to output an operand of an instruction. This
        function checks for the existence of a manually defined operand and
        will output it if it exists. It should be called from
        \ph{ev_out_insn()} and it will call \ph{ev_out_operand()}. This
        function outputs a colored text.
        
        out_one_operand(self, n) -> bool
            @param n: number of operand (C++: int)
            @retval: 1 - operand is displayed
            @retval: 0 - operand is hidden
        """
        return _ida_ua.outctx_t_out_one_operand(self, *args)

    def out_immchar_cmts(self, *args) -> "void":
        r"""


        Print all operand values as commented character constants. This
        function is used to comment void operands with their representation in
        the form of character constants. This function outputs a colored text.
        """
        return _ida_ua.outctx_t_out_immchar_cmts(self, *args)

    def gen_func_header(self, *args) -> "void":
        r"""


        gen_func_header(self, pfn)
            @param pfn (C++: func_t  *)
        """
        return _ida_ua.outctx_t_gen_func_header(self, *args)

    def gen_func_footer(self, *args) -> "void":
        r"""


        gen_func_footer(self, pfn)
            @param pfn (C++: const  func_t  *)
        """
        return _ida_ua.outctx_t_gen_func_footer(self, *args)

    def out_data(self, *args) -> "void":
        r"""


        out_data(self, analyze_only)
            @param analyze_only (C++: bool)
        """
        return _ida_ua.outctx_t_out_data(self, *args)

    def out_specea(self, *args) -> "bool":
        r"""


        out_specea(self, segtype) -> bool
            @param segtype (C++: uchar)
        """
        return _ida_ua.outctx_t_out_specea(self, *args)

    def gen_header_extra(self, *args) -> "void":
        r"""
        gen_header_extra(self)
        """
        return _ida_ua.outctx_t_gen_header_extra(self, *args)

    def gen_header(self, *args) -> "void":
        r"""


        gen_header(self, flags=((1 << 0)|(1 << 1)), proc_name=None, proc_flavour=None)
            @param flags (C++: int)
            @param proc_name (C++: const char *)
            @param proc_flavour (C++: const char *)
        """
        return _ida_ua.outctx_t_gen_header(self, *args)

# Register outctx_t in _ida_ua:
_ida_ua.outctx_t_swigregister(outctx_t)
GH_PRINT_PROC = _ida_ua.GH_PRINT_PROC

GH_PRINT_ASM = _ida_ua.GH_PRINT_ASM

GH_PRINT_BYTESEX = _ida_ua.GH_PRINT_BYTESEX

GH_PRINT_HEADER = _ida_ua.GH_PRINT_HEADER

GH_BYTESEX_HAS_HIGHBYTE = _ida_ua.GH_BYTESEX_HAS_HIGHBYTE

GH_PRINT_PROC_AND_ASM = _ida_ua.GH_PRINT_PROC_AND_ASM

GH_PRINT_PROC_ASM_AND_BYTESEX = _ida_ua.GH_PRINT_PROC_ASM_AND_BYTESEX

GH_PRINT_ALL = _ida_ua.GH_PRINT_ALL

GH_PRINT_ALL_BUT_BYTESEX = _ida_ua.GH_PRINT_ALL_BUT_BYTESEX



def create_outctx(*args) -> "outctx_base_t *":
    r"""


    Create a new output context. To delete it, just use "delete pctx"
    
    create_outctx(ea, F=0, suspop=0) -> outctx_base_t
        @param ea (C++: ea_t)
        @param F (C++: flags_t)
        @param suspop (C++: int)
    """
    return _ida_ua.create_outctx(*args)

def print_insn_mnem(*args) -> "qstring *":
    r"""


    Print instruction mnemonics.
    
    print_insn_mnem(ea) -> str
        @param ea: linear address of the instruction (C++: ea_t)
        @return: success
    """
    return _ida_ua.print_insn_mnem(*args)
FCBF_CONT = _ida_ua.FCBF_CONT
"""
don't stop on decoding, or any other kind of error
"""

FCBF_ERR_REPL = _ida_ua.FCBF_ERR_REPL
"""
of a hex representation of the problematic byte

in case of an error, use a CP_REPLCHAR instead
"""

FCBF_FF_LIT = _ida_ua.FCBF_FF_LIT
"""
in case of codepoints == 0xFF, use it as-is (i.e., LATIN SMALL LETTER
Y WITH DIAERESIS) If both this, and FCBF_REPL are specified, this will
take precedence
"""

FCBF_DELIM = _ida_ua.FCBF_DELIM
"""
add the 'ash'-specified delimiters around the generated data. Note: if
those are not defined and the INFFL_ALLASM is not set,
'format_charlit()' will return an error
"""


def get_dtype_flag(*args) -> "flags_t":
    r"""


    Get flags for 'op_t::dtype' field.
    
    get_dtype_flag(dtype) -> flags_t
        @param dtype (C++: op_dtype_t)
    """
    return _ida_ua.get_dtype_flag(*args)

def get_dtype_size(*args) -> "size_t":
    r"""


    Get size of opt_::dtype field.
    
    get_dtype_size(dtype) -> size_t
        @param dtype (C++: op_dtype_t)
    """
    return _ida_ua.get_dtype_size(*args)

def is_floating_dtype(*args) -> "bool":
    r"""


    Is a floating type operand?
    
    is_floating_dtype(dtype) -> bool
        @param dtype (C++: op_dtype_t)
    """
    return _ida_ua.is_floating_dtype(*args)

def create_insn(*args) -> "int":
    r"""


    Create an instruction at the specified address. This function checks
    if an instruction is present at the specified address and will try to
    create one if there is none. It will fail if there is a data item or
    other items hindering the creation of the new instruction. This
    function will also fill the 'out' structure.
    
    create_insn(ea, out=None) -> int
        @param ea: linear address (C++: ea_t)
        @param out: the resulting instruction (C++: insn_t  *)
        @return: the length of the instruction or 0
    """
    return _ida_ua.create_insn(*args)

def decode_insn(*args) -> "int":
    r"""


    Analyze the specified address and fill 'out'. This function does not
    modify the database. It just tries to interpret the specified address
    as an instruction and fills the 'out' structure.
    
    decode_insn(out, ea) -> int
        @param out: the resulting instruction (C++: insn_t  *)
        @param ea: linear address (C++: ea_t)
        @return: the length of the (possible) instruction or 0
    """
    return _ida_ua.decode_insn(*args)

def can_decode(*args) -> "bool":
    r"""


    Can the bytes at address 'ea' be decoded as instruction?
    
    can_decode(ea) -> bool
        @param ea: linear address (C++: ea_t)
        @return: whether or not the contents at that address could be a valid
                 instruction
    """
    return _ida_ua.can_decode(*args)

def print_operand(*args) -> "qstring *":
    r"""


    Generate text representation for operand #n. This function will
    generate the text representation of the specified operand (includes
    color codes.)
    
    print_operand(ea, n, getn_flags=0, newtype=None) -> str
        @param ea: the item address (instruction or data) (C++: ea_t)
        @param n: operand number (0,1,2...). meaningful only for instructions
                  (C++: int)
        @param getn_flags (C++: int)
        @param newtype: if specified, print the operand using the specified
                        type (C++: struct  printop_t  *)
        @return: success
    """
    return _ida_ua.print_operand(*args)

def decode_prev_insn(*args) -> "ea_t":
    r"""


    Decode previous instruction if it exists, fill 'out'.
    
    decode_prev_insn(out, ea) -> ea_t
        @param out: the resulting instruction (C++: insn_t  *)
        @param ea: the address to decode the previous instruction from (C++:
                   ea_t)
        @return: the previous instruction address ( BADADDR -no such insn)
    """
    return _ida_ua.decode_prev_insn(*args)
class macro_constructor_t(object):
    r"""
    Proxy of C++ macro_constructor_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    reserved = property(_ida_ua.macro_constructor_t_reserved_get, _ida_ua.macro_constructor_t_reserved_set)
    __swig_destroy__ = _ida_ua.delete_macro_constructor_t

    def build_macro(self, *args) -> "bool":
        r"""


        Try to extend the instruction.
        
        build_macro(self, insn, may_go_forward) -> bool
            @param insn: Instruction to modify, usually the first instruction of
                         the macro (C++: insn_t  *)
            @param may_go_forward: Is it ok to consider the next instruction for
                                   the macro? This argument may be false, for
                                   example, if there is a cross reference to the
                                   end of INSN. In this case creating a macro is
                                   not desired. However, it may still be useful to
                                   perform minor tweaks to the instruction using
                                   the information about the surrounding
                                   instructions. (C++: bool)
            @return: true if created an macro instruction. This function may
                     modify 'insn' and return false; these changes will be
                     accepted by the kernel but the instruction will not be
                     considered as a macro.
        """
        return _ida_ua.macro_constructor_t_build_macro(self, *args)

    def __init__(self, *args):
        r"""


        __init__(self) -> macro_constructor_t
            self: PyObject *
        """
        if self.__class__ == macro_constructor_t:
            _self = None
        else:
            _self = self
        _ida_ua.macro_constructor_t_swiginit(self, _ida_ua.new_macro_constructor_t(_self, *args))
    def __disown__(self):
        self.this.disown()
        _ida_ua.disown_macro_constructor_t(self)
        return weakref.proxy(self)

# Register macro_constructor_t in _ida_ua:
_ida_ua.macro_constructor_t_swigregister(macro_constructor_t)


def construct_macro2(*args) -> "bool":
    r"""


    construct_macro2(_this, insn, enable) -> bool
        @param _this (C++: macro_constructor_t  *)
        @param insn (C++: insn_t  *)
        @param enable (C++: bool)
    """
    return _ida_ua.construct_macro2(*args)

def guess_table_address(*args) -> "ea_t":
    r"""


    Guess the jump table address (ibm pc specific)
    
    guess_table_address(insn) -> ea_t
        @param insn  - an ida_ua.insn_t, or an address (C++: const insn_t &)
    """
    return _ida_ua.guess_table_address(*args)

def guess_table_size(*args) -> "asize_t":
    r"""


    Guess the jump table size.
    
    guess_table_size(insn, jump_table) -> asize_t
        @param insn  - an ida_ua.insn_t, or an address (C++: const insn_t &)
        @param jump_table (C++: ea_t)
    """
    return _ida_ua.guess_table_size(*args)

def decode_preceding_insn(*args) -> "PyObject *":
    r"""


    decode_preceding_insn(out, ea) -> PyObject *
    Decodes the preceding instruction. Please check ua.hpp / decode_preceding_insn()
    @param ea: current ea
    @param out: instruction storage
    @return: tuple(preceeding_ea or BADADDR, farref = Boolean)
    """
    return _ida_ua.decode_preceding_insn(*args)

def construct_macro(*args) -> "bool":
    r"""


    construct_macro(insn, enable, build_macro) -> bool
    See ua.hpp's construct_macro().
    """
    return _ida_ua.construct_macro(*args)

def get_dtype_by_size(*args) -> "int":
    r"""


    Get 'op_t::dtype' from size.
    
    get_dtype_by_size(size) -> int
        @param size (C++: asize_t)
    """
    return _ida_ua.get_dtype_by_size(*args)

def get_immvals(*args) -> "PyObject *":
    r"""


    Get immediate values at the specified address. This function decodes
    instruction at the specified address or inspects the data item. It
    finds immediate values and copies them to 'out'. This function will
    store the original value of the operands in 'out', unless the last
    bits of 'F' are "...0 11111111", in which case the transformed values
    (as needed for printing) will be stored instead.
    
    get_immvals(ea, n, F=0) -> PyObject *
        @param ea: address to analyze (C++: ea_t)
        @param n: number of operand (0.. UA_MAXOP -1), -1 means all operands
                  (C++: int)
        @param F: flags for the specified address (C++: flags_t)
        @return: number of immediate values (0..2* UA_MAXOP )
    """
    return _ida_ua.get_immvals(*args)

def get_printable_immvals(*args) -> "PyObject *":
    r"""


    Get immediate ready-to-print values at the specified address
    
    get_printable_immvals(ea, n, F=0) -> PyObject *
        @param ea: address to analyze (C++: ea_t)
        @param n: number of operand (0.. UA_MAXOP -1), -1 means all operands
                  (C++: int)
        @param F: flags for the specified address (C++: flags_t)
        @return: number of immediate values (0..2* UA_MAXOP )
    """
    return _ida_ua.get_printable_immvals(*args)

def insn_t__from_ptrval__(*args) -> "insn_t *":
    r"""


    insn_t__from_ptrval__(ptrval) -> insn_t
        ptrval: size_t
    """
    return _ida_ua.insn_t__from_ptrval__(*args)

def op_t__from_ptrval__(*args) -> "op_t *":
    r"""


    op_t__from_ptrval__(ptrval) -> op_t
        ptrval: size_t
    """
    return _ida_ua.op_t__from_ptrval__(*args)

def outctx_base_t__from_ptrval__(*args) -> "outctx_base_t *":
    r"""


    outctx_base_t__from_ptrval__(ptrval) -> outctx_base_t
        ptrval: size_t
    """
    return _ida_ua.outctx_base_t__from_ptrval__(*args)

def outctx_t__from_ptrval__(*args) -> "outctx_t *":
    r"""


    outctx_t__from_ptrval__(ptrval) -> outctx_t
        ptrval: size_t
    """
    return _ida_ua.outctx_t__from_ptrval__(*args)

#<pycode(py_ua)>
ua_mnem = print_insn_mnem
#</pycode(py_ua)>


if _BC695:
    import ida_idaapi
    def codeSeg(ea, opnum):
        insn = insn_t()
        if decode_insn(insn, ea):
            return _ida_ua.map_code_ea(insn, insn.ops[opnum])
        else:
            return ida_idaapi.BADADDR
    get_dtyp_by_size=get_dtype_by_size
    get_dtyp_flag=get_dtype_flag
    get_dtyp_size=get_dtype_size
    get_operand_immvals=get_immvals
    op_t.dtyp = op_t.dtype
    cmd = insn_t()
    @bc695redef
    def decode_insn(*args):
        if len(args) == 1:
            tmp = insn_t()
            rc = _ida_ua.decode_insn(tmp, args[0])
            cmd.assign(tmp)
            return rc
        else:
            return _ida_ua.decode_insn(*args)
    @bc695redef
    def create_insn(*args):
        if len(args) == 1:
            tmp = insn_t()
            rc = _ida_ua.create_insn(args[0], tmp)
            cmd.assign(tmp)
            return rc
        else:
            return _ida_ua.create_insn(*args)
    @bc695redef
    def decode_prev_insn(*args):
        if len(args) == 1:
            tmp = insn_t()
            rc = _ida_ua.decode_prev_insn(tmp, args[0])
            cmd.assign(tmp)
            return rc
        else:
            return _ida_ua.decode_prev_insn(*args)
    @bc695redef
    def decode_preceding_insn(*args):
        if len(args) == 1:
            tmp = insn_t()
            rc = _ida_ua.decode_preceding_insn(tmp, args[0])
            cmd.assign(tmp)
            return rc
        else:
            return _ida_ua.decode_preceding_insn(*args)
    import ida_ida
    UA_MAXOP=ida_ida.UA_MAXOP
    dt_3byte=dt_byte
    tbo_123=0
    tbo_132=0
    tbo_213=0
    tbo_231=0
    tbo_312=0
    tbo_321=0
    def ua_add_cref(opoff, to, rtype):
        return cmd.add_cref(to, opoff, rtype)
    def ua_add_dref(opoff, to, rtype):
        return cmd.add_dref(to, opoff, rtype)
    def ua_add_off_drefs(x, rtype):
        return cmd.add_off_drefs(x, rtype, 0)
    def ua_add_off_drefs2(x, rtype, outf):
        return cmd.add_off_drefs(x, rtype, outf)
    def ua_dodata(ea, dtype):
        return cmd.create_op_data(ea, 0, dtype)
    def ua_dodata2(opoff, ea, dtype):
        return cmd.create_op_data(ea, opoff, dtype)
    def ua_stkvar2(x, v, flags):
        return cmd.create_stkvar(x, v, flags)



