# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.1
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

"""
IDA Plugin SDK API wrapper: segment
"""

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _ida_segment
else:
    import _ida_segment

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """
    Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass
    """
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """
    Meta class to enforce nondynamic attributes (no new attributes) for a class
    """
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import weakref

SWIG_PYTHON_LEGACY_BOOL = _ida_segment.SWIG_PYTHON_LEGACY_BOOL

import ida_idaapi


import sys
_BC695 = sys.modules["__main__"].IDAPYTHON_COMPAT_695_API

if _BC695:






    def bc695redef(func):
        ida_idaapi._BC695.replace_fun(func)
        return func

import ida_range
SREG_NUM = _ida_segment.SREG_NUM
"""
Maximum number of segment registers is 16 (see 'segregs.hpp' )
"""

class segment_t(ida_range.range_t):
    r"""
    Proxy of C++ segment_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = property(_ida_segment.segment_t_name_get, _ida_segment.segment_t_name_set)
    sclass = property(_ida_segment.segment_t_sclass_get, _ida_segment.segment_t_sclass_set)
    orgbase = property(_ida_segment.segment_t_orgbase_get, _ida_segment.segment_t_orgbase_set)
    align = property(_ida_segment.segment_t_align_get, _ida_segment.segment_t_align_set)
    comb = property(_ida_segment.segment_t_comb_get, _ida_segment.segment_t_comb_set)
    perm = property(_ida_segment.segment_t_perm_get, _ida_segment.segment_t_perm_set)
    bitness = property(_ida_segment.segment_t_bitness_get, _ida_segment.segment_t_bitness_set)

    def use32(self, *args) -> "bool":
        r"""


        Use 32 bit segment addressing?
        """
        return _ida_segment.segment_t_use32(self, *args)

    def use64(self, *args) -> "bool":
        r"""


        Use 64 bit segment addressing?
        """
        return _ida_segment.segment_t_use64(self, *args)

    def abits(self, *args) -> "int":
        r"""


        Get number of address bits.
        """
        return _ida_segment.segment_t_abits(self, *args)

    def abytes(self, *args) -> "int":
        r"""


        Get number of address bytes.
        """
        return _ida_segment.segment_t_abytes(self, *args)
    flags = property(_ida_segment.segment_t_flags_get, _ida_segment.segment_t_flags_set)

    def comorg(self, *args) -> "bool":
        r"""
        comorg(self) -> bool
        """
        return _ida_segment.segment_t_comorg(self, *args)

    def set_comorg(self, *args) -> "void":
        r"""
        set_comorg(self)
        """
        return _ida_segment.segment_t_set_comorg(self, *args)

    def clr_comorg(self, *args) -> "void":
        r"""
        clr_comorg(self)
        """
        return _ida_segment.segment_t_clr_comorg(self, *args)

    def ob_ok(self, *args) -> "bool":
        r"""
        ob_ok(self) -> bool
        """
        return _ida_segment.segment_t_ob_ok(self, *args)

    def set_ob_ok(self, *args) -> "void":
        r"""
        set_ob_ok(self)
        """
        return _ida_segment.segment_t_set_ob_ok(self, *args)

    def clr_ob_ok(self, *args) -> "void":
        r"""
        clr_ob_ok(self)
        """
        return _ida_segment.segment_t_clr_ob_ok(self, *args)

    def is_visible_segm(self, *args) -> "bool":
        r"""
        is_visible_segm(self) -> bool
        """
        return _ida_segment.segment_t_is_visible_segm(self, *args)

    def set_visible_segm(self, *args) -> "void":
        r"""


        set_visible_segm(self, visible)
            visible: bool
        """
        return _ida_segment.segment_t_set_visible_segm(self, *args)

    def set_debugger_segm(self, *args) -> "void":
        r"""


        set_debugger_segm(self, debseg)
            debseg: bool
        """
        return _ida_segment.segment_t_set_debugger_segm(self, *args)

    def is_loader_segm(self, *args) -> "bool":
        r"""
        is_loader_segm(self) -> bool
        """
        return _ida_segment.segment_t_is_loader_segm(self, *args)

    def set_loader_segm(self, *args) -> "void":
        r"""


        set_loader_segm(self, ldrseg)
            ldrseg: bool
        """
        return _ida_segment.segment_t_set_loader_segm(self, *args)

    def is_hidden_segtype(self, *args) -> "bool":
        r"""
        is_hidden_segtype(self) -> bool
        """
        return _ida_segment.segment_t_is_hidden_segtype(self, *args)

    def set_hidden_segtype(self, *args) -> "void":
        r"""


        set_hidden_segtype(self, hide)
            hide: bool
        """
        return _ida_segment.segment_t_set_hidden_segtype(self, *args)

    def is_header_segm(self, *args) -> "bool":
        r"""
        is_header_segm(self) -> bool
        """
        return _ida_segment.segment_t_is_header_segm(self, *args)

    def set_header_segm(self, *args) -> "void":
        r"""


        set_header_segm(self, on)
            on: bool
        """
        return _ida_segment.segment_t_set_header_segm(self, *args)
    sel = property(_ida_segment.segment_t_sel_get, _ida_segment.segment_t_sel_set)
    defsr = property(_ida_segment.segment_t_defsr_get, _ida_segment.segment_t_defsr_set)
    type = property(_ida_segment.segment_t_type_get, _ida_segment.segment_t_type_set)
    color = property(_ida_segment.segment_t_color_get, _ida_segment.segment_t_color_set)

    def update(self, *args) -> "bool":
        r"""


        Update segment information. You must call this function after
        modification of segment characteristics. Note that not all fields of
        segment structure may be modified directly, there are special
        functions to modify some fields.
        """
        return _ida_segment.segment_t_update(self, *args)

    def __init__(self, *args):
        r"""
        __init__(self) -> segment_t
        """
        _ida_segment.segment_t_swiginit(self, _ida_segment.new_segment_t(*args))
    start_ea = property(_ida_segment.segment_t_start_ea_get, _ida_segment.segment_t_start_ea_set)
    end_ea = property(_ida_segment.segment_t_end_ea_get, _ida_segment.segment_t_end_ea_set)
    __swig_destroy__ = _ida_segment.delete_segment_t

# Register segment_t in _ida_segment:
_ida_segment.segment_t_swigregister(segment_t)
saAbs = _ida_segment.saAbs
"""
Absolute segment.
"""

saRelByte = _ida_segment.saRelByte
"""
Relocatable, byte aligned.
"""

saRelWord = _ida_segment.saRelWord
"""
Relocatable, word (2-byte) aligned.
"""

saRelPara = _ida_segment.saRelPara
"""
Relocatable, paragraph (16-byte) aligned.
"""

saRelPage = _ida_segment.saRelPage
"""
Relocatable, aligned on 256-byte boundary.
"""

saRelDble = _ida_segment.saRelDble
"""
boundary.

Relocatable, aligned on a double word (4-byte)
"""

saRel4K = _ida_segment.saRel4K
"""
alignment. It is not supported by LINK.

This value is used by the PharLap OMF for page (4K)
"""

saGroup = _ida_segment.saGroup
"""
Segment group.
"""

saRel32Bytes = _ida_segment.saRel32Bytes
"""
32 bytes
"""

saRel64Bytes = _ida_segment.saRel64Bytes
"""
64 bytes
"""

saRelQword = _ida_segment.saRelQword
"""
8 bytes
"""

saRel128Bytes = _ida_segment.saRel128Bytes
"""
128 bytes
"""

saRel512Bytes = _ida_segment.saRel512Bytes
"""
512 bytes
"""

saRel1024Bytes = _ida_segment.saRel1024Bytes
"""
1024 bytes
"""

saRel2048Bytes = _ida_segment.saRel2048Bytes
"""
2048 bytes
"""

saRel_MAX_ALIGN_CODE = _ida_segment.saRel_MAX_ALIGN_CODE

scPriv = _ida_segment.scPriv
"""
segment.

Private. Do not combine with any other program
"""

scGroup = _ida_segment.scGroup
"""
Segment group.
"""

scPub = _ida_segment.scPub
"""
the alignment requirement.

Public. Combine by appending at an offset that meets
"""

scPub2 = _ida_segment.scPub2
"""
As defined by Microsoft, same as C=2 (public).
"""

scStack = _ida_segment.scStack
"""
byte alignment.

Stack. Combine as for C=2. This combine type forces
"""

scCommon = _ida_segment.scCommon
"""
Common. Combine by overlay using maximum size.
"""

scPub3 = _ida_segment.scPub3
"""
As defined by Microsoft, same as C=2 (public).
"""

sc_MAX_COMB_CODE = _ida_segment.sc_MAX_COMB_CODE

SEGPERM_EXEC = _ida_segment.SEGPERM_EXEC
"""
Execute.
"""

SEGPERM_WRITE = _ida_segment.SEGPERM_WRITE
"""
Write.
"""

SEGPERM_READ = _ida_segment.SEGPERM_READ
"""
Read.
"""

SEGPERM_MAXVAL = _ida_segment.SEGPERM_MAXVAL

SEG_MAX_BITNESS_CODE = _ida_segment.SEG_MAX_BITNESS_CODE

SFL_COMORG = _ida_segment.SFL_COMORG
"""
IDP dependent field (IBM PC: if set, ORG directive is not commented
out)
"""

SFL_OBOK = _ida_segment.SFL_OBOK
"""
Orgbase is present? (IDP dependent field)
"""

SFL_HIDDEN = _ida_segment.SFL_HIDDEN
"""
Is the segment hidden?
"""

SFL_DEBUG = _ida_segment.SFL_DEBUG
"""
Is the segment created for the debugger?. Such segments are temporary
and do not have permanent flags.
"""

SFL_LOADER = _ida_segment.SFL_LOADER
"""
Is the segment created by the loader?
"""

SFL_HIDETYPE = _ida_segment.SFL_HIDETYPE
"""
Hide segment type (do not print it in the listing)
"""

SFL_HEADER = _ida_segment.SFL_HEADER
"""
Header segment (do not create offsets to it in the disassembly)
"""

SEG_NORM = _ida_segment.SEG_NORM
"""
unknown type, no assumptions
"""

SEG_XTRN = _ida_segment.SEG_XTRN
"""
no instructions are allowed

segment with 'extern' definitions.
"""

SEG_CODE = _ida_segment.SEG_CODE
"""
code segment
"""

SEG_DATA = _ida_segment.SEG_DATA
"""
data segment
"""

SEG_IMP = _ida_segment.SEG_IMP
"""
java: implementation segment
"""

SEG_GRP = _ida_segment.SEG_GRP
"""
group of segments
"""

SEG_NULL = _ida_segment.SEG_NULL
"""
zero-length segment
"""

SEG_UNDF = _ida_segment.SEG_UNDF
"""
undefined segment type (not used)
"""

SEG_BSS = _ida_segment.SEG_BSS
"""
uninitialized segment
"""

SEG_ABSSYM = _ida_segment.SEG_ABSSYM
"""
segment with definitions of absolute symbols
"""

SEG_COMM = _ida_segment.SEG_COMM
"""
segment with communal definitions
"""

SEG_IMEM = _ida_segment.SEG_IMEM
"""
internal processor memory & sfr (8051)
"""

SEG_MAX_SEGTYPE_CODE = _ida_segment.SEG_MAX_SEGTYPE_CODE



def is_visible_segm(*args) -> "bool":
    r"""


    See 'SFL_HIDDEN' .
    
    is_visible_segm(s) -> bool
        @param s (C++: segment_t  *)
    """
    return _ida_segment.is_visible_segm(*args)

def is_finally_visible_segm(*args) -> "bool":
    r"""


    See 'SFL_HIDDEN' , 'SCF_SHHID_SEGM' .
    
    is_finally_visible_segm(s) -> bool
        @param s (C++: segment_t  *)
    """
    return _ida_segment.is_finally_visible_segm(*args)

def set_visible_segm(*args) -> "void":
    r"""


    See 'SFL_HIDDEN' .
    
    set_visible_segm(s, visible)
        @param s (C++: segment_t  *)
        @param visible (C++: bool)
    """
    return _ida_segment.set_visible_segm(*args)

def is_spec_segm(*args) -> "bool":
    r"""


    Has segment a special type?. ( 'SEG_XTRN' , 'SEG_GRP' , 'SEG_ABSSYM' ,
    'SEG_COMM' )
    
    is_spec_segm(seg_type) -> bool
        @param seg_type (C++: uchar)
    """
    return _ida_segment.is_spec_segm(*args)

def is_spec_ea(*args) -> "bool":
    r"""


    Does the address belong to a segment with a special type?. (
    'SEG_XTRN' , 'SEG_GRP' , 'SEG_ABSSYM' , 'SEG_COMM' )
    
    is_spec_ea(ea) -> bool
        @param ea: linear address (C++: ea_t)
    """
    return _ida_segment.is_spec_ea(*args)

def lock_segm(*args) -> "void":
    r"""


    Lock segment pointer Locked pointers are guaranteed to remain valid
    until they are unlocked. Ranges with locked pointers cannot be deleted
    or moved.
    
    lock_segm(segm, lock)
        @param segm (C++: const  segment_t  *)
        @param lock (C++: bool)
    """
    return _ida_segment.lock_segm(*args)
class lock_segment(object):
    r"""
    Proxy of C++ lock_segment class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        __init__(self, _segm) -> lock_segment
            _segm: segment_t const *
        """
        _ida_segment.lock_segment_swiginit(self, _ida_segment.new_lock_segment(*args))
    __swig_destroy__ = _ida_segment.delete_lock_segment

# Register lock_segment in _ida_segment:
_ida_segment.lock_segment_swigregister(lock_segment)


def is_segm_locked(*args) -> "bool":
    r"""


    Is a segment pointer locked?
    
    is_segm_locked(segm) -> bool
        @param segm (C++: const  segment_t  *)
    """
    return _ida_segment.is_segm_locked(*args)

def getn_selector(*args) -> "sel_t *, ea_t *":
    r"""


    Get description of selector (0.. 'get_selector_qty()' -1)
    
    getn_selector(n) -> bool
        @param n (C++: int)
    """
    return _ida_segment.getn_selector(*args)

def get_selector_qty(*args) -> "size_t":
    r"""


    Get number of defined selectors.
    """
    return _ida_segment.get_selector_qty(*args)

def setup_selector(*args) -> "sel_t":
    r"""


    Allocate a selector for a segment if necessary. You must call this
    function before calling 'add_segm_ex()' . 'add_segm()' calls this
    function itself, so you don't need to allocate a selector. This
    function will allocate a selector if 'segbase' requires more than 16
    bits and the current processor is IBM PC. Otherwise it will return the
    segbase value.
    
    setup_selector(segbase) -> sel_t
        @param segbase: a new segment base paragraph (C++: ea_t)
        @return: the allocated selector number
    """
    return _ida_segment.setup_selector(*args)

def allocate_selector(*args) -> "sel_t":
    r"""


    Allocate a selector for a segment unconditionally. You must call this
    function before calling 'add_segm_ex()' . 'add_segm()' calls this
    function itself, so you don't need to allocate a selector. This
    function will allocate a new free selector and setup its mapping using
    'find_free_selector()' and 'set_selector()' functions.
    
    allocate_selector(segbase) -> sel_t
        @param segbase: a new segment base paragraph (C++: ea_t)
        @return: the allocated selector number
    """
    return _ida_segment.allocate_selector(*args)

def find_free_selector(*args) -> "sel_t":
    r"""


    Find first unused selector.
    """
    return _ida_segment.find_free_selector(*args)

def set_selector(*args) -> "int":
    r"""


    Set mapping of selector to a paragraph. You should call this
    functionbeforecreating a segment which uses the selector, otherwise
    the creation of the segment will fail.
    
    set_selector(selector, paragraph) -> int
        @param selector: number of selector to map   if selector ==  BADSEL ,
                         then return 0 (fail)   if the selector has had a
                         mapping, old mapping is destroyed   if the selector
                         number is equal to paragraph value, then the mapping
                         is destroyed because we don't need to keep trivial
                         mappings. (C++: sel_t)
        @param paragraph: paragraph to map selector (C++: ea_t)
        @retval: 1 - ok
        @retval: 0 - failure (bad selector or too many mappings)
    """
    return _ida_segment.set_selector(*args)

def del_selector(*args) -> "void":
    r"""


    Delete mapping of a selector. Be wary of deleting selectors that are
    being used in the program, this can make a mess in the segments.
    
    del_selector(selector)
        @param selector: number of selector to remove from the translation
                         table (C++: sel_t)
    """
    return _ida_segment.del_selector(*args)

def sel2para(*args) -> "ea_t":
    r"""


    Get mapping of a selector.
    
    sel2para(selector) -> ea_t
        @param selector: number of selector to translate (C++: sel_t)
        @return: paragraph the specified selector is mapped to. if there is no
                 mapping, returns 'selector'.
    """
    return _ida_segment.sel2para(*args)

def sel2ea(*args) -> "ea_t":
    r"""


    Get mapping of a selector as a linear address.
    
    sel2ea(selector) -> ea_t
        @param selector: number of selector to translate to linear address
                         (C++: sel_t)
        @return: linear address the specified selector is mapped to. if there
                 is no mapping, returns to_ea(selector,0);
    """
    return _ida_segment.sel2ea(*args)

def find_selector(*args) -> "sel_t":
    r"""


    Find a selector that has mapping to the specified paragraph.
    
    find_selector(base) -> sel_t
        @param base: paragraph to search in the translation table (C++: ea_t)
        @return: selector value or base
    """
    return _ida_segment.find_selector(*args)

def get_segm_by_sel(*args) -> "segment_t *":
    r"""


    Get pointer to segment structure. This function finds a segment by its
    selector. If there are several segments with the same selectors, the
    last one will be returned.
    
    get_segm_by_sel(selector) -> segment_t
        @param selector: a segment with the specified selector will be
                         returned (C++: sel_t)
        @return: pointer to segment or NULL
    """
    return _ida_segment.get_segm_by_sel(*args)

def add_segm_ex(*args) -> "bool":
    r"""


    Add a new segment. If a segment already exists at the specified range
    of addresses, this segment will be truncated. Instructions and data in
    the old segment will be deleted if the new segment has another
    addressing mode or another segment base address.
    
    add_segm_ex(s, name, sclass, flags) -> bool
        @param s: pointer to filled segment structure. segment
                          selector should have proper mapping (see
                          set_selector() ).   if s.start_ea== BADADDR  then
                          s.start_ea <- get_segm_base(&s)   if s.end_ea==
                          BADADDR , then a segment up to the next segment will
                          be created (if the next segment doesn't exist, then
                          1 byte segment will be created).   if the s.end_ea <
                          s.start_ea, then fail.   if s.end_ea is too high and
                          the new segment would overlap the next segment,
                          s.end_ea is adjusted properly. (C++: segment_t  *)
        @param name: name of new segment. may be NULL. if specified, the
                     segment is immediately renamed (C++: const char *)
        @param sclass: class of the segment. may be NULL. if specified, the
                       segment class is immediately changed (C++: const char
                       *)
        @param flags: Add segment flags (C++: int)
        @retval: 1 - ok
        @retval: 0 - failed, a warning message is displayed
    """
    return _ida_segment.add_segm_ex(*args)
ADDSEG_NOSREG = _ida_segment.ADDSEG_NOSREG
"""
(undefine all default segment registers)

set all default segment register values to 'BADSEL'
"""

ADDSEG_OR_DIE = _ida_segment.ADDSEG_OR_DIE
"""
'qexit()' if can't add a segment
"""

ADDSEG_NOTRUNC = _ida_segment.ADDSEG_NOTRUNC
"""
destroy/truncate old segments instead.

don't truncate the new segment at the beginning of the next segment if
they overlap.
"""

ADDSEG_QUIET = _ida_segment.ADDSEG_QUIET
"""
silent mode, no "Adding segment..." in the messages window
"""

ADDSEG_FILLGAP = _ida_segment.ADDSEG_FILLGAP
"""
fill gap between new segment and previous one. i.e. if such a gap
exists, and this gap is less than 64K, then fill the gap by extending
the previous segment and adding .align directive to it. This way we
avoid gaps between segments. too many gaps lead to a virtual array
failure. it cannot hold more than ~1000 gaps.
"""

ADDSEG_SPARSE = _ida_segment.ADDSEG_SPARSE
"""
use sparse storage method for the new segment
"""

ADDSEG_NOAA = _ida_segment.ADDSEG_NOAA
"""
do not mark new segment for auto-analysis
"""

ADDSEG_IDBENC = _ida_segment.ADDSEG_IDBENC
"""
non-ASCII bytes will be decoded accordingly

'name' and 'sclass' are given in the IDB encoding;
"""


def add_segm(*args) -> "bool":
    r"""


    Add a new segment, second form. Segment alignment is set to
    'saRelByte' . Segment combination is "public" or "stack" (if segment
    class is "STACK"). Addressing mode of segment is taken as default
    (16bit or 32bit). Default segment registers are set to 'BADSEL' . If a
    segment already exists at the specified range of addresses, this
    segment will be truncated. Instructions and data in the old segment
    will be deleted if the new segment has another addressing mode or
    another segment base address.
    
    add_segm(para, start, end, name, sclass, flags=0) -> bool
        @param para: segment base paragraph. if paragraph can't fit in 16bit,
                     then a new selector is allocated and mapped to the
                     paragraph. (C++: ea_t)
        @param start: start address of the segment. if start== BADADDR  then
                      start <- to_ea(para,0). (C++: ea_t)
        @param end: end address of the segment. end address should be higher
                    than start address. For emulate empty segments, use
                    SEG_NULL  segment type. If the end address is lower than
                    start address, then fail. If end== BADADDR , then a
                    segment up to the next segment will be created (if the
                    next segment doesn't exist, then 1 byte segment will be
                    created). If 'end' is too high and the new segment would
                    overlap the next segment, 'end' is adjusted properly.
                    (C++: ea_t)
        @param name: name of new segment. may be NULL (C++: const char *)
        @param sclass: class of the segment. may be NULL. type of the new
                       segment is modified if class is one of predefined
                       names:   "CODE" ->  SEG_CODE   "DATA" ->  SEG_DATA
                       "CONST" ->  SEG_DATA   "STACK" ->  SEG_BSS   "BSS" ->
                       SEG_BSS   "XTRN" ->  SEG_XTRN   "COMM" ->  SEG_COMM
                       "ABS" ->  SEG_ABSSYM (C++: const char *)
        @param flags (C++: int)
        @retval: 1 - ok
        @retval: 0 - failed, a warning message is displayed
    """
    return _ida_segment.add_segm(*args)

def del_segm(*args) -> "bool":
    r"""


    Delete a segment.
    
    del_segm(ea, flags) -> bool
        @param ea: any address belonging to the segment (C++: ea_t)
        @param flags: Segment modification flags (C++: int)
        @retval: 1 - ok
        @retval: 0 - failed, no segment at 'ea'.
    """
    return _ida_segment.del_segm(*args)
SEGMOD_KILL = _ida_segment.SEGMOD_KILL
"""
disable addresses if segment gets shrinked or deleted
"""

SEGMOD_KEEP = _ida_segment.SEGMOD_KEEP
"""
keep information (code & data, etc)
"""

SEGMOD_SILENT = _ida_segment.SEGMOD_SILENT
"""
be silent
"""

SEGMOD_KEEP0 = _ida_segment.SEGMOD_KEEP0
"""
flag for internal use, don't set
"""

SEGMOD_KEEPSEL = _ida_segment.SEGMOD_KEEPSEL
"""
do not try to delete unused selector
"""

SEGMOD_NOMOVE = _ida_segment.SEGMOD_NOMOVE
"""
(for 'set_segm_start()' )

don't move info from the start of segment to the new start address
"""

SEGMOD_SPARSE = _ida_segment.SEGMOD_SPARSE
"""
(for 'set_segm_start()' , 'set_segm_end()' )

use sparse storage if extending the segment
"""


def get_segm_qty(*args) -> "int":
    r"""


    Get number of segments.
    """
    return _ida_segment.get_segm_qty(*args)

def getseg(*args) -> "segment_t *":
    r"""


    Get pointer to segment by linear address.
    
    getseg(ea) -> segment_t
        @param ea: linear address belonging to the segment (C++: ea_t)
        @return: NULL or pointer to segment structure
    """
    return _ida_segment.getseg(*args)

def getnseg(*args) -> "segment_t *":
    r"""


    Get pointer to segment by its number.Obsoleted because it can slow
    down the debugger (it has to refresh the whole memory segmentation to
    calculate the correct answer)
    
    getnseg(n) -> segment_t
        @param n: segment number in the range (0.. get_segm_qty() -1) (C++:
                  int)
        @return: NULL or pointer to segment structure
    """
    return _ida_segment.getnseg(*args)

def get_segm_num(*args) -> "int":
    r"""


    Get number of segment by address.
    
    get_segm_num(ea) -> int
        @param ea: linear address belonging to the segment (C++: ea_t)
        @return: -1 if no segment occupies the specified address. otherwise
                 returns number of the specified segment (0.. get_segm_qty()
                 -1)
    """
    return _ida_segment.get_segm_num(*args)

def get_next_seg(*args) -> "segment_t *":
    r"""


    Get pointer to the next segment.
    
    get_next_seg(ea) -> segment_t
        @param ea (C++: ea_t)
    """
    return _ida_segment.get_next_seg(*args)

def get_prev_seg(*args) -> "segment_t *":
    r"""


    Get pointer to the previous segment.
    
    get_prev_seg(ea) -> segment_t
        @param ea (C++: ea_t)
    """
    return _ida_segment.get_prev_seg(*args)

def get_first_seg(*args) -> "segment_t *":
    r"""


    Get pointer to the first segment.
    """
    return _ida_segment.get_first_seg(*args)

def get_last_seg(*args) -> "segment_t *":
    r"""


    Get pointer to the last segment.
    """
    return _ida_segment.get_last_seg(*args)

def get_segm_by_name(*args) -> "segment_t *":
    r"""


    Get pointer to segment by its name. If there are several segments with
    the same name, returns the first of them.
    
    get_segm_by_name(name) -> segment_t
        @param name: segment name. may be NULL. (C++: const char *)
        @return: NULL or pointer to segment structure
    """
    return _ida_segment.get_segm_by_name(*args)

def set_segm_end(*args) -> "bool":
    r"""


    Set segment end address. The next segment is shrinked to allow
    expansion of the specified segment. The kernel might even delete the
    next segment if necessary. The kernel will ask the user for a
    permission to destroy instructions or data going out of segment scope
    if such instructions exist.
    
    set_segm_end(ea, newend, flags) -> bool
        @param ea: any address belonging to the segment (C++: ea_t)
        @param newend: new end address of the segment (C++: ea_t)
        @param flags: Segment modification flags (C++: int)
        @retval: 1 - ok
        @retval: 0 - failed, a warning message is displayed
    """
    return _ida_segment.set_segm_end(*args)

def set_segm_start(*args) -> "bool":
    r"""


    Set segment start address. The previous segment is trimmed to allow
    expansion of the specified segment. The kernel might even delete the
    previous segment if necessary. The kernel will ask the user for a
    permission to destroy instructions or data going out of segment scope
    if such instructions exist.
    
    set_segm_start(ea, newstart, flags) -> bool
        @param ea: any address belonging to the segment (C++: ea_t)
        @param newstart: new start address of the segment note that segment
                         start address should be higher than segment base
                         linear address. (C++: ea_t)
        @param flags: Segment modification flags (C++: int)
        @retval: 1 - ok
        @retval: 0 - failed, a warning message is displayed
    """
    return _ida_segment.set_segm_start(*args)

def move_segm_start(*args) -> "bool":
    r"""


    Move segment start. The main difference between this function and
    'set_segm_start()' is that this function may expand the previous
    segment while 'set_segm_start()' never does it. So, this function
    allows to change bounds of two segments simultaneously. If the
    previous segment and the specified segment have the same addressing
    mode and segment base, then instructions and data are not destroyed -
    they simply move from one segment to another. Otherwise all
    instructions/data which migrate from one segment to another are
    destroyed.this function never disables addresses.
    
    move_segm_start(ea, newstart, mode) -> bool
        @param ea: any address belonging to the segment (C++: ea_t)
        @param newstart: new start address of the segment note that segment
                         start address should be higher than segment base
                         linear address. (C++: ea_t)
        @param mode: policy for destroying defined items   0: if it is
                     necessary to destroy defined items, display a dialog box
                     and ask confirmation   1: if it is necessary to destroy
                     defined items, just destroy them without asking the user
                     -1: if it is necessary to destroy defined items, don't
                     destroy them (i.e. function will fail)   -2: don't
                     destroy defined items (function will succeed) (C++: int)
        @retval: 1 - ok
        @retval: 0 - failed, a warning message is displayed
    """
    return _ida_segment.move_segm_start(*args)

def move_segm(*args) -> "int":
    r"""


    Move a segment to a new address. This function moves all information
    to the new address. It fixes up address sensitive information in the
    kernel. The total effect is equal to reloading the segment to the
    target address. For the file format dependent address sensitive
    information, 'loader_t::move_segm' is called. Also IDB notification
    event 'idb_event::segm_moved' is called.
    
    move_segm(s, to, flags=0) -> int
        @param s: segment to move (C++: segment_t  *)
        @param to: new segment start address (C++: ea_t)
        @param flags: Move segment flags (C++: int)
        @return: Move segment result codes
    """
    return _ida_segment.move_segm(*args)
MSF_SILENT = _ida_segment.MSF_SILENT
"""
don't display a "please wait" box on the screen
"""

MSF_NOFIX = _ida_segment.MSF_NOFIX
"""
don't call the loader to fix relocations
"""

MSF_LDKEEP = _ida_segment.MSF_LDKEEP
"""
keep the loader in the memory (optimization)
"""

MSF_FIXONCE = _ida_segment.MSF_FIXONCE
"""
valid for 'rebase_program()' . see 'loader_t::move_segm' .

call loader only once with the special calling method.
"""

MSF_PRIORITY = _ida_segment.MSF_PRIORITY
"""
valid for 'move_segm()'

loader segments will overwrite any existing debugger segments when
moved.
"""

MSF_NETNODES = _ida_segment.MSF_NETNODES
"""
valid for 'rebase_program()'

move netnodes instead of changing inf.netdelta (this is slower)
"""

MOVE_SEGM_OK = _ida_segment.MOVE_SEGM_OK
"""
all ok
"""

MOVE_SEGM_PARAM = _ida_segment.MOVE_SEGM_PARAM
"""
The specified segment does not exist.
"""

MOVE_SEGM_ROOM = _ida_segment.MOVE_SEGM_ROOM
"""
Not enough free room at the target address.
"""

MOVE_SEGM_IDP = _ida_segment.MOVE_SEGM_IDP
"""
IDP module forbids moving the segment.
"""

MOVE_SEGM_CHUNK = _ida_segment.MOVE_SEGM_CHUNK
"""
Too many chunks are defined, can't move.
"""

MOVE_SEGM_LOADER = _ida_segment.MOVE_SEGM_LOADER
"""
The segment has been moved but the loader complained.
"""

MOVE_SEGM_ODD = _ida_segment.MOVE_SEGM_ODD
"""
Cannot move segments by an odd number of bytes.
"""

MOVE_SEGM_ORPHAN = _ida_segment.MOVE_SEGM_ORPHAN
"""
Orphan bytes hinder segment movement.
"""

MOVE_SEGM_DEBUG = _ida_segment.MOVE_SEGM_DEBUG
"""
Debugger segments cannot be moved.
"""


def change_segment_status(*args) -> "int":
    r"""


    Convert a debugger segment to a regular segment and vice versa. When
    converting debug->regular, the memory contents will be copied to the
    database.
    
    change_segment_status(s, is_deb_segm) -> int
        @param s: segment to modify (C++: segment_t  *)
        @param is_deb_segm: new status of the segment (C++: bool)
        @return: Change segment status result codes
    """
    return _ida_segment.change_segment_status(*args)
CSS_OK = _ida_segment.CSS_OK
"""
ok
"""

CSS_NODBG = _ida_segment.CSS_NODBG
"""
debugger is not running
"""

CSS_NORANGE = _ida_segment.CSS_NORANGE
"""
could not find corresponding memory range
"""

CSS_NOMEM = _ida_segment.CSS_NOMEM
"""
is too big)

not enough memory (might be because the segment
"""

CSS_BREAK = _ida_segment.CSS_BREAK
"""
memory reading process stopped by user
"""


def take_memory_snapshot(*args) -> "bool":
    r"""


    Take a memory snapshot of the running process.
    
    take_memory_snapshot(only_loader_segs) -> bool
        @param only_loader_segs: only is_loader_segm() segments will be
                                 affected (C++: bool)
        @return: success
    """
    return _ida_segment.take_memory_snapshot(*args)

def is_miniidb(*args) -> "bool":
    r"""


    Is the database a miniidb created by the debugger?.
    """
    return _ida_segment.is_miniidb(*args)

def set_segm_base(*args) -> "bool":
    r"""


    Internal function.
    
    set_segm_base(s, newbase) -> bool
        @param s (C++: segment_t  *)
        @param newbase (C++: ea_t)
    """
    return _ida_segment.set_segm_base(*args)

def set_group_selector(*args) -> "int":
    r"""


    Create a new group of segments (used OMF files).
    
    set_group_selector(grp, sel) -> int
        @param grp: selector of group segment (segment type is  SEG_GRP ) You
                    should create an 'empty' (1 byte) group segment It won't
                    contain anything and will be used to redirect references
                    to the group of segments to the common selector. (C++:
                    sel_t)
        @param sel: common selector of all segments belonging to the segment
                    You should create all segments within the group with the
                    same selector value. (C++: sel_t)
        @return: 1 ok
    """
    return _ida_segment.set_group_selector(*args)
MAX_GROUPS = _ida_segment.MAX_GROUPS
"""
max number of segment groups
"""


def get_group_selector(*args) -> "sel_t":
    r"""


    Get common selector for a group of segments.
    
    get_group_selector(grpsel) -> sel_t
        @param grpsel: selector of group segment (C++: sel_t)
        @return: common selector of the group or 'grpsel' if no such group is
                 found
    """
    return _ida_segment.get_group_selector(*args)

def add_segment_translation(*args) -> "bool":
    r"""


    Add segment translation.
    
    add_segment_translation(segstart, mappedseg) -> bool
        @param segstart: start address of the segment to add translation to
                         (C++: ea_t)
        @param mappedseg: start address of the overlayed segment (C++: ea_t)
        @retval: 1 - ok
        @retval: 0 - too many translations or bad segstart
    """
    return _ida_segment.add_segment_translation(*args)
MAX_SEGM_TRANSLATIONS = _ida_segment.MAX_SEGM_TRANSLATIONS
"""
max number of segment translations
"""


def set_segment_translations(*args) -> "bool":
    r"""


    Set new translation list.
    
    set_segment_translations(segstart, transmap) -> bool
        @param segstart: start address of the segment to add translation to
                         (C++: ea_t)
        @param transmap: vector of segment start addresses for the translation
                         list. If transmap is empty, the translation list is
                         deleted. (C++: const  eavec_t  &)
        @retval: 1 - ok
        @retval: 0 - too many translations or bad segstart
    """
    return _ida_segment.set_segment_translations(*args)

def del_segment_translations(*args) -> "void":
    r"""


    Delete the translation list
    
    del_segment_translations(segstart)
        @param segstart: start address of the segment to delete translation
                         list (C++: ea_t)
    """
    return _ida_segment.del_segment_translations(*args)

def get_segment_translations(*args) -> "ssize_t":
    r"""


    Get segment translation list.
    
    get_segment_translations(transmap, segstart) -> ssize_t
        @param transmap: vector of segment start addresses for the translation
                         list (C++: eavec_t  *)
        @param segstart: start address of the segment to get information about
                         (C++: ea_t)
        @return: -1 if no translation list or bad segstart. otherwise returns
                 size of translation list.
    """
    return _ida_segment.get_segment_translations(*args)

def get_segment_cmt(*args) -> "qstring *":
    r"""


    Get segment comment.
    
    get_segment_cmt(s, repeatable) -> str
        @param s: pointer to segment structure (C++: const  segment_t  *)
        @param repeatable: 0: get regular comment. 1: get repeatable comment.
                           (C++: bool)
        @return: size of comment or -1
    """
    return _ida_segment.get_segment_cmt(*args)

def set_segment_cmt(*args) -> "void":
    r"""


    Set segment comment.
    
    set_segment_cmt(s, cmt, repeatable)
        @param s: pointer to segment structure (C++: const  segment_t  *)
        @param cmt: comment string, may be multiline (with '  '). maximal size
                    is 4096 bytes. Use empty str ("") to delete comment (C++:
                    const char *)
        @param repeatable: 0: set regular comment. 1: set repeatable comment.
                           (C++: bool)
    """
    return _ida_segment.set_segment_cmt(*args)

def std_out_segm_footer(*args) -> "void":
    r"""


    Generate segment footer line as a comment line. This function may be
    used in IDP modules to generate segment footer if the target assembler
    doesn't have 'ends' directive.
    
    std_out_segm_footer(ctx, seg)
        @param ctx (C++: struct  outctx_t  &)
        @param seg (C++: segment_t  *)
    """
    return _ida_segment.std_out_segm_footer(*args)

def set_segm_name(*args) -> "int":
    r"""


    Rename segment. The new name is validated (see validate_name). A
    segment always has a name. If you hadn't specified a name, the kernel
    will assign it "seg###" name where ### is segment number.
    
    set_segm_name(s, name, flags=0) -> int
        @param s: pointer to segment (may be NULL) (C++: segment_t  *)
        @param name: new segment name (C++: const char *)
        @param flags: ADDSEG_IDBENC or 0 (C++: int)
        @retval: 1 - ok, name is good and segment is renamed
        @retval: 0 - failure, name is bad or segment is NULL
    """
    return _ida_segment.set_segm_name(*args)

def get_segm_name(*args) -> "qstring *":
    r"""


    Get true segment name by pointer to segment.
    
    get_segm_name(s, flags=0) -> str
        @param s: pointer to segment (C++: const  segment_t  *)
        @param flags: 0-return name as is; 1-substitute bad symbols with _ 1
                      corresponds to GN_VISIBLE (C++: int)
        @return: size of segment name (-1 if s==NULL)
    """
    return _ida_segment.get_segm_name(*args)

def get_visible_segm_name(*args) -> "qstring *":
    r"""


    Get segment name by pointer to segment.
    
    get_visible_segm_name(s) -> str
        @param s: pointer to segment (C++: const  segment_t  *)
        @return: size of segment name (-1 if s==NULL)
    """
    return _ida_segment.get_visible_segm_name(*args)

def get_segm_class(*args) -> "qstring *":
    r"""


    Get segment class. Segment class is arbitrary text (max 8 characters).
    
    get_segm_class(s) -> str
        @param s: pointer to segment (C++: const  segment_t  *)
        @return: size of segment class (-1 if s==NULL or bufsize<=0)
    """
    return _ida_segment.get_segm_class(*args)

def set_segm_class(*args) -> "int":
    r"""


    Set segment class.
    
    set_segm_class(s, sclass, flags=0) -> int
        @param s: pointer to segment (may be NULL) (C++: segment_t  *)
        @param sclass: segment class (may be NULL). If segment type is
                       SEG_NORM  and segment class is one of predefined names,
                       then segment type is changed to:   "CODE" ->  SEG_CODE
                       "DATA" ->  SEG_DATA   "STACK" ->  SEG_BSS   "BSS" ->
                       SEG_BSS   if "UNK" then segment type is reset to
                       SEG_NORM . (C++: const char *)
        @param flags (C++: int)
        @retval: 1 - ok, name is good and segment is renamed
        @retval: 0 - failure, name is NULL or bad or segment is NULL
    """
    return _ida_segment.set_segm_class(*args)

def segtype(*args) -> "uchar":
    r"""


    Get segment type.
    
    segtype(ea) -> uchar
        @param ea: any linear address within the segment (C++: ea_t)
        @return: Segment types ,  SEG_UNDF  if no segment found at 'ea'
    """
    return _ida_segment.segtype(*args)

def get_segment_alignment(*args) -> "char const *":
    r"""


    Get text representation of segment alignment code.
    
    get_segment_alignment(align) -> char const *
        @param align (C++: uchar)
        @return: text digestable by IBM PC assembler.
    """
    return _ida_segment.get_segment_alignment(*args)

def get_segment_combination(*args) -> "char const *":
    r"""


    Get text representation of segment combination code.
    
    get_segment_combination(comb) -> char const *
        @param comb (C++: uchar)
        @return: text digestable by IBM PC assembler.
    """
    return _ida_segment.get_segment_combination(*args)

def get_segm_para(*args) -> "ea_t":
    r"""


    Get segment base paragraph. Segment base paragraph may be converted to
    segment base linear address using 'to_ea()' function. In fact,
    to_ea(get_segm_para(s), 0) == get_segm_base(s).
    
    get_segm_para(s) -> ea_t
        @param s: pointer to segment (C++: const  segment_t  *)
        @return: 0 if s == NULL, the segment base paragraph
    """
    return _ida_segment.get_segm_para(*args)

def get_segm_base(*args) -> "ea_t":
    r"""


    Get segment base linear address. Segment base linear address is used
    to calculate virtual addresses. The virtual address of the first byte
    of the segment will be (start address of segment - segment base linear
    address)
    
    get_segm_base(s) -> ea_t
        @param s: pointer to segment (C++: const  segment_t  *)
        @return: 0 if s == NULL, otherwise segment base linear address
    """
    return _ida_segment.get_segm_base(*args)

def set_segm_addressing(*args) -> "bool":
    r"""


    Change segment addressing mode (16, 32, 64 bits). You must use this
    function to change segment addressing, never change the 'bitness'
    field directly. This function will delete all instructions, comments
    and names in the segment
    
    set_segm_addressing(s, bitness) -> bool
        @param s: pointer to segment (C++: segment_t  *)
        @param bitness: new addressing mode of segment   2: 64bit segment   1:
                        32bit segment   0: 16bit segment (C++: size_t)
        @return: success
    """
    return _ida_segment.set_segm_addressing(*args)

def update_segm(*args) -> "bool":
    r"""


    update_segm(s) -> bool
        @param s (C++: segment_t  *)
    """
    return _ida_segment.update_segm(*args)

def segm_adjust_diff(*args) -> "adiff_t":
    r"""


    Truncate and sign extend a delta depending on the segment.
    
    segm_adjust_diff(s, delta) -> adiff_t
        @param s (C++: const  segment_t  *)
        @param delta (C++: adiff_t)
    """
    return _ida_segment.segm_adjust_diff(*args)

def segm_adjust_ea(*args) -> "ea_t":
    r"""


    Truncate an address depending on the segment.
    
    segm_adjust_ea(s, ea) -> ea_t
        @param s (C++: const  segment_t  *)
        @param ea (C++: ea_t)
    """
    return _ida_segment.segm_adjust_ea(*args)

def get_defsr(*args) -> "sel_t":
    r"""


    get_defsr(s, reg) -> sel_t
        s: segment_t *
        reg: int
    """
    return _ida_segment.get_defsr(*args)

def set_defsr(*args) -> "void":
    r"""


    set_defsr(s, reg, value)
        s: segment_t *
        reg: int
        value: sel_t
    """
    return _ida_segment.set_defsr(*args)

def rebase_program(*args) -> "int":
    r"""


    Rebase the whole program by 'delta' bytes.
    
    rebase_program(delta, flags) -> int
        @param delta: number of bytes to move the program (C++: adiff_t)
        @param flags: Move segment flags  it is recommended to use
                      MSF_FIXONCE  so that the loader takes care of global
                      variables it stored in the database (C++: int)
        @return: Move segment result codes
    """
    return _ida_segment.rebase_program(*args)

if _BC695:
    CSS_NOAREA=CSS_NORANGE
    SEGDEL_KEEP=SEGMOD_KEEP
    SEGDEL_KEEP0=SEGMOD_KEEP0
    SEGDEL_PERM=SEGMOD_KILL
    SEGDEL_SILENT=SEGMOD_SILENT
    def del_segment_cmt(s, rpt):
        set_segment_cmt(s, "", rpt)
    ask_selector=sel2para
# In 7.0, those were renamed
#  - get_true_segm_name -> get_segm_name
#  - get_segm_name -> get_visible_segm_name
# alas, since they have the same prototypes, we cannot do much,
# but redirect all to get_segm_name and hope for the best
    get_true_segm_name=get_segm_name



