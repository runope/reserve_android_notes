# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.1
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

"""
IDA Plugin SDK API wrapper: pro
"""

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _ida_pro
else:
    import _ida_pro

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """
    Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass
    """
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """
    Meta class to enforce nondynamic attributes (no new attributes) for a class
    """
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import weakref

SWIG_PYTHON_LEGACY_BOOL = _ida_pro.SWIG_PYTHON_LEGACY_BOOL

import ida_idaapi


import sys
_BC695 = sys.modules["__main__"].IDAPYTHON_COMPAT_695_API

if _BC695:






    def bc695redef(func):
        ida_idaapi._BC695.replace_fun(func)
        return func

IDA_SDK_VERSION = _ida_pro.IDA_SDK_VERSION
"""
IDA SDK v7.5.
"""

BADMEMSIZE = _ida_pro.BADMEMSIZE

MAXSTR = _ida_pro.MAXSTR
"""
maximum string size
"""

__MF__ = _ida_pro.__MF__
"""
byte sex of our platform (Most significant byte First). 0: little
endian (Intel 80x86). 1: big endian (PowerPC).
"""


def qatoll(*args) -> "int64":
    r"""


    qatoll(nptr) -> int64
        @param nptr (C++: const char *)
    """
    return _ida_pro.qatoll(*args)
FMT_64 = _ida_pro.FMT_64

FMT_Z = _ida_pro.FMT_Z

FMT_ZS = _ida_pro.FMT_ZS

FMT_EA = _ida_pro.FMT_EA


def qexit(*args) -> "void":
    r"""


    Call qatexit functions, shut down UI and kernel, and exit.
    
    qexit(code)
        @param code: exit code (C++: int)
    """
    return _ida_pro.qexit(*args)

def set_bits(*args) -> "void":
    r"""


    Set bits between [low, high) in 'bitmap'.
    
    set_bits(bitmap, low, high)
        @param bitmap (C++: uchar  *)
        @param low (C++: size_t)
        @param high (C++: size_t)
    """
    return _ida_pro.set_bits(*args)

def clear_bits(*args) -> "void":
    r"""


    Clear bits between [low, high) in 'bitmap'.
    
    clear_bits(bitmap, low, high)
        @param bitmap (C++: uchar  *)
        @param low (C++: size_t)
        @param high (C++: size_t)
    """
    return _ida_pro.clear_bits(*args)

def log2ceil(*args) -> "int":
    r"""


    calculate ceil(log2(d64)) or floor(log2(d64)), it returns 0 if d64 ==
    0
    
    log2ceil(d64) -> int
        @param d64 (C++: uint64)
    """
    return _ida_pro.log2ceil(*args)

def log2floor(*args) -> "int":
    r"""


    log2floor(d64) -> int
        @param d64 (C++: uint64)
    """
    return _ida_pro.log2floor(*args)

def extend_sign(*args) -> "uint64":
    r"""


    Sign-, or zero-extend the value 'v' to occupy 64 bits. The value 'v'
    is considered to be of size 'nbytes'.
    
    extend_sign(v, nbytes, sign_extend) -> uint64
        @param v (C++: uint64)
        @param nbytes (C++: int)
        @param sign_extend (C++: bool)
    """
    return _ida_pro.extend_sign(*args)

def readbytes(*args) -> "int":
    r"""


    Read at most 4 bytes from file.
    
    readbytes(h, res, size, mf) -> int
        @param h: file handle (C++: int)
        @param res: value read from file (C++: uint32  *)
        @param size: size of value in bytes (1,2,4) (C++: int)
        @param mf: is MSB first? (C++: bool)
        @return: 0 on success, nonzero otherwise
    """
    return _ida_pro.readbytes(*args)

def writebytes(*args) -> "int":
    r"""


    Write at most 4 bytes to file.
    
    writebytes(h, l, size, mf) -> int
        @param h: file handle (C++: int)
        @param l: value to write (C++: uint32)
        @param size: size of value in bytes (1,2,4) (C++: int)
        @param mf: is MSB first? (C++: bool)
        @return: 0 on success, nonzero otherwise
    """
    return _ida_pro.writebytes(*args)

def reloc_value(*args) -> "void":
    r"""


    reloc_value(value, size, delta, mf)
        @param value (C++: void *)
        @param size (C++: int)
        @param delta (C++: adiff_t)
        @param mf (C++: bool)
    """
    return _ida_pro.reloc_value(*args)

def qvector_reserve(*args) -> "void *":
    r"""


    Change capacity of given qvector.
    
    qvector_reserve(vec, old, cnt, elsize) -> void *
        @param vec: a pointer to a qvector (C++: void *)
        @param old: a pointer to the qvector's array (C++: void *)
        @param cnt: number of elements to reserve (C++: size_t)
        @param elsize: size of each element (C++: size_t)
        @return: a pointer to the newly allocated array
    """
    return _ida_pro.qvector_reserve(*args)
class qrefcnt_obj_t(object):
    r"""
    Proxy of C++ qrefcnt_obj_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    refcnt = property(_ida_pro.qrefcnt_obj_t_refcnt_get, _ida_pro.qrefcnt_obj_t_refcnt_set)

    def release(self, *args) -> "void":
        r"""


        Call destructor. We use 'release()' instead of operator delete() to
        maintain binary compatibility with all compilers (vc and gcc use
        different vtable layouts for operator delete)
        """
        return _ida_pro.qrefcnt_obj_t_release(self, *args)
    __swig_destroy__ = _ida_pro.delete_qrefcnt_obj_t

# Register qrefcnt_obj_t in _ida_pro:
_ida_pro.qrefcnt_obj_t_swigregister(qrefcnt_obj_t)


def relocate_relobj(*args) -> "bool":
    r"""


    relocate_relobj(_relobj, ea, mf) -> bool
        @param _relobj (C++: struct  relobj_t  *)
        @param ea (C++: ea_t)
        @param mf (C++: bool)
    """
    return _ida_pro.relocate_relobj(*args)
IDBDEC_ESCAPE = _ida_pro.IDBDEC_ESCAPE
"""
convert non-printable characters to C escapes (, \\xNN, \\uNNNN)
"""

CP_ACP = _ida_pro.CP_ACP

CP_OEM = _ida_pro.CP_OEM

CP_UTF8 = _ida_pro.CP_UTF8

CP_BOM = _ida_pro.CP_BOM

UTF8_BOM = _ida_pro.UTF8_BOM

UTF16LE_BOM = _ida_pro.UTF16LE_BOM

UTF16BE_BOM = _ida_pro.UTF16BE_BOM

UTF32LE_BOM = _ida_pro.UTF32LE_BOM

UTF32BE_BOM = _ida_pro.UTF32BE_BOM

CP_ELLIPSIS = _ida_pro.CP_ELLIPSIS

UTF8_ELLIPSIS = _ida_pro.UTF8_ELLIPSIS

CP_REPLCHAR = _ida_pro.CP_REPLCHAR

UTF8_REPLCHAR = _ida_pro.UTF8_REPLCHAR

MAX_UTF8_SEQ_LEN = _ida_pro.MAX_UTF8_SEQ_LEN

CEF_RETERR = _ida_pro.CEF_RETERR

ENC_WIN1252 = _ida_pro.ENC_WIN1252

ENC_UTF8 = _ida_pro.ENC_UTF8

ENC_MUTF8 = _ida_pro.ENC_MUTF8

ENC_UTF16 = _ida_pro.ENC_UTF16

ENC_UTF16LE = _ida_pro.ENC_UTF16LE

ENC_UTF16BE = _ida_pro.ENC_UTF16BE

ENC_UTF32 = _ida_pro.ENC_UTF32

ENC_UTF32LE = _ida_pro.ENC_UTF32LE

ENC_UTF32BE = _ida_pro.ENC_UTF32BE

CP_UTF16 = _ida_pro.CP_UTF16
"""
UTF-16 codepage.
"""

SUBSTCHAR = _ida_pro.SUBSTCHAR
"""
default char, used if a char cannot be represented in a codepage
"""

class channel_redir_t(object):
    r"""
    Proxy of C++ channel_redir_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    fd = property(_ida_pro.channel_redir_t_fd_get, _ida_pro.channel_redir_t_fd_set)
    file = property(_ida_pro.channel_redir_t_file_get, _ida_pro.channel_redir_t_file_set)
    flags = property(_ida_pro.channel_redir_t_flags_get, _ida_pro.channel_redir_t_flags_set)

    def is_input(self, *args) -> "bool":
        r"""
        is_input(self) -> bool
        """
        return _ida_pro.channel_redir_t_is_input(self, *args)

    def is_output(self, *args) -> "bool":
        r"""
        is_output(self) -> bool
        """
        return _ida_pro.channel_redir_t_is_output(self, *args)

    def is_append(self, *args) -> "bool":
        r"""
        is_append(self) -> bool
        """
        return _ida_pro.channel_redir_t_is_append(self, *args)

    def is_quoted(self, *args) -> "bool":
        r"""
        is_quoted(self) -> bool
        """
        return _ida_pro.channel_redir_t_is_quoted(self, *args)
    start = property(_ida_pro.channel_redir_t_start_get, _ida_pro.channel_redir_t_start_set)
    length = property(_ida_pro.channel_redir_t_length_get, _ida_pro.channel_redir_t_length_set)

    def __init__(self, *args):
        r"""
        __init__(self) -> channel_redir_t
        """
        _ida_pro.channel_redir_t_swiginit(self, _ida_pro.new_channel_redir_t(*args))
    __swig_destroy__ = _ida_pro.delete_channel_redir_t

# Register channel_redir_t in _ida_pro:
_ida_pro.channel_redir_t_swigregister(channel_redir_t)
IOREDIR_INPUT = _ida_pro.IOREDIR_INPUT
"""
input redirection
"""

IOREDIR_OUTPUT = _ida_pro.IOREDIR_OUTPUT
"""
output redirection
"""

IOREDIR_APPEND = _ida_pro.IOREDIR_APPEND
"""
append, do not overwrite the output file
"""

IOREDIR_QUOTED = _ida_pro.IOREDIR_QUOTED
"""
the file name was quoted
"""



def quote_cmdline_arg(*args) -> "bool":
    r"""


    Quote a command line argument if it contains escape characters. For
    example, *.c will be converted into "*.c" because * may be
    inadvertently expanded by the shell
    
    quote_cmdline_arg(arg) -> bool
        @param arg (C++: qstring  *)
        @return: true: modified 'arg'
    """
    return _ida_pro.quote_cmdline_arg(*args)
class instant_dbgopts_t(object):
    r"""
    Proxy of C++ instant_dbgopts_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    debmod = property(_ida_pro.instant_dbgopts_t_debmod_get, _ida_pro.instant_dbgopts_t_debmod_set)
    env = property(_ida_pro.instant_dbgopts_t_env_get, _ida_pro.instant_dbgopts_t_env_set)
    host = property(_ida_pro.instant_dbgopts_t_host_get, _ida_pro.instant_dbgopts_t_host_set)
    _pass = property(_ida_pro.instant_dbgopts_t__pass_get, _ida_pro.instant_dbgopts_t__pass_set)
    port = property(_ida_pro.instant_dbgopts_t_port_get, _ida_pro.instant_dbgopts_t_port_set)
    pid = property(_ida_pro.instant_dbgopts_t_pid_get, _ida_pro.instant_dbgopts_t_pid_set)
    event_id = property(_ida_pro.instant_dbgopts_t_event_id_get, _ida_pro.instant_dbgopts_t_event_id_set)
    attach = property(_ida_pro.instant_dbgopts_t_attach_get, _ida_pro.instant_dbgopts_t_attach_set)

    def __init__(self, *args):
        r"""
        __init__(self) -> instant_dbgopts_t
        """
        _ida_pro.instant_dbgopts_t_swiginit(self, _ida_pro.new_instant_dbgopts_t(*args))
    __swig_destroy__ = _ida_pro.delete_instant_dbgopts_t

# Register instant_dbgopts_t in _ida_pro:
_ida_pro.instant_dbgopts_t_swigregister(instant_dbgopts_t)


def parse_dbgopts(*args) -> "bool":
    r"""


    Parse the -r command line switch (for instant debugging). r_switch
    points to the value of the -r switch. Example: win32@localhost+
    
    parse_dbgopts(ido, r_switch) -> bool
        @param ido (C++: struct  instant_dbgopts_t  *)
        @param r_switch (C++: const char *)
        @return: true-ok, false-parse error
    """
    return _ida_pro.parse_dbgopts(*args)

def check_process_exit(*args) -> "int":
    r"""


    Check whether process has terminated or not.
    
    check_process_exit(handle, exit_code, msecs=-1) -> int
        @param handle: process handle to wait for (C++: void *)
        @param exit_code: pointer to the buffer for the exit code (C++: int *)
        msecs: int
        @retval: 0 - process has exited, and the exit code is available. if
                     *exit_code < 0: the process was killed with a signal
                     -*exit_code
        @retval: 1 - process has not exited yet
        @retval: -1 - error happened, see error code for  winerr()  in
                      *exit_code
    """
    return _ida_pro.check_process_exit(*args)
TCT_UNKNOWN = _ida_pro.TCT_UNKNOWN

TCT_OWNER = _ida_pro.TCT_OWNER

TCT_NOT_OWNER = _ida_pro.TCT_NOT_OWNER


def is_control_tty(*args) -> "enum tty_control_t":
    r"""


    Check if the current process is the owner of the TTY specified by 'fd'
    (typically an opened descriptor to /dev/tty).
    
    is_control_tty(fd) -> enum tty_control_t
        @param fd (C++: int)
    """
    return _ida_pro.is_control_tty(*args)

def qdetach_tty(*args) -> "void":
    r"""


    If the current terminal is the controlling terminal of the calling
    process, give up this controlling terminal.The current terminal is
    supposed to be /dev/tty
    """
    return _ida_pro.qdetach_tty(*args)

def qcontrol_tty(*args) -> "void":
    r"""


    Make the current terminal the controlling terminal of the calling
    process.The current terminal is supposed to be /dev/tty
    """
    return _ida_pro.qcontrol_tty(*args)
class __qthread_t(object):
    r"""
    Proxy of C++ __qthread_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(self) -> __qthread_t
        """
        _ida_pro.__qthread_t_swiginit(self, _ida_pro.new___qthread_t(*args))
    __swig_destroy__ = _ida_pro.delete___qthread_t

# Register __qthread_t in _ida_pro:
_ida_pro.__qthread_t_swigregister(__qthread_t)


def qthread_equal(*args) -> "bool":
    r"""


    Are two threads equal?
    
    qthread_equal(q1, q2) -> bool
        @param q1 (C++: qthread_t)
        @param q2 (C++: qthread_t)
    """
    return _ida_pro.qthread_equal(*args)

def is_main_thread(*args) -> "bool":
    r"""


    Are we running in the main thread?
    """
    return _ida_pro.is_main_thread(*args)
class __qsemaphore_t(object):
    r"""
    Proxy of C++ __qsemaphore_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(self) -> __qsemaphore_t
        """
        _ida_pro.__qsemaphore_t_swiginit(self, _ida_pro.new___qsemaphore_t(*args))
    __swig_destroy__ = _ida_pro.delete___qsemaphore_t

# Register __qsemaphore_t in _ida_pro:
_ida_pro.__qsemaphore_t_swigregister(__qsemaphore_t)

class __qmutex_t(object):
    r"""
    Proxy of C++ __qmutex_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(self) -> __qmutex_t
        """
        _ida_pro.__qmutex_t_swiginit(self, _ida_pro.new___qmutex_t(*args))
    __swig_destroy__ = _ida_pro.delete___qmutex_t

# Register __qmutex_t in _ida_pro:
_ida_pro.__qmutex_t_swigregister(__qmutex_t)

class qmutex_locker_t(object):
    r"""
    Proxy of C++ qmutex_locker_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        __init__(self, _lock) -> qmutex_locker_t
            _lock: qmutex_t
        """
        _ida_pro.qmutex_locker_t_swiginit(self, _ida_pro.new_qmutex_locker_t(*args))
    __swig_destroy__ = _ida_pro.delete_qmutex_locker_t

# Register qmutex_locker_t in _ida_pro:
_ida_pro.qmutex_locker_t_swigregister(qmutex_locker_t)

class intvec_t(object):
    r"""
    Proxy of C++ qvector< int > class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        __init__(self) -> intvec_t
            x: qvector< int > const &
        """
        _ida_pro.intvec_t_swiginit(self, _ida_pro.new_intvec_t(*args))
    __swig_destroy__ = _ida_pro.delete_intvec_t

    def push_back(self, *args) -> "int &":
        r"""


        push_back(self, x)
            x: int const &
        """
        return _ida_pro.intvec_t_push_back(self, *args)

    def pop_back(self, *args) -> "void":
        r"""
        pop_back(self)
        """
        return _ida_pro.intvec_t_pop_back(self, *args)

    def size(self, *args) -> "size_t":
        r"""
        size(self) -> size_t
        """
        return _ida_pro.intvec_t_size(self, *args)

    def empty(self, *args) -> "bool":
        r"""
        empty(self) -> bool
        """
        return _ida_pro.intvec_t_empty(self, *args)

    def at(self, *args) -> "int const &":
        r"""


        at(self, _idx) -> int const &
            _idx: size_t
        """
        return _ida_pro.intvec_t_at(self, *args)

    def qclear(self, *args) -> "void":
        r"""
        qclear(self)
        """
        return _ida_pro.intvec_t_qclear(self, *args)

    def clear(self, *args) -> "void":
        r"""
        clear(self)
        """
        return _ida_pro.intvec_t_clear(self, *args)

    def resize(self, *args) -> "void":
        r"""


        resize(self, _newsize, x)
            _newsize: size_t
            x: int const &
        

        resize(self, _newsize)
            _newsize: size_t
        """
        return _ida_pro.intvec_t_resize(self, *args)

    def capacity(self, *args) -> "size_t":
        r"""
        capacity(self) -> size_t
        """
        return _ida_pro.intvec_t_capacity(self, *args)

    def reserve(self, *args) -> "void":
        r"""


        reserve(self, cnt)
            cnt: size_t
        """
        return _ida_pro.intvec_t_reserve(self, *args)

    def truncate(self, *args) -> "void":
        r"""
        truncate(self)
        """
        return _ida_pro.intvec_t_truncate(self, *args)

    def swap(self, *args) -> "void":
        r"""


        swap(self, r)
            r: qvector< int > &
        """
        return _ida_pro.intvec_t_swap(self, *args)

    def extract(self, *args) -> "int *":
        r"""
        extract(self) -> int *
        """
        return _ida_pro.intvec_t_extract(self, *args)

    def inject(self, *args) -> "void":
        r"""


        inject(self, s, len)
            s: int *
            len: size_t
        """
        return _ida_pro.intvec_t_inject(self, *args)

    def __eq__(self, *args) -> "bool":
        r"""


        __eq__(self, r) -> bool
            r: qvector< int > const &
        """
        return _ida_pro.intvec_t___eq__(self, *args)

    def __ne__(self, *args) -> "bool":
        r"""


        __ne__(self, r) -> bool
            r: qvector< int > const &
        """
        return _ida_pro.intvec_t___ne__(self, *args)

    def begin(self, *args) -> "qvector< int >::const_iterator":
        r"""
        begin(self) -> qvector< int >::iterator
        begin(self) -> qvector< int >::const_iterator
        """
        return _ida_pro.intvec_t_begin(self, *args)

    def end(self, *args) -> "qvector< int >::const_iterator":
        r"""
        end(self) -> qvector< int >::iterator
        end(self) -> qvector< int >::const_iterator
        """
        return _ida_pro.intvec_t_end(self, *args)

    def insert(self, *args) -> "qvector< int >::iterator":
        r"""


        insert(self, it, x) -> qvector< int >::iterator
            it: qvector< int >::iterator
            x: int const &
        """
        return _ida_pro.intvec_t_insert(self, *args)

    def erase(self, *args) -> "qvector< int >::iterator":
        r"""


        erase(self, it) -> qvector< int >::iterator
            it: qvector< int >::iterator
        

        erase(self, first, last) -> qvector< int >::iterator
            first: qvector< int >::iterator
            last: qvector< int >::iterator
        """
        return _ida_pro.intvec_t_erase(self, *args)

    def find(self, *args) -> "qvector< int >::const_iterator":
        r"""


        find(self, x) -> qvector< int >::iterator
            x: int const &
        

        find(self, x) -> qvector< int >::const_iterator
            x: int const &
        """
        return _ida_pro.intvec_t_find(self, *args)

    def has(self, *args) -> "bool":
        r"""


        has(self, x) -> bool
            x: int const &
        """
        return _ida_pro.intvec_t_has(self, *args)

    def add_unique(self, *args) -> "bool":
        r"""


        add_unique(self, x) -> bool
            x: int const &
        """
        return _ida_pro.intvec_t_add_unique(self, *args)

    def _del(self, *args) -> "bool":
        r"""


        _del(self, x) -> bool
            x: int const &
        """
        return _ida_pro.intvec_t__del(self, *args)

    def __len__(self, *args) -> "size_t":
        r"""
        __len__(self) -> size_t
        """
        return _ida_pro.intvec_t___len__(self, *args)

    def __getitem__(self, *args) -> "int const &":
        r"""


        __getitem__(self, i) -> int const &
            i: size_t
        """
        return _ida_pro.intvec_t___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        r"""


        __setitem__(self, i, v)
            i: size_t
            v: int const &
        """
        return _ida_pro.intvec_t___setitem__(self, *args)

    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator


# Register intvec_t in _ida_pro:
_ida_pro.intvec_t_swigregister(intvec_t)
cvar = _ida_pro.cvar
NULL_PIPE_HANDLE = cvar.NULL_PIPE_HANDLE

class uintvec_t(object):
    r"""
    Proxy of C++ qvector< unsigned int > class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        __init__(self) -> uintvec_t
            x: qvector< unsigned int > const &
        """
        _ida_pro.uintvec_t_swiginit(self, _ida_pro.new_uintvec_t(*args))
    __swig_destroy__ = _ida_pro.delete_uintvec_t

    def push_back(self, *args) -> "unsigned int &":
        r"""


        push_back(self, x)
            x: unsigned int const &
        """
        return _ida_pro.uintvec_t_push_back(self, *args)

    def pop_back(self, *args) -> "void":
        r"""
        pop_back(self)
        """
        return _ida_pro.uintvec_t_pop_back(self, *args)

    def size(self, *args) -> "size_t":
        r"""
        size(self) -> size_t
        """
        return _ida_pro.uintvec_t_size(self, *args)

    def empty(self, *args) -> "bool":
        r"""
        empty(self) -> bool
        """
        return _ida_pro.uintvec_t_empty(self, *args)

    def at(self, *args) -> "unsigned int const &":
        r"""


        at(self, _idx) -> unsigned int const &
            _idx: size_t
        """
        return _ida_pro.uintvec_t_at(self, *args)

    def qclear(self, *args) -> "void":
        r"""
        qclear(self)
        """
        return _ida_pro.uintvec_t_qclear(self, *args)

    def clear(self, *args) -> "void":
        r"""
        clear(self)
        """
        return _ida_pro.uintvec_t_clear(self, *args)

    def resize(self, *args) -> "void":
        r"""


        resize(self, _newsize, x)
            _newsize: size_t
            x: unsigned int const &
        

        resize(self, _newsize)
            _newsize: size_t
        """
        return _ida_pro.uintvec_t_resize(self, *args)

    def capacity(self, *args) -> "size_t":
        r"""
        capacity(self) -> size_t
        """
        return _ida_pro.uintvec_t_capacity(self, *args)

    def reserve(self, *args) -> "void":
        r"""


        reserve(self, cnt)
            cnt: size_t
        """
        return _ida_pro.uintvec_t_reserve(self, *args)

    def truncate(self, *args) -> "void":
        r"""
        truncate(self)
        """
        return _ida_pro.uintvec_t_truncate(self, *args)

    def swap(self, *args) -> "void":
        r"""


        swap(self, r)
            r: qvector< unsigned int > &
        """
        return _ida_pro.uintvec_t_swap(self, *args)

    def extract(self, *args) -> "unsigned int *":
        r"""
        extract(self) -> unsigned int *
        """
        return _ida_pro.uintvec_t_extract(self, *args)

    def inject(self, *args) -> "void":
        r"""


        inject(self, s, len)
            s: unsigned int *
            len: size_t
        """
        return _ida_pro.uintvec_t_inject(self, *args)

    def __eq__(self, *args) -> "bool":
        r"""


        __eq__(self, r) -> bool
            r: qvector< unsigned int > const &
        """
        return _ida_pro.uintvec_t___eq__(self, *args)

    def __ne__(self, *args) -> "bool":
        r"""


        __ne__(self, r) -> bool
            r: qvector< unsigned int > const &
        """
        return _ida_pro.uintvec_t___ne__(self, *args)

    def begin(self, *args) -> "qvector< unsigned int >::const_iterator":
        r"""
        begin(self) -> qvector< unsigned int >::iterator
        begin(self) -> qvector< unsigned int >::const_iterator
        """
        return _ida_pro.uintvec_t_begin(self, *args)

    def end(self, *args) -> "qvector< unsigned int >::const_iterator":
        r"""
        end(self) -> qvector< unsigned int >::iterator
        end(self) -> qvector< unsigned int >::const_iterator
        """
        return _ida_pro.uintvec_t_end(self, *args)

    def insert(self, *args) -> "qvector< unsigned int >::iterator":
        r"""


        insert(self, it, x) -> qvector< unsigned int >::iterator
            it: qvector< unsigned int >::iterator
            x: unsigned int const &
        """
        return _ida_pro.uintvec_t_insert(self, *args)

    def erase(self, *args) -> "qvector< unsigned int >::iterator":
        r"""


        erase(self, it) -> qvector< unsigned int >::iterator
            it: qvector< unsigned int >::iterator
        

        erase(self, first, last) -> qvector< unsigned int >::iterator
            first: qvector< unsigned int >::iterator
            last: qvector< unsigned int >::iterator
        """
        return _ida_pro.uintvec_t_erase(self, *args)

    def find(self, *args) -> "qvector< unsigned int >::const_iterator":
        r"""


        find(self, x) -> qvector< unsigned int >::iterator
            x: unsigned int const &
        

        find(self, x) -> qvector< unsigned int >::const_iterator
            x: unsigned int const &
        """
        return _ida_pro.uintvec_t_find(self, *args)

    def has(self, *args) -> "bool":
        r"""


        has(self, x) -> bool
            x: unsigned int const &
        """
        return _ida_pro.uintvec_t_has(self, *args)

    def add_unique(self, *args) -> "bool":
        r"""


        add_unique(self, x) -> bool
            x: unsigned int const &
        """
        return _ida_pro.uintvec_t_add_unique(self, *args)

    def _del(self, *args) -> "bool":
        r"""


        _del(self, x) -> bool
            x: unsigned int const &
        """
        return _ida_pro.uintvec_t__del(self, *args)

    def __len__(self, *args) -> "size_t":
        r"""
        __len__(self) -> size_t
        """
        return _ida_pro.uintvec_t___len__(self, *args)

    def __getitem__(self, *args) -> "unsigned int const &":
        r"""


        __getitem__(self, i) -> unsigned int const &
            i: size_t
        """
        return _ida_pro.uintvec_t___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        r"""


        __setitem__(self, i, v)
            i: size_t
            v: unsigned int const &
        """
        return _ida_pro.uintvec_t___setitem__(self, *args)

    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator


# Register uintvec_t in _ida_pro:
_ida_pro.uintvec_t_swigregister(uintvec_t)

class longlongvec_t(object):
    r"""
    Proxy of C++ qvector< long long > class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        __init__(self) -> longlongvec_t
            x: qvector< long long > const &
        """
        _ida_pro.longlongvec_t_swiginit(self, _ida_pro.new_longlongvec_t(*args))
    __swig_destroy__ = _ida_pro.delete_longlongvec_t

    def push_back(self, *args) -> "long long &":
        r"""


        push_back(self, x)
            x: long long const &
        """
        return _ida_pro.longlongvec_t_push_back(self, *args)

    def pop_back(self, *args) -> "void":
        r"""
        pop_back(self)
        """
        return _ida_pro.longlongvec_t_pop_back(self, *args)

    def size(self, *args) -> "size_t":
        r"""
        size(self) -> size_t
        """
        return _ida_pro.longlongvec_t_size(self, *args)

    def empty(self, *args) -> "bool":
        r"""
        empty(self) -> bool
        """
        return _ida_pro.longlongvec_t_empty(self, *args)

    def at(self, *args) -> "long long const &":
        r"""


        at(self, _idx) -> long long const &
            _idx: size_t
        """
        return _ida_pro.longlongvec_t_at(self, *args)

    def qclear(self, *args) -> "void":
        r"""
        qclear(self)
        """
        return _ida_pro.longlongvec_t_qclear(self, *args)

    def clear(self, *args) -> "void":
        r"""
        clear(self)
        """
        return _ida_pro.longlongvec_t_clear(self, *args)

    def resize(self, *args) -> "void":
        r"""


        resize(self, _newsize, x)
            _newsize: size_t
            x: long long const &
        

        resize(self, _newsize)
            _newsize: size_t
        """
        return _ida_pro.longlongvec_t_resize(self, *args)

    def capacity(self, *args) -> "size_t":
        r"""
        capacity(self) -> size_t
        """
        return _ida_pro.longlongvec_t_capacity(self, *args)

    def reserve(self, *args) -> "void":
        r"""


        reserve(self, cnt)
            cnt: size_t
        """
        return _ida_pro.longlongvec_t_reserve(self, *args)

    def truncate(self, *args) -> "void":
        r"""
        truncate(self)
        """
        return _ida_pro.longlongvec_t_truncate(self, *args)

    def swap(self, *args) -> "void":
        r"""


        swap(self, r)
            r: qvector< long long > &
        """
        return _ida_pro.longlongvec_t_swap(self, *args)

    def extract(self, *args) -> "long long *":
        r"""
        extract(self) -> long long *
        """
        return _ida_pro.longlongvec_t_extract(self, *args)

    def inject(self, *args) -> "void":
        r"""


        inject(self, s, len)
            s: long long *
            len: size_t
        """
        return _ida_pro.longlongvec_t_inject(self, *args)

    def __eq__(self, *args) -> "bool":
        r"""


        __eq__(self, r) -> bool
            r: qvector< long long > const &
        """
        return _ida_pro.longlongvec_t___eq__(self, *args)

    def __ne__(self, *args) -> "bool":
        r"""


        __ne__(self, r) -> bool
            r: qvector< long long > const &
        """
        return _ida_pro.longlongvec_t___ne__(self, *args)

    def begin(self, *args) -> "qvector< long long >::const_iterator":
        r"""
        begin(self) -> qvector< long long >::iterator
        begin(self) -> qvector< long long >::const_iterator
        """
        return _ida_pro.longlongvec_t_begin(self, *args)

    def end(self, *args) -> "qvector< long long >::const_iterator":
        r"""
        end(self) -> qvector< long long >::iterator
        end(self) -> qvector< long long >::const_iterator
        """
        return _ida_pro.longlongvec_t_end(self, *args)

    def insert(self, *args) -> "qvector< long long >::iterator":
        r"""


        insert(self, it, x) -> qvector< long long >::iterator
            it: qvector< long long >::iterator
            x: long long const &
        """
        return _ida_pro.longlongvec_t_insert(self, *args)

    def erase(self, *args) -> "qvector< long long >::iterator":
        r"""


        erase(self, it) -> qvector< long long >::iterator
            it: qvector< long long >::iterator
        

        erase(self, first, last) -> qvector< long long >::iterator
            first: qvector< long long >::iterator
            last: qvector< long long >::iterator
        """
        return _ida_pro.longlongvec_t_erase(self, *args)

    def find(self, *args) -> "qvector< long long >::const_iterator":
        r"""


        find(self, x) -> qvector< long long >::iterator
            x: long long const &
        

        find(self, x) -> qvector< long long >::const_iterator
            x: long long const &
        """
        return _ida_pro.longlongvec_t_find(self, *args)

    def has(self, *args) -> "bool":
        r"""


        has(self, x) -> bool
            x: long long const &
        """
        return _ida_pro.longlongvec_t_has(self, *args)

    def add_unique(self, *args) -> "bool":
        r"""


        add_unique(self, x) -> bool
            x: long long const &
        """
        return _ida_pro.longlongvec_t_add_unique(self, *args)

    def _del(self, *args) -> "bool":
        r"""


        _del(self, x) -> bool
            x: long long const &
        """
        return _ida_pro.longlongvec_t__del(self, *args)

    def __len__(self, *args) -> "size_t":
        r"""
        __len__(self) -> size_t
        """
        return _ida_pro.longlongvec_t___len__(self, *args)

    def __getitem__(self, *args) -> "long long const &":
        r"""


        __getitem__(self, i) -> long long const &
            i: size_t
        """
        return _ida_pro.longlongvec_t___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        r"""


        __setitem__(self, i, v)
            i: size_t
            v: long long const &
        """
        return _ida_pro.longlongvec_t___setitem__(self, *args)

    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator


# Register longlongvec_t in _ida_pro:
_ida_pro.longlongvec_t_swigregister(longlongvec_t)

class ulonglongvec_t(object):
    r"""
    Proxy of C++ qvector< unsigned long long > class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        __init__(self) -> ulonglongvec_t
            x: qvector< unsigned long long > const &
        """
        _ida_pro.ulonglongvec_t_swiginit(self, _ida_pro.new_ulonglongvec_t(*args))
    __swig_destroy__ = _ida_pro.delete_ulonglongvec_t

    def push_back(self, *args) -> "unsigned long long &":
        r"""


        push_back(self, x)
            x: unsigned long long const &
        """
        return _ida_pro.ulonglongvec_t_push_back(self, *args)

    def pop_back(self, *args) -> "void":
        r"""
        pop_back(self)
        """
        return _ida_pro.ulonglongvec_t_pop_back(self, *args)

    def size(self, *args) -> "size_t":
        r"""
        size(self) -> size_t
        """
        return _ida_pro.ulonglongvec_t_size(self, *args)

    def empty(self, *args) -> "bool":
        r"""
        empty(self) -> bool
        """
        return _ida_pro.ulonglongvec_t_empty(self, *args)

    def at(self, *args) -> "unsigned long long const &":
        r"""


        at(self, _idx) -> unsigned long long const &
            _idx: size_t
        """
        return _ida_pro.ulonglongvec_t_at(self, *args)

    def qclear(self, *args) -> "void":
        r"""
        qclear(self)
        """
        return _ida_pro.ulonglongvec_t_qclear(self, *args)

    def clear(self, *args) -> "void":
        r"""
        clear(self)
        """
        return _ida_pro.ulonglongvec_t_clear(self, *args)

    def resize(self, *args) -> "void":
        r"""


        resize(self, _newsize, x)
            _newsize: size_t
            x: unsigned long long const &
        

        resize(self, _newsize)
            _newsize: size_t
        """
        return _ida_pro.ulonglongvec_t_resize(self, *args)

    def capacity(self, *args) -> "size_t":
        r"""
        capacity(self) -> size_t
        """
        return _ida_pro.ulonglongvec_t_capacity(self, *args)

    def reserve(self, *args) -> "void":
        r"""


        reserve(self, cnt)
            cnt: size_t
        """
        return _ida_pro.ulonglongvec_t_reserve(self, *args)

    def truncate(self, *args) -> "void":
        r"""
        truncate(self)
        """
        return _ida_pro.ulonglongvec_t_truncate(self, *args)

    def swap(self, *args) -> "void":
        r"""


        swap(self, r)
            r: qvector< unsigned long long > &
        """
        return _ida_pro.ulonglongvec_t_swap(self, *args)

    def extract(self, *args) -> "unsigned long long *":
        r"""
        extract(self) -> unsigned long long *
        """
        return _ida_pro.ulonglongvec_t_extract(self, *args)

    def inject(self, *args) -> "void":
        r"""


        inject(self, s, len)
            s: unsigned long long *
            len: size_t
        """
        return _ida_pro.ulonglongvec_t_inject(self, *args)

    def __eq__(self, *args) -> "bool":
        r"""


        __eq__(self, r) -> bool
            r: qvector< unsigned long long > const &
        """
        return _ida_pro.ulonglongvec_t___eq__(self, *args)

    def __ne__(self, *args) -> "bool":
        r"""


        __ne__(self, r) -> bool
            r: qvector< unsigned long long > const &
        """
        return _ida_pro.ulonglongvec_t___ne__(self, *args)

    def begin(self, *args) -> "qvector< unsigned long long >::const_iterator":
        r"""
        begin(self) -> qvector< unsigned long long >::iterator
        begin(self) -> qvector< unsigned long long >::const_iterator
        """
        return _ida_pro.ulonglongvec_t_begin(self, *args)

    def end(self, *args) -> "qvector< unsigned long long >::const_iterator":
        r"""
        end(self) -> qvector< unsigned long long >::iterator
        end(self) -> qvector< unsigned long long >::const_iterator
        """
        return _ida_pro.ulonglongvec_t_end(self, *args)

    def insert(self, *args) -> "qvector< unsigned long long >::iterator":
        r"""


        insert(self, it, x) -> qvector< unsigned long long >::iterator
            it: qvector< unsigned long long >::iterator
            x: unsigned long long const &
        """
        return _ida_pro.ulonglongvec_t_insert(self, *args)

    def erase(self, *args) -> "qvector< unsigned long long >::iterator":
        r"""


        erase(self, it) -> qvector< unsigned long long >::iterator
            it: qvector< unsigned long long >::iterator
        

        erase(self, first, last) -> qvector< unsigned long long >::iterator
            first: qvector< unsigned long long >::iterator
            last: qvector< unsigned long long >::iterator
        """
        return _ida_pro.ulonglongvec_t_erase(self, *args)

    def find(self, *args) -> "qvector< unsigned long long >::const_iterator":
        r"""


        find(self, x) -> qvector< unsigned long long >::iterator
            x: unsigned long long const &
        

        find(self, x) -> qvector< unsigned long long >::const_iterator
            x: unsigned long long const &
        """
        return _ida_pro.ulonglongvec_t_find(self, *args)

    def has(self, *args) -> "bool":
        r"""


        has(self, x) -> bool
            x: unsigned long long const &
        """
        return _ida_pro.ulonglongvec_t_has(self, *args)

    def add_unique(self, *args) -> "bool":
        r"""


        add_unique(self, x) -> bool
            x: unsigned long long const &
        """
        return _ida_pro.ulonglongvec_t_add_unique(self, *args)

    def _del(self, *args) -> "bool":
        r"""


        _del(self, x) -> bool
            x: unsigned long long const &
        """
        return _ida_pro.ulonglongvec_t__del(self, *args)

    def __len__(self, *args) -> "size_t":
        r"""
        __len__(self) -> size_t
        """
        return _ida_pro.ulonglongvec_t___len__(self, *args)

    def __getitem__(self, *args) -> "unsigned long long const &":
        r"""


        __getitem__(self, i) -> unsigned long long const &
            i: size_t
        """
        return _ida_pro.ulonglongvec_t___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        r"""


        __setitem__(self, i, v)
            i: size_t
            v: unsigned long long const &
        """
        return _ida_pro.ulonglongvec_t___setitem__(self, *args)

    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator


# Register ulonglongvec_t in _ida_pro:
_ida_pro.ulonglongvec_t_swigregister(ulonglongvec_t)

class boolvec_t(object):
    r"""
    Proxy of C++ qvector< bool > class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        __init__(self) -> boolvec_t
            x: qvector< bool > const &
        """
        _ida_pro.boolvec_t_swiginit(self, _ida_pro.new_boolvec_t(*args))
    __swig_destroy__ = _ida_pro.delete_boolvec_t

    def push_back(self, *args) -> "bool &":
        r"""


        push_back(self, x)
            x: bool const &
        """
        return _ida_pro.boolvec_t_push_back(self, *args)

    def pop_back(self, *args) -> "void":
        r"""
        pop_back(self)
        """
        return _ida_pro.boolvec_t_pop_back(self, *args)

    def size(self, *args) -> "size_t":
        r"""
        size(self) -> size_t
        """
        return _ida_pro.boolvec_t_size(self, *args)

    def empty(self, *args) -> "bool":
        r"""
        empty(self) -> bool
        """
        return _ida_pro.boolvec_t_empty(self, *args)

    def at(self, *args) -> "bool const &":
        r"""


        at(self, _idx) -> bool const &
            _idx: size_t
        """
        return _ida_pro.boolvec_t_at(self, *args)

    def qclear(self, *args) -> "void":
        r"""
        qclear(self)
        """
        return _ida_pro.boolvec_t_qclear(self, *args)

    def clear(self, *args) -> "void":
        r"""
        clear(self)
        """
        return _ida_pro.boolvec_t_clear(self, *args)

    def resize(self, *args) -> "void":
        r"""


        resize(self, _newsize, x)
            _newsize: size_t
            x: bool const &
        

        resize(self, _newsize)
            _newsize: size_t
        """
        return _ida_pro.boolvec_t_resize(self, *args)

    def grow(self, *args) -> "void":
        r"""


        grow(self, x=bool())
            x: bool const &
        """
        return _ida_pro.boolvec_t_grow(self, *args)

    def capacity(self, *args) -> "size_t":
        r"""
        capacity(self) -> size_t
        """
        return _ida_pro.boolvec_t_capacity(self, *args)

    def reserve(self, *args) -> "void":
        r"""


        reserve(self, cnt)
            cnt: size_t
        """
        return _ida_pro.boolvec_t_reserve(self, *args)

    def truncate(self, *args) -> "void":
        r"""
        truncate(self)
        """
        return _ida_pro.boolvec_t_truncate(self, *args)

    def swap(self, *args) -> "void":
        r"""


        swap(self, r)
            r: qvector< bool > &
        """
        return _ida_pro.boolvec_t_swap(self, *args)

    def extract(self, *args) -> "bool *":
        r"""
        extract(self) -> bool *
        """
        return _ida_pro.boolvec_t_extract(self, *args)

    def inject(self, *args) -> "void":
        r"""


        inject(self, s, len)
            s: bool *
            len: size_t
        """
        return _ida_pro.boolvec_t_inject(self, *args)

    def __eq__(self, *args) -> "bool":
        r"""


        __eq__(self, r) -> bool
            r: qvector< bool > const &
        """
        return _ida_pro.boolvec_t___eq__(self, *args)

    def __ne__(self, *args) -> "bool":
        r"""


        __ne__(self, r) -> bool
            r: qvector< bool > const &
        """
        return _ida_pro.boolvec_t___ne__(self, *args)

    def begin(self, *args) -> "qvector< bool >::const_iterator":
        r"""
        begin(self) -> qvector< bool >::iterator
        begin(self) -> qvector< bool >::const_iterator
        """
        return _ida_pro.boolvec_t_begin(self, *args)

    def end(self, *args) -> "qvector< bool >::const_iterator":
        r"""
        end(self) -> qvector< bool >::iterator
        end(self) -> qvector< bool >::const_iterator
        """
        return _ida_pro.boolvec_t_end(self, *args)

    def insert(self, *args) -> "qvector< bool >::iterator":
        r"""


        insert(self, it, x) -> qvector< bool >::iterator
            it: qvector< bool >::iterator
            x: bool const &
        """
        return _ida_pro.boolvec_t_insert(self, *args)

    def erase(self, *args) -> "qvector< bool >::iterator":
        r"""


        erase(self, it) -> qvector< bool >::iterator
            it: qvector< bool >::iterator
        

        erase(self, first, last) -> qvector< bool >::iterator
            first: qvector< bool >::iterator
            last: qvector< bool >::iterator
        """
        return _ida_pro.boolvec_t_erase(self, *args)

    def find(self, *args) -> "qvector< bool >::const_iterator":
        r"""


        find(self, x) -> qvector< bool >::iterator
            x: bool const &
        

        find(self, x) -> qvector< bool >::const_iterator
            x: bool const &
        """
        return _ida_pro.boolvec_t_find(self, *args)

    def has(self, *args) -> "bool":
        r"""


        has(self, x) -> bool
            x: bool const &
        """
        return _ida_pro.boolvec_t_has(self, *args)

    def add_unique(self, *args) -> "bool":
        r"""


        add_unique(self, x) -> bool
            x: bool const &
        """
        return _ida_pro.boolvec_t_add_unique(self, *args)

    def _del(self, *args) -> "bool":
        r"""


        _del(self, x) -> bool
            x: bool const &
        """
        return _ida_pro.boolvec_t__del(self, *args)

    def __len__(self, *args) -> "size_t":
        r"""
        __len__(self) -> size_t
        """
        return _ida_pro.boolvec_t___len__(self, *args)

    def __getitem__(self, *args) -> "bool const &":
        r"""


        __getitem__(self, i) -> bool const &
            i: size_t
        """
        return _ida_pro.boolvec_t___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        r"""


        __setitem__(self, i, v)
            i: size_t
            v: bool const &
        """
        return _ida_pro.boolvec_t___setitem__(self, *args)

    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator


# Register boolvec_t in _ida_pro:
_ida_pro.boolvec_t_swigregister(boolvec_t)

class strvec_t(object):
    r"""
    Proxy of C++ qvector< simpleline_t > class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        __init__(self) -> strvec_t
            x: qvector< simpleline_t > const &
        """
        _ida_pro.strvec_t_swiginit(self, _ida_pro.new_strvec_t(*args))
    __swig_destroy__ = _ida_pro.delete_strvec_t

    def push_back(self, *args) -> "simpleline_t &":
        r"""


        push_back(self, x)
            x: simpleline_t const &
        """
        return _ida_pro.strvec_t_push_back(self, *args)

    def pop_back(self, *args) -> "void":
        r"""
        pop_back(self)
        """
        return _ida_pro.strvec_t_pop_back(self, *args)

    def size(self, *args) -> "size_t":
        r"""
        size(self) -> size_t
        """
        return _ida_pro.strvec_t_size(self, *args)

    def empty(self, *args) -> "bool":
        r"""
        empty(self) -> bool
        """
        return _ida_pro.strvec_t_empty(self, *args)

    def at(self, *args) -> "simpleline_t const &":
        r"""


        at(self, _idx) -> simpleline_t const &
            _idx: size_t
        """
        return _ida_pro.strvec_t_at(self, *args)

    def qclear(self, *args) -> "void":
        r"""
        qclear(self)
        """
        return _ida_pro.strvec_t_qclear(self, *args)

    def clear(self, *args) -> "void":
        r"""
        clear(self)
        """
        return _ida_pro.strvec_t_clear(self, *args)

    def resize(self, *args) -> "void":
        r"""


        resize(self, _newsize, x)
            _newsize: size_t
            x: simpleline_t const &
        

        resize(self, _newsize)
            _newsize: size_t
        """
        return _ida_pro.strvec_t_resize(self, *args)

    def grow(self, *args) -> "void":
        r"""


        grow(self, x=simpleline_t())
            x: simpleline_t const &
        """
        return _ida_pro.strvec_t_grow(self, *args)

    def capacity(self, *args) -> "size_t":
        r"""
        capacity(self) -> size_t
        """
        return _ida_pro.strvec_t_capacity(self, *args)

    def reserve(self, *args) -> "void":
        r"""


        reserve(self, cnt)
            cnt: size_t
        """
        return _ida_pro.strvec_t_reserve(self, *args)

    def truncate(self, *args) -> "void":
        r"""
        truncate(self)
        """
        return _ida_pro.strvec_t_truncate(self, *args)

    def swap(self, *args) -> "void":
        r"""


        swap(self, r)
            r: qvector< simpleline_t > &
        """
        return _ida_pro.strvec_t_swap(self, *args)

    def extract(self, *args) -> "simpleline_t *":
        r"""
        extract(self) -> simpleline_t *
        """
        return _ida_pro.strvec_t_extract(self, *args)

    def inject(self, *args) -> "void":
        r"""


        inject(self, s, len)
            s: simpleline_t *
            len: size_t
        """
        return _ida_pro.strvec_t_inject(self, *args)

    def begin(self, *args) -> "qvector< simpleline_t >::const_iterator":
        r"""
        begin(self) -> qvector< simpleline_t >::iterator
        begin(self) -> qvector< simpleline_t >::const_iterator
        """
        return _ida_pro.strvec_t_begin(self, *args)

    def end(self, *args) -> "qvector< simpleline_t >::const_iterator":
        r"""
        end(self) -> qvector< simpleline_t >::iterator
        end(self) -> qvector< simpleline_t >::const_iterator
        """
        return _ida_pro.strvec_t_end(self, *args)

    def insert(self, *args) -> "qvector< simpleline_t >::iterator":
        r"""


        insert(self, it, x) -> qvector< simpleline_t >::iterator
            it: qvector< simpleline_t >::iterator
            x: simpleline_t const &
        """
        return _ida_pro.strvec_t_insert(self, *args)

    def erase(self, *args) -> "qvector< simpleline_t >::iterator":
        r"""


        erase(self, it) -> qvector< simpleline_t >::iterator
            it: qvector< simpleline_t >::iterator
        

        erase(self, first, last) -> qvector< simpleline_t >::iterator
            first: qvector< simpleline_t >::iterator
            last: qvector< simpleline_t >::iterator
        """
        return _ida_pro.strvec_t_erase(self, *args)

    def __len__(self, *args) -> "size_t":
        r"""
        __len__(self) -> size_t
        """
        return _ida_pro.strvec_t___len__(self, *args)

    def __getitem__(self, *args) -> "simpleline_t const &":
        r"""


        __getitem__(self, i) -> simpleline_t const &
            i: size_t
        """
        return _ida_pro.strvec_t___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        r"""


        __setitem__(self, i, v)
            i: size_t
            v: simpleline_t const &
        """
        return _ida_pro.strvec_t___setitem__(self, *args)

    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator


# Register strvec_t in _ida_pro:
_ida_pro.strvec_t_swigregister(strvec_t)

class sizevec_t(object):
    r"""
    Proxy of C++ qvector< size_t > class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        __init__(self) -> sizevec_t
            x: qvector< size_t > const &
        """
        _ida_pro.sizevec_t_swiginit(self, _ida_pro.new_sizevec_t(*args))
    __swig_destroy__ = _ida_pro.delete_sizevec_t

    def push_back(self, *args) -> "size_t &":
        r"""


        push_back(self, x)
            x: size_t const &
        """
        return _ida_pro.sizevec_t_push_back(self, *args)

    def pop_back(self, *args) -> "void":
        r"""
        pop_back(self)
        """
        return _ida_pro.sizevec_t_pop_back(self, *args)

    def size(self, *args) -> "size_t":
        r"""
        size(self) -> size_t
        """
        return _ida_pro.sizevec_t_size(self, *args)

    def empty(self, *args) -> "bool":
        r"""
        empty(self) -> bool
        """
        return _ida_pro.sizevec_t_empty(self, *args)

    def at(self, *args) -> "size_t const &":
        r"""


        at(self, _idx) -> size_t const &
            _idx: size_t
        """
        return _ida_pro.sizevec_t_at(self, *args)

    def qclear(self, *args) -> "void":
        r"""
        qclear(self)
        """
        return _ida_pro.sizevec_t_qclear(self, *args)

    def clear(self, *args) -> "void":
        r"""
        clear(self)
        """
        return _ida_pro.sizevec_t_clear(self, *args)

    def resize(self, *args) -> "void":
        r"""


        resize(self, _newsize, x)
            _newsize: size_t
            x: size_t const &
        

        resize(self, _newsize)
            _newsize: size_t
        """
        return _ida_pro.sizevec_t_resize(self, *args)

    def grow(self, *args) -> "void":
        r"""


        grow(self, x=size_t())
            x: size_t const &
        """
        return _ida_pro.sizevec_t_grow(self, *args)

    def capacity(self, *args) -> "size_t":
        r"""
        capacity(self) -> size_t
        """
        return _ida_pro.sizevec_t_capacity(self, *args)

    def reserve(self, *args) -> "void":
        r"""


        reserve(self, cnt)
            cnt: size_t
        """
        return _ida_pro.sizevec_t_reserve(self, *args)

    def truncate(self, *args) -> "void":
        r"""
        truncate(self)
        """
        return _ida_pro.sizevec_t_truncate(self, *args)

    def swap(self, *args) -> "void":
        r"""


        swap(self, r)
            r: qvector< size_t > &
        """
        return _ida_pro.sizevec_t_swap(self, *args)

    def extract(self, *args) -> "size_t *":
        r"""
        extract(self) -> size_t *
        """
        return _ida_pro.sizevec_t_extract(self, *args)

    def inject(self, *args) -> "void":
        r"""


        inject(self, s, len)
            s: size_t *
            len: size_t
        """
        return _ida_pro.sizevec_t_inject(self, *args)

    def __eq__(self, *args) -> "bool":
        r"""


        __eq__(self, r) -> bool
            r: qvector< size_t > const &
        """
        return _ida_pro.sizevec_t___eq__(self, *args)

    def __ne__(self, *args) -> "bool":
        r"""


        __ne__(self, r) -> bool
            r: qvector< size_t > const &
        """
        return _ida_pro.sizevec_t___ne__(self, *args)

    def begin(self, *args) -> "qvector< size_t >::const_iterator":
        r"""
        begin(self) -> qvector< size_t >::iterator
        begin(self) -> qvector< size_t >::const_iterator
        """
        return _ida_pro.sizevec_t_begin(self, *args)

    def end(self, *args) -> "qvector< size_t >::const_iterator":
        r"""
        end(self) -> qvector< size_t >::iterator
        end(self) -> qvector< size_t >::const_iterator
        """
        return _ida_pro.sizevec_t_end(self, *args)

    def insert(self, *args) -> "qvector< size_t >::iterator":
        r"""


        insert(self, it, x) -> qvector< size_t >::iterator
            it: qvector< size_t >::iterator
            x: size_t const &
        """
        return _ida_pro.sizevec_t_insert(self, *args)

    def erase(self, *args) -> "qvector< size_t >::iterator":
        r"""


        erase(self, it) -> qvector< size_t >::iterator
            it: qvector< size_t >::iterator
        

        erase(self, first, last) -> qvector< size_t >::iterator
            first: qvector< size_t >::iterator
            last: qvector< size_t >::iterator
        """
        return _ida_pro.sizevec_t_erase(self, *args)

    def find(self, *args) -> "qvector< size_t >::const_iterator":
        r"""


        find(self, x) -> qvector< size_t >::iterator
            x: size_t const &
        

        find(self, x) -> qvector< size_t >::const_iterator
            x: size_t const &
        """
        return _ida_pro.sizevec_t_find(self, *args)

    def has(self, *args) -> "bool":
        r"""


        has(self, x) -> bool
            x: size_t const &
        """
        return _ida_pro.sizevec_t_has(self, *args)

    def add_unique(self, *args) -> "bool":
        r"""


        add_unique(self, x) -> bool
            x: size_t const &
        """
        return _ida_pro.sizevec_t_add_unique(self, *args)

    def _del(self, *args) -> "bool":
        r"""


        _del(self, x) -> bool
            x: size_t const &
        """
        return _ida_pro.sizevec_t__del(self, *args)

    def __len__(self, *args) -> "size_t":
        r"""
        __len__(self) -> size_t
        """
        return _ida_pro.sizevec_t___len__(self, *args)

    def __getitem__(self, *args) -> "size_t const &":
        r"""


        __getitem__(self, i) -> size_t const &
            i: size_t
        """
        return _ida_pro.sizevec_t___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        r"""


        __setitem__(self, i, v)
            i: size_t
            v: size_t const &
        """
        return _ida_pro.sizevec_t___setitem__(self, *args)

    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator


# Register sizevec_t in _ida_pro:
_ida_pro.sizevec_t_swigregister(sizevec_t)


def qstrvec_t_create(*args) -> "PyObject *":
    r"""
    qstrvec_t_create() -> PyObject *
    """
    return _ida_pro.qstrvec_t_create(*args)

def qstrvec_t_destroy(*args) -> "bool":
    r"""


    qstrvec_t_destroy(py_obj) -> bool
        py_obj: PyObject *
    """
    return _ida_pro.qstrvec_t_destroy(*args)

def qstrvec_t_get_clink(*args) -> "qstrvec_t *":
    r"""


    qstrvec_t_get_clink(_self) -> qstrvec_t *
        self: PyObject *
    """
    return _ida_pro.qstrvec_t_get_clink(*args)

def qstrvec_t_get_clink_ptr(*args) -> "PyObject *":
    r"""


    qstrvec_t_get_clink_ptr(_self) -> PyObject *
        self: PyObject *
    """
    return _ida_pro.qstrvec_t_get_clink_ptr(*args)

def qstrvec_t_assign(*args) -> "bool":
    r"""


    qstrvec_t_assign(_self, other) -> bool
        self: PyObject *
        other: PyObject *
    """
    return _ida_pro.qstrvec_t_assign(*args)

def qstrvec_t_addressof(*args) -> "PyObject *":
    r"""


    qstrvec_t_addressof(_self, idx) -> PyObject *
        self: PyObject *
        idx: size_t
    """
    return _ida_pro.qstrvec_t_addressof(*args)

def qstrvec_t_set(*args) -> "bool":
    r"""


    qstrvec_t_set(_self, idx, s) -> bool
        self: PyObject *
        idx: size_t
        s: char const *
    """
    return _ida_pro.qstrvec_t_set(*args)

def qstrvec_t_from_list(*args) -> "bool":
    r"""


    qstrvec_t_from_list(_self, py_list) -> bool
        self: PyObject *
        py_list: PyObject *
    """
    return _ida_pro.qstrvec_t_from_list(*args)

def qstrvec_t_size(*args) -> "size_t":
    r"""


    qstrvec_t_size(_self) -> size_t
        self: PyObject *
    """
    return _ida_pro.qstrvec_t_size(*args)

def qstrvec_t_get(*args) -> "PyObject *":
    r"""


    qstrvec_t_get(_self, idx) -> PyObject *
        self: PyObject *
        idx: size_t
    """
    return _ida_pro.qstrvec_t_get(*args)

def qstrvec_t_add(*args) -> "bool":
    r"""


    qstrvec_t_add(_self, s) -> bool
        self: PyObject *
        s: char const *
    """
    return _ida_pro.qstrvec_t_add(*args)

def qstrvec_t_clear(*args) -> "bool":
    r"""


    qstrvec_t_clear(_self, qclear) -> bool
        self: PyObject *
        qclear: bool
    """
    return _ida_pro.qstrvec_t_clear(*args)

def qstrvec_t_insert(*args) -> "bool":
    r"""


    qstrvec_t_insert(_self, idx, s) -> bool
        self: PyObject *
        idx: size_t
        s: char const *
    """
    return _ida_pro.qstrvec_t_insert(*args)

def qstrvec_t_remove(*args) -> "bool":
    r"""


    qstrvec_t_remove(_self, idx) -> bool
        self: PyObject *
        idx: size_t
    """
    return _ida_pro.qstrvec_t_remove(*args)

def str2user(*args) -> "PyObject *":
    r"""


    str2user(str) -> PyObject *
    Insert C-style escape characters to string
    
    @return: new string with escape characters inserted
    """
    return _ida_pro.str2user(*args)
class uchar_array(object):
    r"""
    Proxy of C++ uchar_array class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        __init__(self, nelements) -> uchar_array
            nelements: size_t
        """
        _ida_pro.uchar_array_swiginit(self, _ida_pro.new_uchar_array(*args))
    __swig_destroy__ = _ida_pro.delete_uchar_array

    def __getitem__(self, *args) -> "uchar":
        r"""


        __getitem__(self, index) -> uchar
            index: size_t
        """
        return _ida_pro.uchar_array___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        r"""


        __setitem__(self, index, value)
            index: size_t
            value: uchar
        """
        return _ida_pro.uchar_array___setitem__(self, *args)

    def cast(self, *args) -> "uchar *":
        r"""
        cast(self) -> uchar *
        """
        return _ida_pro.uchar_array_cast(self, *args)

    @staticmethod
    def frompointer(*args) -> "uchar_array *":
        r"""


        frompointer(t) -> uchar_array
            t: uchar *
        """
        return _ida_pro.uchar_array_frompointer(*args)

# Register uchar_array in _ida_pro:
_ida_pro.uchar_array_swigregister(uchar_array)

def uchar_array_frompointer(*args) -> "uchar_array *":
    r"""


    uchar_array_frompointer(t) -> uchar_array
        t: uchar *
    """
    return _ida_pro.uchar_array_frompointer(*args)

class tid_array(object):
    r"""
    Proxy of C++ tid_array class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        __init__(self, nelements) -> tid_array
            nelements: size_t
        """
        _ida_pro.tid_array_swiginit(self, _ida_pro.new_tid_array(*args))
    __swig_destroy__ = _ida_pro.delete_tid_array

    def __getitem__(self, *args) -> "tid_t":
        r"""


        __getitem__(self, index) -> tid_t
            index: size_t
        """
        return _ida_pro.tid_array___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        r"""


        __setitem__(self, index, value)
            index: size_t
            value: tid_t
        """
        return _ida_pro.tid_array___setitem__(self, *args)

    def cast(self, *args) -> "tid_t *":
        r"""
        cast(self) -> tid_t *
        """
        return _ida_pro.tid_array_cast(self, *args)

    @staticmethod
    def frompointer(*args) -> "tid_array *":
        r"""


        frompointer(t) -> tid_array
            t: tid_t *
        """
        return _ida_pro.tid_array_frompointer(*args)

# Register tid_array in _ida_pro:
_ida_pro.tid_array_swigregister(tid_array)

def tid_array_frompointer(*args) -> "tid_array *":
    r"""


    tid_array_frompointer(t) -> tid_array
        t: tid_t *
    """
    return _ida_pro.tid_array_frompointer(*args)

class ea_array(object):
    r"""
    Proxy of C++ ea_array class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        __init__(self, nelements) -> ea_array
            nelements: size_t
        """
        _ida_pro.ea_array_swiginit(self, _ida_pro.new_ea_array(*args))
    __swig_destroy__ = _ida_pro.delete_ea_array

    def __getitem__(self, *args) -> "ea_t":
        r"""


        __getitem__(self, index) -> ea_t
            index: size_t
        """
        return _ida_pro.ea_array___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        r"""


        __setitem__(self, index, value)
            index: size_t
            value: ea_t
        """
        return _ida_pro.ea_array___setitem__(self, *args)

    def cast(self, *args) -> "ea_t *":
        r"""
        cast(self) -> ea_t *
        """
        return _ida_pro.ea_array_cast(self, *args)

    @staticmethod
    def frompointer(*args) -> "ea_array *":
        r"""


        frompointer(t) -> ea_array
            t: ea_t *
        """
        return _ida_pro.ea_array_frompointer(*args)

# Register ea_array in _ida_pro:
_ida_pro.ea_array_swigregister(ea_array)

def ea_array_frompointer(*args) -> "ea_array *":
    r"""


    ea_array_frompointer(t) -> ea_array
        t: ea_t *
    """
    return _ida_pro.ea_array_frompointer(*args)

class sel_array(object):
    r"""
    Proxy of C++ sel_array class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        __init__(self, nelements) -> sel_array
            nelements: size_t
        """
        _ida_pro.sel_array_swiginit(self, _ida_pro.new_sel_array(*args))
    __swig_destroy__ = _ida_pro.delete_sel_array

    def __getitem__(self, *args) -> "sel_t":
        r"""


        __getitem__(self, index) -> sel_t
            index: size_t
        """
        return _ida_pro.sel_array___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        r"""


        __setitem__(self, index, value)
            index: size_t
            value: sel_t
        """
        return _ida_pro.sel_array___setitem__(self, *args)

    def cast(self, *args) -> "sel_t *":
        r"""
        cast(self) -> sel_t *
        """
        return _ida_pro.sel_array_cast(self, *args)

    @staticmethod
    def frompointer(*args) -> "sel_array *":
        r"""


        frompointer(t) -> sel_array
            t: sel_t *
        """
        return _ida_pro.sel_array_frompointer(*args)

# Register sel_array in _ida_pro:
_ida_pro.sel_array_swigregister(sel_array)

def sel_array_frompointer(*args) -> "sel_array *":
    r"""


    sel_array_frompointer(t) -> sel_array
        t: sel_t *
    """
    return _ida_pro.sel_array_frompointer(*args)

class uval_array(object):
    r"""
    Proxy of C++ uval_array class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        __init__(self, nelements) -> uval_array
            nelements: size_t
        """
        _ida_pro.uval_array_swiginit(self, _ida_pro.new_uval_array(*args))
    __swig_destroy__ = _ida_pro.delete_uval_array

    def __getitem__(self, *args) -> "uval_t":
        r"""


        __getitem__(self, index) -> uval_t
            index: size_t
        """
        return _ida_pro.uval_array___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        r"""


        __setitem__(self, index, value)
            index: size_t
            value: uval_t
        """
        return _ida_pro.uval_array___setitem__(self, *args)

    def cast(self, *args) -> "uval_t *":
        r"""
        cast(self) -> uval_t *
        """
        return _ida_pro.uval_array_cast(self, *args)

    @staticmethod
    def frompointer(*args) -> "uval_array *":
        r"""


        frompointer(t) -> uval_array
            t: uval_t *
        """
        return _ida_pro.uval_array_frompointer(*args)

# Register uval_array in _ida_pro:
_ida_pro.uval_array_swigregister(uval_array)

def uval_array_frompointer(*args) -> "uval_array *":
    r"""


    uval_array_frompointer(t) -> uval_array
        t: uval_t *
    """
    return _ida_pro.uval_array_frompointer(*args)

class int_pointer(object):
    r"""
    Proxy of C++ int_pointer class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(self) -> int_pointer
        """
        _ida_pro.int_pointer_swiginit(self, _ida_pro.new_int_pointer(*args))
    __swig_destroy__ = _ida_pro.delete_int_pointer

    def assign(self, *args) -> "void":
        r"""


        assign(self, value)
            value: int
        """
        return _ida_pro.int_pointer_assign(self, *args)

    def value(self, *args) -> "int":
        r"""
        value(self) -> int
        """
        return _ida_pro.int_pointer_value(self, *args)

    def cast(self, *args) -> "int *":
        r"""
        cast(self) -> int *
        """
        return _ida_pro.int_pointer_cast(self, *args)

    @staticmethod
    def frompointer(*args) -> "int_pointer *":
        r"""


        frompointer(t) -> int_pointer
            t: int *
        """
        return _ida_pro.int_pointer_frompointer(*args)

# Register int_pointer in _ida_pro:
_ida_pro.int_pointer_swigregister(int_pointer)

def int_pointer_frompointer(*args) -> "int_pointer *":
    r"""


    int_pointer_frompointer(t) -> int_pointer
        t: int *
    """
    return _ida_pro.int_pointer_frompointer(*args)

class ea_pointer(object):
    r"""
    Proxy of C++ ea_pointer class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(self) -> ea_pointer
        """
        _ida_pro.ea_pointer_swiginit(self, _ida_pro.new_ea_pointer(*args))
    __swig_destroy__ = _ida_pro.delete_ea_pointer

    def assign(self, *args) -> "void":
        r"""


        assign(self, value)
            value: ea_t
        """
        return _ida_pro.ea_pointer_assign(self, *args)

    def value(self, *args) -> "ea_t":
        r"""
        value(self) -> ea_t
        """
        return _ida_pro.ea_pointer_value(self, *args)

    def cast(self, *args) -> "ea_t *":
        r"""
        cast(self) -> ea_t *
        """
        return _ida_pro.ea_pointer_cast(self, *args)

    @staticmethod
    def frompointer(*args) -> "ea_pointer *":
        r"""


        frompointer(t) -> ea_pointer
            t: ea_t *
        """
        return _ida_pro.ea_pointer_frompointer(*args)

# Register ea_pointer in _ida_pro:
_ida_pro.ea_pointer_swigregister(ea_pointer)

def ea_pointer_frompointer(*args) -> "ea_pointer *":
    r"""


    ea_pointer_frompointer(t) -> ea_pointer
        t: ea_t *
    """
    return _ida_pro.ea_pointer_frompointer(*args)

class sval_pointer(object):
    r"""
    Proxy of C++ sval_pointer class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(self) -> sval_pointer
        """
        _ida_pro.sval_pointer_swiginit(self, _ida_pro.new_sval_pointer(*args))
    __swig_destroy__ = _ida_pro.delete_sval_pointer

    def assign(self, *args) -> "void":
        r"""


        assign(self, value)
            value: sval_t
        """
        return _ida_pro.sval_pointer_assign(self, *args)

    def value(self, *args) -> "sval_t":
        r"""
        value(self) -> sval_t
        """
        return _ida_pro.sval_pointer_value(self, *args)

    def cast(self, *args) -> "sval_t *":
        r"""
        cast(self) -> sval_t *
        """
        return _ida_pro.sval_pointer_cast(self, *args)

    @staticmethod
    def frompointer(*args) -> "sval_pointer *":
        r"""


        frompointer(t) -> sval_pointer
            t: sval_t *
        """
        return _ida_pro.sval_pointer_frompointer(*args)

# Register sval_pointer in _ida_pro:
_ida_pro.sval_pointer_swigregister(sval_pointer)

def sval_pointer_frompointer(*args) -> "sval_pointer *":
    r"""


    sval_pointer_frompointer(t) -> sval_pointer
        t: sval_t *
    """
    return _ida_pro.sval_pointer_frompointer(*args)

class sel_pointer(object):
    r"""
    Proxy of C++ sel_pointer class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(self) -> sel_pointer
        """
        _ida_pro.sel_pointer_swiginit(self, _ida_pro.new_sel_pointer(*args))
    __swig_destroy__ = _ida_pro.delete_sel_pointer

    def assign(self, *args) -> "void":
        r"""


        assign(self, value)
            value: sel_t
        """
        return _ida_pro.sel_pointer_assign(self, *args)

    def value(self, *args) -> "sel_t":
        r"""
        value(self) -> sel_t
        """
        return _ida_pro.sel_pointer_value(self, *args)

    def cast(self, *args) -> "sel_t *":
        r"""
        cast(self) -> sel_t *
        """
        return _ida_pro.sel_pointer_cast(self, *args)

    @staticmethod
    def frompointer(*args) -> "sel_pointer *":
        r"""


        frompointer(t) -> sel_pointer
            t: sel_t *
        """
        return _ida_pro.sel_pointer_frompointer(*args)

# Register sel_pointer in _ida_pro:
_ida_pro.sel_pointer_swigregister(sel_pointer)

def sel_pointer_frompointer(*args) -> "sel_pointer *":
    r"""


    sel_pointer_frompointer(t) -> sel_pointer
        t: sel_t *
    """
    return _ida_pro.sel_pointer_frompointer(*args)


#<pycode(py_pro)>
import ida_idaapi

int64vec_t = longlongvec_t
uint64vec_t = ulonglongvec_t
if ida_idaapi.__EA64__:
    svalvec_t = longlongvec_t
    uvalvec_t = ulonglongvec_t
else:
    svalvec_t = intvec_t
    uvalvec_t = uintvec_t
eavec_t = uvalvec_t

ida_idaapi._listify_types(
        intvec_t,
        uintvec_t,
        longlongvec_t,
        ulonglongvec_t,
        boolvec_t,
        strvec_t)

# -----------------------------------------------------------------------
# qstrvec_t clinked object
class _qstrvec_t(ida_idaapi.py_clinked_object_t):
    """
    WARNING: It is very unlikely an IDAPython user should ever, ever
    have to use this type. It should only be used for IDAPython internals.

    For example, in py_askusingform.py, we ctypes-expose to the IDA
    kernel & UI a qstrvec instance, in case a DropdownListControl is
    constructed.
    That's because that's what ask_form expects, and we have no
    choice but to make a DropdownListControl hold a qstrvec_t.
    This is, afaict, the only situation where a Python
    _qstrvec_t is required.
    """

    def __init__(self, items=None):
        ida_idaapi.py_clinked_object_t.__init__(self)
# Populate the list if needed
        if items:
            self.from_list(items)

    def _create_clink(self):
        return _ida_pro.qstrvec_t_create()

    def _del_clink(self, lnk):
        return _ida_pro.qstrvec_t_destroy(lnk)

    def _get_clink_ptr(self):
        return _ida_pro.qstrvec_t_get_clink_ptr(self)

    def assign(self, other):
        """
        Copies the contents of 'other' to 'self'
        """
        return _ida_pro.qstrvec_t_assign(self, other)

    def __setitem__(self, idx, s):
        """
        Sets string at the given index
        """
        return _ida_pro.qstrvec_t_set(self, idx, s)

    def __getitem__(self, idx):
        """
        Gets the string at the given index
        """
        return _ida_pro.qstrvec_t_get(self, idx)

    def __get_size(self):
        return _ida_pro.qstrvec_t_size(self)

    size = property(__get_size)
    """
    Returns the count of elements
    """

    def addressof(self, idx):
        """
        Returns the address (as number) of the qstring at the given index
        """
        return _ida_pro.qstrvec_t_addressof(self, idx)

    def add(self, s):
        """
        Add a string to the vector
        """
        return _ida_pro.qstrvec_t_add(self, s)

    def from_list(self, lst):
        """
        Populates the vector from a Python string list
        """
        return _ida_pro.qstrvec_t_from_list(self, lst)

    def clear(self, qclear=False):
        """
        Clears all strings from the vector.
        @param qclear: Just reset the size but do not actually free the memory
        """
        return _ida_pro.qstrvec_t_clear(self, qclear)

    def insert(self, idx, s):
        """
        Insert a string into the vector
        """
        return _ida_pro.qstrvec_t_insert(self, idx, s)

    def remove(self, idx):
        """
        Removes a string from the vector
        """
        return _ida_pro.qstrvec_t_remove(self, idx)

#</pycode(py_pro)>


if _BC695:
    def strlwr(s):
        return str(s).lower()
    def strupr(s):
        return str(s).upper()



